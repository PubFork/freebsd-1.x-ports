 -*- Mode: Text;  -*-
File: PORTING
Author: Heinz W. Schmidt (hws@csis.dit.csiro.au)
(c) Commonwealth Scientific and Industrial Research Organisation (CSIRO),
Australia, 1992, 1993. 
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

See the FAQ for currently supported platforms and platforms for which we know
of ports.  Before starting a major effort, you may also contact

		    sather-admin@icsi.berkeley.edu

to find out whether there are ports to other platforms. 


The currently included ports involved many contributions since 1991.
Particularly we would like to thank:

Michael Arnoldus, Gerd Aschemann, Jonathan Bachrach, Oscar Bosman, Timothy J.
Burr, Matthew Deshon, Andrew Duckworth, Bill Foote, Dov Grobgeld, Hiroshi
Harada, Nobuyuki Hikichi, Lee Iverson, Kimmo Lahtinen, Gerhard Goos, Patrick
Moran, Jean-Jacques Moreau, Kevin Trojanowski, Daniel S. Rice, Brian Rogoff

The following sections explain machine dependencies of the system and how we
have set up the structure to work with the currently supported architectures.
You will also find instructions for where to change things if you need to
change them.

IF YOU NEED TO CHANGE A FILE TO MAKE IT WORK ON YOUR PLATFORM, PLEASE CARE TO
SEND A SHORT DIFF TO sather-admin@icsi.berkeley.edu. You may perhaps save
many people a little effort (= avoid a lot of effort?).

In order to simplify installing and porting the system across a number of
platforms we must make minimum assumptions about the availability of basic
features and also sometimes conditionalize the code and installation procedure.
For instance we used "include" in make files in an intermediate version of the
system. But "make" does not support it on all platforms and users may choose
different make facilities, such as the Berkeley pmake, which does not support
"include" but has an "#include" instead.  

The make files are therefore generated in a "configure" step. This step uses a
template file called "Makefile.in" to generate a "Makefile", for many
directories. It prepends environment settings to these make file templates.  An
environment is defined as a triple: architecture ($ARCH), operating system
($OS), and language (or libraries, if you wish, $CLANG). 

"configure" guesses $ARCH and $OS by default. When porting to new platform
you try make/config.guess and make/arch.guess, to see whether these guesses
are ok. If not add to the guesses in these shell scripts. You have to choose
$CLANG, currently "kr" or "". This will be appended to $ARCH to make
the value the user calls $SATHER_ENVI (and called $ENVI in some configure
files). "configure" also chooses commands to use with /bin/sh to run
make scripts. It uses the file make/envi.locate for the purpose.
If commands used in Makefiles are in nonstandard directories on your
platform you may have to add a line or two to make/envi.locate.

Two files overwrite guesses: 

* make/DEFSITE contains site specific definitions.
  The parameters in this file will be defined by the user installing the system,
  once you have ported it. The funny "@" values like @CLANG@ represent parameters
  that "configure" will replace by some defaults. Typically when porting you
  do not want to change DEFSITE but may want to use command line options
  to configure to overwrite the settings. For details of command line options
  see the file make/config.in.

* make/$SATHER_ENVI contains compiler choices and options for the given target.
  When you port the file for your platform will be missing. Consequently
  the "configure" step will complain about that missing file. The first
  thing here will be to supply such a file following close platforms as
  examples.

SATHER_ENVI -- Selecting an environment
=======================================

Currently $SATHER_ENVI mainly selects 

  bin.$SATHER_ENVI: compiler, libraries, executables, precompiled classes
  make/$SATHER_ENVI: make compiler and option choices
  
Moreover the sather compiler needs to know about some of the dependencies too
since it generates a make file too to compile the C files it generates.  We
want that a naive call to the compiler works too, such as "cs hello". While
users can exploit (c_flags) options in the .sather file to pass architecture
specific information into make files generated by the Sather compiler, the make
files used in the system installation use command line options to the Sather
compiler to avoid the need to conditionalize system .sather files for different
architectures like the compiler/.sather.  The only conditionalization is in
terms of pathnames. The compiler interprets all environment variables that
appear in a .sather file, including the file sys/sys_dot_sather which defines
compilation defaults for all compilations. Currently this file only includes
the variables $SATHER_HOME and $SATHER_ENVI.


#ifdef -- Machine Dependent Files
=================================

Several runtime and basic support C sources are conditionalized.

        compiler/timer.c
	lib/base/C/*_.c
	  lib/base/C/time_.c (particularly)
	sys/C/*_.c
          sys/C/envivars_.c (particularly)
	  sys/C/macros_.c
	sys/C/all_.h

Moreover all the GC and DBG support is conditionalized, for these see the
section below.

In general you have to watch out for a few files in sys/C and lib/base/C
directories only. lib/base/C contains the basic system dependent C code that
Sather base classes may refer to. sys/C contains things like the runtime system
and files needed in Sather code in general.


Sather compiler
===============

The compiler itself does use only a few of the lib/base C files.  Cf.
compiler/.sather for more details.

The compiler is configured using the template file

	compiler/install.sa

This file is edited in a make step automatically. Relevant site and target
system defaults are burnt into it before the boot compiler (C) compiles this
file.  Make file settings will be passed on into the Sather code.  Indeed, the
boot compiler only compiles an architecture specific version of the file called
in-$SATHER_ENVI.sa. You can create this file using "make arch-install" in the
compiler directory once you have setup the system using "make config". How does
the boot compiler (distributed C code) know the options? The compiler relies on
as few options as possible.  These are passed by environment variables. Even if
you have not set them, make steps will export make settings to environment
variables before invoking the boot compiler.

Beside temporary hacks of boot compiler C sources, you should not change boot
compiler C files. Some of the early port reports that we received contained
hacks of the boot compiler that of course will get lost with the next
distribution when a new boot compiler C directory is created from the current
compiler sather sources! Note that once you have ported and can compile the
compiler, you can also create a new boot compiler. See the file doc/DISTRIBUTE
for details once your port is complete and you want to replace your boot
compiler hacks by generated code.


sys/C/GC -- The Garbage Collector
=================================

The current version of the GC is 3.3. It is a public domain GC.  Should the GC
not run on your machine, it maybe worthwhile to check whether a newer version
of the GC runs on your machine. You find the GC on

	ftp.parc.xerox.com pub/russell

Usually a new release does preserve the old interface specification.
In this case you can simply replace the GC and (hopefully) test make it.

	cd sys/C
        make clean
        make

If you have to port the GC to your machine it may be worthwile to first ignore
the GC and try to build a GC-less system. When the "-DGC_" option is omitted in
the compiler C flags, Sather will not want the GC.  The documentation in the GC
distribution contains details of how to port the GC. The main extensions will
be in gc.h and the few sys/C/GC/*.c files at places indicated by comments like

        >>> fix it here <<< 

Read the documentation to find out about the function of each of these files.
Note that on some systems you may need to write about ten lines of assembler
code that copy the contents of data registers (possibly references to objects)
to be traced by the GC when it starts chasing objects.


debugger/C -- The Sather Debugger
=================================

The current distribution contains the Sather debugger SDB for Sun sparc
processors only. This is not a fundamental problem but a matter of not having
found time to include other versions. SDB builds on GNU GDB. The debugger/C
directory contains a copy of the relevant GDB files configured for sparc
processors.

If you are familiar with the GDB installation you may go ahead and install your
version.  Do not forget to change Mkf.mach.cpp to NOT SKIP the sdb installation
on your architecture, once you have added the right GDB files. Cf. the macro
SKIPSDB there.

Here is how you might proceed. Our plan was to create a subdirectory
gdb.$SATHER_ENVI that contains only the $SATHER_ENVI dependent files of gdb. I
believe these are 4 or 5 files. And they should be linked to the debugger/C
directory. The debugger/C make file can be changed to take care of linking the
respective debugger/C files to the right gdb.$SATHER_ENVI files. Then "make"
taps the right directory for each architecture.  You will perhaps find a better
scheme that could serve several architectures in one directory tree.


Pathname Problems?
==================

All pathname canonicalization of the Sather compiler goes through one function
in the class UNIX_PATH now (lib/base/pathname.sa).  pathname.sa allows users to
have arbitrary environment variables in .sather files. Note that this includes
canonicalization of any tokens in .sather files since the compiler passes them
all through this function.

BEWARE OF RANDOM USE OF VARIABLES IN .sather, YOU MAY WANT TO DISTRIBUTE
SOURCES AT SOME POINT IN TIME!

However variables used in moderation can help conditionalize your compilations
appropriately. Note that some .sather files contain paths like:

${SATHER_HOME}/bin.${SATHER_ENVI}/runtime_.o

The variables in these paths are not recognized by lib/base/pathname.sa which
only accepts literal variables. Consequently these paths will be taken
literally. This is fine for (object_files) paths which will be copied into the
generated Makefile and therefore the contained variables can be viewed as
Makefile macros that are expanded in the target system.  This may be important
in case you need cross compilation.


Untested Archtitecture Dependencies
===================================

We have integrated several changes that were reported on the list to be
necessary to make Sather run on a particular architecture. As mentioned above,
we do not have all machines around for testing and therefore it is quite
probable that you will find some fixes introduced for your sort of machine but
still other parts missing.  If you have to fix Sather, once again, care to send
fixes to 
			sather-admin@icsi.berkeley.edu

and also tells us whether our "dry" ports work if you run the system without
changes on a machine not mentioned in the list above. Of course we like to
extend the list.

If you are porting to a new target architecture / Unix system and add a
dependency on a new flag of architecture or Unix system, please update the
Mkf.mach.cpp comments that list all the flags used so far.  This may help
others in detecting problems with #idefs that catch on their machines but are
not meant to. You may use a unique flag for your kind of machine and introduce
it in the make config step, cf. the comments in the file doc/INSTALL.


	Happy Sather hacking!
