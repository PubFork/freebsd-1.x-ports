#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
#line 8 "parser.y"

# include "comp.h"
# include "str.h"
# include "array.h"
# include "object.h"
# include "xfloat.h"
# include "interpret.h"
# include "macro.h"
# include "token.h"
# include "ppcontrol.h"
# include "node.h"
# include "compile.h"

# define yylex		pp_gettok
# define yyerror	c_error

int nerrors;			/* number of errors encountered so far */
static int ndeclarations;	/* number of declarations */
static int nstatements;		/* number of statements in current function */
static bool typechecking;	/* does the current function have it? */

static void  t_void	P((node*));
static bool  t_unary	P((node*, char*));
static node *uassign	P((int, node*, char*));
static node *cast	P((node*, unsigned short));
static node *idx	P((node*, node*));
static node *range	P((node*, node*, node*));
static node *bini	P((int, node*, node*, char*));
static node *bina	P((int, node*, node*, char*));
static node *mult	P((int, node*, node*, char*));
static node *mdiv	P((int, node*, node*, char*));
static node *mod	P((int, node*, node*, char*));
static node *add	P((int, node*, node*, char*));
static node *sub	P((int, node*, node*, char*));
static node *umin	P((node*));
static node *lshift	P((int, node*, node*, char*));
static node *rshift	P((int, node*, node*, char*));
static node *rel	P((int, node*, node*, char*));
static node *eq		P((node*, node*));
static node *and	P((int, node*, node*, char*));
static node *xor	P((int, node*, node*, char*));
static node *or		P((int, node*, node*, char*));
static node *land	P((node*, node*));
static node *lor	P((node*, node*));
static node *quest	P((node*, node*, node*));
static node *assign	P((node*, node*));

#line 72 "parser.y"
typedef union {
    Int number;			/* lex input */
    xfloat real;		/* lex input */
    unsigned short type;	/* internal */
    struct _node_ *node;	/* internal */
} YYSTYPE;
#line 67 "y.tab.c"
#define FOR 257
#define VOID 258
#define DO 259
#define CONTINUE 260
#define INHERIT 261
#define MAPPING 262
#define INT 263
#define LOCK 264
#define NOMASK 265
#define CATCH 266
#define CASE 267
#define FLOAT 268
#define BREAK 269
#define MIXED 270
#define STATIC 271
#define VARARGS 272
#define STRING 273
#define ELSE 274
#define IF 275
#define WHILE 276
#define SWITCH 277
#define DEFAULT 278
#define RETURN 279
#define PRIVATE 280
#define OBJECT 281
#define ARROW 282
#define PLUS_PLUS 283
#define MIN_MIN 284
#define LSHIFT 285
#define RSHIFT 286
#define LE 287
#define GE 288
#define EQ 289
#define NE 290
#define LAND 291
#define LOR 292
#define PLUS_EQ 293
#define MIN_EQ 294
#define MULT_EQ 295
#define DIV_EQ 296
#define MOD_EQ 297
#define LSHIFT_EQ 298
#define RSHIFT_EQ 299
#define AND_EQ 300
#define XOR_EQ 301
#define OR_EQ 302
#define COLON_COLON 303
#define DOT_DOT 304
#define ELLIPSIS 305
#define STRING_CONST 306
#define IDENTIFIER 307
#define INT_CONST 308
#define FLOAT_CONST 309
#define MARK 310
#define HASH 311
#define HASH_HASH 312
#define INCL_CONST 313
#define NR_TOKENS 314
#define YYERRCODE 256
short yylhs[] = {                                        -1,
   49,    0,   48,   48,   50,   50,   50,    5,    5,   47,
    7,    7,    6,   51,   53,   52,   54,   52,   55,    8,
    8,    8,    8,    9,    9,   10,   10,    1,    1,    2,
    2,    2,    2,    3,    3,    3,    3,    3,    3,    3,
    4,    4,   11,   12,   13,   13,   14,   14,   15,   15,
   16,   16,   16,   17,   17,   17,   17,   56,   17,   57,
   17,   58,   17,   59,   17,   60,   17,   61,   17,   62,
   17,   17,   17,   17,   17,   63,   18,   19,   19,   19,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   21,   21,   21,   22,   22,   22,   23,   23,   23,
   23,   23,   23,   23,   24,   24,   25,   25,   25,   25,
   26,   26,   26,   27,   27,   27,   28,   28,   28,   28,
   28,   29,   29,   29,   30,   30,   31,   31,   32,   32,
   33,   33,   34,   34,   35,   35,   36,   36,   36,   36,
   36,   36,   36,   36,   36,   36,   36,   36,   37,   37,
   38,   38,   39,   40,   41,   41,   42,   42,   42,   43,
   43,   43,   44,   45,   45,   46,   46,   46,
};
short yylen[] = {                                         2,
    0,    2,    0,    2,    4,    1,    1,    0,    1,    1,
    1,    3,    1,    4,    0,    5,    0,    7,    4,    0,
    1,    1,    2,    1,    3,    2,    1,    0,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    0,    2,    2,    5,    1,    1,    1,    3,    0,    2,
    1,    1,    2,    2,    1,    5,    7,    0,    8,    0,
    6,    0,   10,    0,    6,    0,    5,    0,    7,    0,
    4,    2,    2,    3,    1,    0,    4,    1,    2,    3,
    1,    1,    1,    5,    5,    1,    3,    4,    4,    4,
    6,    1,    4,    6,    1,    2,    2,    1,    2,    2,
    2,    2,    2,    2,    1,    5,    1,    3,    3,    3,
    1,    3,    3,    1,    3,    3,    1,    3,    3,    3,
    3,    1,    3,    3,    1,    3,    1,    3,    1,    3,
    1,    3,    1,    3,    1,    5,    1,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    1,    3,
    0,    1,    1,    1,    1,    3,    0,    1,    2,    0,
    1,    2,    3,    1,    3,    0,    1,    2,
};
short yydefred[] = {                                      1,
    0,    3,    0,    0,    0,    4,    6,    7,   10,    0,
    9,   40,   38,   34,   32,   35,   39,   31,   33,   36,
   30,   37,   29,   41,    0,   13,   11,    0,    0,   45,
    0,   47,    0,    0,    5,    0,   42,    0,    0,   14,
   41,    0,   41,    0,    0,   24,   27,   12,    0,   76,
   16,   46,   48,    0,   26,   17,   23,    0,    0,   49,
   43,    0,   25,   44,    0,   18,    0,    0,   58,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   81,   82,   75,    0,    0,   77,    0,    0,
    0,    0,   83,   50,   52,   55,    0,   92,    0,    0,
  105,  107,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  149,    0,    0,   51,   53,    0,    0,
   73,    0,    0,    0,   72,    0,    0,    0,   70,    0,
  154,    0,   99,  100,   79,  102,    0,    0,   41,    0,
  101,  103,  104,   41,    0,    0,    0,   96,   97,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   54,
    0,    0,    0,    0,    0,    0,    0,   66,    0,    0,
    0,    0,    0,   74,  155,    0,    0,    0,  164,    0,
    0,    0,   87,    0,    0,    0,    0,    0,    0,    0,
  108,  109,  110,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  139,
  140,  141,  142,  143,  144,  145,  146,  147,  148,  138,
  150,   80,    0,    0,   90,   89,    0,    0,    0,   60,
   64,   71,    0,    0,    0,    0,    0,    0,   19,  159,
    0,   88,    0,   93,    0,    0,    0,    0,   68,   67,
    0,    0,    0,  156,   84,  163,  165,   85,  106,    0,
    0,  136,    0,    0,    0,    0,   61,   65,   91,   94,
    0,    0,   69,   57,   62,   59,    0,   63,
};
short yydgoto[] = {                                       1,
    5,   23,   43,   29,   10,   93,   28,   44,   45,   46,
   30,   52,   32,   33,   65,   94,   95,   96,   97,   98,
   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,
  109,  110,  111,  112,  113,  114,  115,  131,  190,  132,
  205,  206,  197,  199,  200,  201,  116,    3,    2,    6,
    7,    8,   39,   62,  117,  120,  272,  297,  273,  248,
  285,  193,   60,
};
short yysindex[] = {                                      0,
    0,    0, -242, -282,  297,    0,    0,    0,    0, -257,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   17,    0,    0,  -12,  -37,    0,
    0,    0,  -21, -100,    0, -257,    0,   28,  -47,    0,
    0,    0,    0,   42,  -38,    0,    0,    0, -100,    0,
    0,    0,    0,  -37,    0,    0,    0,  350,   46,    0,
    0,  -47,    0,    0,   34,    0,   50,   77,    0,   62,
   83,   86,   13,   72,  104,  110,  113,   97,   13,   13,
   13, -282,    0,    0,    0,   13,  139,    0,   13,   13,
   13,  388,    0,    0,    0,    0,  126,    0,  -83, -172,
    0,    0,   71,   54, -152,   18, -154,  129,   75,   47,
 -115,  -63,  294,    0,    4, -118,    0,    0,   13,   87,
    0,   13,   13,  -26,    0,   13,   13,   13,    0,  143,
    0,  130,    0,    0,    0,    0,   13,   13,    0,   40,
    0,    0,    0,    0,   13, -282,   13,    0,    0,   13,
   13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
   13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
   13,   13,   13,   13,   13,   13,   13,   13,   13,    0,
   13, -282,  131,  -88,   44,   57,   13,    0,  143,  150,
  151,  152,   87,    0,    0,  153,   69,  137,    0,  154,
  103,   99,    0,   10,  -18,  159,  161,  143,  109, -101,
    0,    0,    0,   71,   71,   54,   54, -152, -152, -152,
 -152,   18,   18, -154,  129,   75,   47, -115,    7,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   13,  164,    0,    0,  147,   87,   87,    0,
    0,    0,   13,  165,   13,   13,  170,   13,    0,    0,
   13,    0,   13,    0,   13,   13,  155,   13,    0,    0,
  -59,   87,  -47,    0,    0,    0,    0,    0,    0,  175,
  124,    0,   13,  179,   87,   87,    0,    0,    0,    0,
  180,  163,    0,    0,    0,    0,   87,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    1,  -82,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   -7,    0,    0,  182,    0,    0,    0,   11,    0,    0,
    0,  -39,    0,    0,  184,    0,    0,    0,  182,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  570,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  167,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  418,  459,
    0,    0,  486,  786,  900,   84, 1340, 1409, 1480, 1671,
   31, 1771,  -29,    0,    0,  391,    0,    0,  167,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  -20,
    0,    0,    0,    0,    0,    0,  102,  135,    0,    0,
    0,    0,    0,    0,  190,    0,  -72,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  210,    0,
    0,    0,    0,    0,    0,  174,    0,    0,    0,  195,
    0,    0,    0,    0,  248,    0,    0,  -86,    0,    0,
    0,    0,    0,  513,  604,  823,  874,  928,  968, 1005,
 1270, 1296, 1324, 1364, 1452, 1634, 1742, 1758,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  167,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  177,    0,    0,  199,    0,    0,    0,    0,
    0,    0,  190,    0,  202,    0,    0,    0,    0,    0,
  -23,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  263,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
  242,    0,   23,  -25,    0,   14,    0,  265,    0,  257,
  291,  314,  298,  201,    0,    0, -111,  -35,    0,    0,
    0,    0,    0,  -46,   -5,   -4,  -98,    3,  185,  186,
  187,  183,  191,    0,   91, 1731, 1198, -103, -114, -136,
  222,   98,    0,  111,    0,    0,   37,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,
};
#define YYTABLESIZE 2076
short yytable[] = {                                     168,
    2,   21,   40,   51,   37,   58,  153,  147,  184,   56,
  210,  137,  191,  192,  137,  183,   56,   54,    4,   56,
  152,   56,   41,   27,    9,  261,   66,   24,  137,  137,
   36,  188,  209,  133,  134,   56,   46,   40,  152,  136,
   11,   25,  141,  142,  143,   90,   35,  181,   26,   48,
  181,   46,   87,   41,   43,   86,   34,   89,  218,  219,
  220,  221,  180,  137,  266,   38,   90,   49,  259,   43,
   47,  133,  152,   87,  133,   50,   86,  159,   89,  160,
  203,  252,   56,  181,  245,   47,   64,  181,  133,  133,
   61,  133,   85,  133,   47,  137,  153,  246,  154,   56,
  181,   56,   56,  211,  212,  213,  267,  152,  118,  139,
  148,  149,  150,  202,  144,   15,  119,  151,  135,   90,
  121,  122,  122,  133,  122,  123,   87,  122,  281,   86,
  125,   89,  155,  156,  161,  162,  270,  271,   91,  258,
   37,  122,  122,  126,  122,   85,  122,  214,  215,  127,
  216,  217,  128,  284,  129,  133,   50,   42,   88,   91,
  287,   13,   14,  222,  223,  145,  163,   16,  164,   17,
  165,   90,   20,  293,  294,  166,  122,  122,   87,  291,
   22,   86,  207,   89,  182,  298,  181,  244,  194,  243,
  249,  250,  251,  254,  255,  257,  253,  256,  146,  262,
  263,  264,  265,  268,  269,  275,    9,  122,  122,   50,
  278,  279,   91,  283,  286,  289,  290,  152,  242,  292,
  295,  296,   20,    8,   22,  151,  160,  166,  167,  138,
  157,  151,   56,   56,   56,   56,   56,  288,   56,   56,
   56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
  153,   56,   56,   56,   56,   56,   56,   56,   28,   56,
   56,  137,   28,   28,   91,   28,   57,   40,   28,    9,
   28,   28,   28,   28,  137,  137,   71,  187,   72,   56,
   28,   28,   56,   56,   56,   56,  260,  167,  158,   67,
   68,  168,   69,   70,  151,   80,   81,   71,  161,   72,
   73,  162,   74,  151,  157,  158,   92,   28,   75,   76,
   77,   78,   79,   59,   63,   82,   80,   81,   26,    9,
   83,   84,  133,  133,  133,  133,  133,  133,  133,  133,
  133,  133,  133,   55,  133,  133,   82,   31,   53,   26,
    9,   83,   84,   68,  204,   69,   70,  224,  227,  225,
   71,  226,   72,   73,  179,   74,  282,  228,  196,    0,
  280,   75,   76,   77,   78,   79,  277,    0,    0,   80,
   81,    0,  122,  122,  122,  122,  122,  122,  122,  122,
  122,  122,  122,  122,  122,  122,    0,  122,  122,   82,
    0,    0,   26,    9,   83,   84,   12,    0,    0,    0,
   13,   14,   71,    0,   72,    0,   16,    0,   17,    0,
    0,   20,    0,    0,    0,    0,    0,    0,    0,   22,
    0,   80,   81,    0,    0,    0,    0,   86,   86,    0,
   78,   86,   86,   86,   86,   86,    0,   86,    0,    0,
    0,   82,    0,    0,   26,    9,   83,   84,   86,   86,
   86,   86,   86,   86,   95,   95,    0,    0,   95,   95,
   95,   95,   95,    0,   95,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   95,   95,   95,   95,   95,
   95,   86,    0,   86,   86,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   98,   98,    0,    0,   98,
   98,   98,   98,   98,    0,   98,    0,    0,    0,    0,
   95,   95,    0,    0,   86,   86,   98,   98,   98,   98,
   98,   98,    0,  111,    0,    0,  111,    0,  111,  111,
  111,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   95,   95,  111,  111,  111,  111,  111,  111,    0,
  112,   98,   98,  112,   12,  112,  112,  112,   13,   14,
    0,   15,    0,    0,   16,    0,   17,   18,   19,   20,
  112,  112,  112,  112,  112,  112,   21,   22,  111,  111,
    0,    0,   98,   98,    0,    0,  169,  170,  171,  172,
  173,  174,  175,  176,  177,  178,    0,    0,    0,    0,
    0,    0,    0,    9,    0,  112,  112,   12,    0,  111,
  111,   13,   14,    0,    0,    0,    0,   16,    0,   17,
    0,    0,   20,    0,    0,    0,    0,    0,    0,    0,
   22,    0,    0,    0,    0,    0,  112,  112,    0,    0,
    0,  113,    0,    0,  113,   12,  113,  113,  113,   13,
   14,    0,   15,    0,    0,   16,    9,   17,   18,   19,
   20,  113,  113,  113,  113,  113,  113,   21,   22,    0,
    0,    0,   86,   86,   86,   86,   86,   86,   86,   86,
   86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
   86,   86,   86,    0,   86,   86,  113,  113,    0,    0,
   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
    0,   95,   95,    0,    0,    0,    0,  113,  113,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   98,   98,   98,   98,   98,   98,   98,
   98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
   98,    0,   98,   98,    0,    0,    0,    0,    0,    0,
  111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
  111,  111,  111,  111,  111,  111,  111,  111,    0,  111,
  111,    0,    0,    0,    0,    0,    0,  112,  112,  112,
  112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
  112,  112,  112,  112,  112,    0,  112,  112,    0,    0,
    0,    0,    0,  114,    0,    0,  114,   28,    0,  114,
    0,   28,   28,    0,   28,    0,    0,   28,    0,   28,
   28,   28,   28,  114,  114,  114,  114,  114,  114,   28,
   28,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  115,    0,    0,  115,    0,    0,  115,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  114,  114,
  115,  115,  115,  115,  115,  115,    0,    0,  113,  113,
  113,  113,  113,  113,  113,  113,  113,  113,  113,  113,
  113,  113,  113,  113,  113,  113,    0,  113,  113,  114,
  114,  116,    0,    0,  116,  115,  115,  116,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  116,  116,  116,  116,  116,  116,  117,    0,    0,
  117,    0,    0,  117,    0,    0,  115,  115,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  117,  117,  117,
  117,  117,  117,    0,    0,  120,  116,  116,  120,    0,
    0,  120,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  120,  120,  120,  120,  120,
  120,    0,  117,  117,    0,    0,    0,  116,  116,    0,
    0,    0,    0,    0,    0,  121,    0,    0,  121,    0,
    0,  121,    0,    0,    0,    0,    0,    0,    0,    0,
  120,  120,    0,  117,  117,  121,  121,  121,  121,  121,
  121,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  118,    0,    0,  118,    0,    0,  118,    0,
    0,  120,  120,    0,    0,    0,    0,    0,    0,    0,
  121,  121,  118,  118,  118,  118,  118,  118,    0,    0,
  114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
  114,  114,  114,  114,  114,  114,  114,  114,    0,  114,
  114,  121,  121,    0,    0,    0,    0,  118,  118,    0,
    0,    0,    0,    0,    0,    0,    0,  115,  115,  115,
  115,  115,  115,  115,  115,  115,  115,  115,  115,  115,
  115,  115,  115,  115,  115,    0,  115,  115,  118,  118,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  116,  116,
  116,  116,  116,  116,  116,  116,  116,  116,  116,  116,
  116,  116,  116,  116,  116,  116,    0,  116,  116,    0,
    0,    0,    0,    0,    0,    0,  117,  117,  117,  117,
  117,  117,  117,  117,  117,  117,  117,  117,  117,  117,
  117,  117,    0,  117,  117,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  120,  120,  120,  120,  120,  120,
  120,  120,  120,  120,  120,  120,  120,  120,  120,  120,
    0,  120,  120,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  121,  121,  121,  121,  121,  121,
  121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
    0,  121,  121,    0,    0,    0,  130,    0,    0,    0,
    0,    0,    0,    0,  140,    0,    0,    0,    0,    0,
    0,  118,  118,  118,  118,  118,  118,  118,  118,  118,
  118,  118,  118,  118,  118,  118,  118,  119,  118,  118,
  119,    0,    0,  119,    0,    0,  130,    0,    0,  185,
  186,    0,    0,  189,  189,  189,    0,  119,  119,  119,
  119,  119,  119,  123,    0,    0,  123,    0,    0,  123,
    0,    0,    0,    0,  208,    0,    0,    0,    0,    0,
    0,    0,    0,  123,  123,    0,  123,    0,  123,    0,
    0,  124,  119,  119,  124,  229,    0,  124,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  125,    0,    0,
  125,  124,  124,  125,  124,    0,  124,    0,  123,  123,
    0,    0,    0,  119,  119,    0,    0,  125,  125,    0,
  125,  126,  125,    0,  126,    0,    0,  126,    0,    0,
    0,    0,    0,    0,    0,    0,  124,  124,    0,  123,
  123,  126,  126,    0,  126,    0,  126,    0,    0,    0,
    0,    0,  125,  125,    0,    0,    0,    0,    0,    0,
  130,    0,    0,    0,    0,    0,    0,  124,  124,  127,
    0,    0,  127,    0,    0,    0,  126,  126,    0,    0,
    0,    0,  130,  125,  125,  189,  127,  127,    0,  127,
    0,  127,    0,    0,    0,    0,    0,    0,    0,    0,
  130,    0,    0,    0,    0,    0,    0,  126,  126,    0,
    0,    0,  128,    0,    0,  128,    0,    0,    0,    0,
    0,  127,  127,    0,    0,    0,    0,    0,    0,  128,
  128,    0,  128,    0,  128,    0,    0,    0,    0,    0,
  129,    0,    0,  129,    0,    0,    0,    0,    0,    0,
    0,    0,  127,  127,    0,    0,    0,  129,  129,    0,
  129,    0,  129,    0,  128,  128,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  119,  119,  119,  119,
  119,  119,  119,  119,  119,  119,  119,  119,  119,  119,
  119,  119,  129,  119,  119,  128,  128,    0,    0,    0,
    0,    0,    0,    0,  123,  123,  123,  123,  123,  123,
  123,  123,  123,  123,  123,  123,  123,  123,    0,  123,
  123,    0,    0,  129,  129,    0,    0,    0,    0,    0,
    0,    0,  124,  124,  124,  124,  124,  124,  124,  124,
  124,  124,  124,  124,  124,  124,    0,  124,  124,    0,
  125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
  125,  125,    0,  125,  125,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  126,  126,  126,  126,  126,  126,
  126,  126,  126,  126,  126,  126,    0,  126,  126,    0,
    0,    0,    0,    0,  130,    0,    0,  130,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  130,  130,    0,  130,    0,  130,    0,    0,  127,
  127,  127,  127,  127,  127,  127,  127,  127,  127,  127,
  127,  131,  127,  127,  131,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  130,    0,  131,  131,
    0,  131,    0,  131,    0,    0,    0,    0,    0,    0,
    0,    0,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,    0,  128,  128,  130,  130,    0,
    0,    0,    0,  131,    0,    0,    0,    0,    0,    0,
  129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
  129,  129,  132,  129,  129,  132,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  131,    0,    0,  134,  132,
  132,  134,  132,  124,  132,    0,    0,    0,    0,    0,
    0,  135,    0,    0,  135,  134,  134,    0,  134,    0,
  134,    0,    0,    0,    0,    0,    0,    0,  135,  135,
    0,  135,    0,    0,  132,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  134,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  135,    0,    0,  132,  195,  198,    0,
    0,    0,    0,    0,    0,  195,    0,    0,    0,    0,
    0,    0,  134,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  135,    0,    0,    0,  230,
  231,  232,  233,  234,  235,  236,  237,  238,  239,  240,
    0,  241,    0,    0,    0,    0,    0,  247,    0,    0,
    0,    0,    0,    0,  130,  130,  130,  130,  130,  130,
  130,  130,  130,  130,  130,  130,    0,  130,  130,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  131,  131,  131,  131,  131,  131,  131,  131,  131,
  131,  131,  131,    0,  131,  131,    0,    0,    0,    0,
    0,    0,    0,  274,    0,  276,  198,    0,    0,    0,
    0,  274,    0,  195,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  132,  132,  132,  132,  132,  132,  132,  132,
  132,  132,  132,  132,    0,  132,  132,    0,    0,  134,
  134,  134,  134,  134,  134,  134,  134,  134,  134,  134,
    0,  134,  134,  135,  135,  135,  135,  135,  135,  135,
  135,  135,  135,    0,  135,  135,
};
short yycheck[] = {                                      63,
    0,   41,   42,   39,   42,   44,   93,   91,  120,   33,
  147,   41,  127,  128,   44,  119,   40,   43,  261,   43,
   41,   45,   44,   10,  307,   44,   62,    5,   58,   59,
   43,   58,  147,   80,   81,   59,   44,   59,   59,   86,
    4,    5,   89,   90,   91,   33,   59,   44,  306,   36,
   44,   59,   40,   44,   44,   43,   40,   45,  157,  158,
  159,  160,   59,   93,   58,   29,   33,   40,   59,   59,
   34,   41,   93,   40,   44,  123,   43,   60,   45,   62,
   41,  193,   41,   44,   41,   49,   41,   44,   58,   59,
   54,   61,   59,   63,   58,  125,   43,   41,   45,  123,
   44,  125,  126,  150,  151,  152,  243,   37,   59,   87,
  283,  284,   42,  139,   92,  123,   40,   47,   82,   33,
   59,   38,   40,   93,   41,   40,   40,   44,  265,   43,
   59,   45,  285,  286,  289,  290,  248,  249,  126,   41,
   42,   58,   59,   40,   61,   59,   63,  153,  154,   40,
  155,  156,   40,  268,   58,  125,  123,  258,  125,  126,
  272,  262,  263,  161,  162,   40,   38,  268,   94,  270,
  124,   33,  273,  285,  286,  291,   93,   94,   40,  283,
  281,   43,  146,   45,  303,  297,   44,  276,   59,   59,
   41,   41,   41,  125,   58,   93,   44,   44,  282,   41,
   40,   93,  304,   40,   58,   41,  307,  124,  125,  123,
   41,  258,  126,   59,  274,   41,   93,  304,  182,   41,
   41,   59,   41,  306,   41,   59,  125,   93,  292,   91,
   41,  304,  256,  257,  258,  259,  260,  273,  262,  263,
  264,  265,  266,  267,  268,  269,  270,  271,  272,  273,
   41,  275,  276,  277,  278,  279,  280,  281,  258,  283,
  284,  123,  262,  263,  126,  265,  305,  307,  268,  307,
  270,  271,  272,  273,  304,  305,  264,  304,  266,  303,
  280,  281,  306,  307,  308,  309,  305,   93,   41,  256,
  257,   93,  259,  260,   93,  283,  284,  264,  125,  266,
  267,  125,  269,   41,  287,  288,   65,  307,  275,  276,
  277,  278,  279,   49,   58,  303,  283,  284,  306,  307,
  308,  309,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,   43,  304,  305,  303,   24,   41,  306,
  307,  308,  309,  257,  144,  259,  260,  163,  166,  164,
  264,  165,  266,  267,   61,  269,  266,  167,  137,   -1,
  263,  275,  276,  277,  278,  279,  256,   -1,   -1,  283,
  284,   -1,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,  304,  305,  303,
   -1,   -1,  306,  307,  308,  309,  258,   -1,   -1,   -1,
  262,  263,  264,   -1,  266,   -1,  268,   -1,  270,   -1,
   -1,  273,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  281,
   -1,  283,  284,   -1,   -1,   -1,   -1,   37,   38,   -1,
   40,   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,
   -1,  303,   -1,   -1,  306,  307,  308,  309,   58,   59,
   60,   61,   62,   63,   37,   38,   -1,   -1,   41,   42,
   43,   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   58,   59,   60,   61,   62,
   63,   91,   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   37,   38,   -1,   -1,   41,
   42,   43,   44,   45,   -1,   47,   -1,   -1,   -1,   -1,
   93,   94,   -1,   -1,  124,  125,   58,   59,   60,   61,
   62,   63,   -1,   38,   -1,   -1,   41,   -1,   43,   44,
   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  124,  125,   58,   59,   60,   61,   62,   63,   -1,
   38,   93,   94,   41,  258,   43,   44,   45,  262,  263,
   -1,  265,   -1,   -1,  268,   -1,  270,  271,  272,  273,
   58,   59,   60,   61,   62,   63,  280,  281,   93,   94,
   -1,   -1,  124,  125,   -1,   -1,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  307,   -1,   93,   94,  258,   -1,  124,
  125,  262,  263,   -1,   -1,   -1,   -1,  268,   -1,  270,
   -1,   -1,  273,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  281,   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,   -1,
   -1,   38,   -1,   -1,   41,  258,   43,   44,   45,  262,
  263,   -1,  265,   -1,   -1,  268,  307,  270,  271,  272,
  273,   58,   59,   60,   61,   62,   63,  280,  281,   -1,
   -1,   -1,  282,  283,  284,  285,  286,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,   -1,  304,  305,   93,   94,   -1,   -1,
  283,  284,  285,  286,  287,  288,  289,  290,  291,  292,
  293,  294,  295,  296,  297,  298,  299,  300,  301,  302,
   -1,  304,  305,   -1,   -1,   -1,   -1,  124,  125,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  285,  286,  287,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,  298,  299,  300,  301,
  302,   -1,  304,  305,   -1,   -1,   -1,   -1,   -1,   -1,
  285,  286,  287,  288,  289,  290,  291,  292,  293,  294,
  295,  296,  297,  298,  299,  300,  301,  302,   -1,  304,
  305,   -1,   -1,   -1,   -1,   -1,   -1,  285,  286,  287,
  288,  289,  290,  291,  292,  293,  294,  295,  296,  297,
  298,  299,  300,  301,  302,   -1,  304,  305,   -1,   -1,
   -1,   -1,   -1,   38,   -1,   -1,   41,  258,   -1,   44,
   -1,  262,  263,   -1,  265,   -1,   -1,  268,   -1,  270,
  271,  272,  273,   58,   59,   60,   61,   62,   63,  280,
  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   38,   -1,   -1,   41,   -1,   -1,   44,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   93,   94,
   58,   59,   60,   61,   62,   63,   -1,   -1,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,  304,  305,  124,
  125,   38,   -1,   -1,   41,   93,   94,   44,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   59,   60,   61,   62,   63,   38,   -1,   -1,
   41,   -1,   -1,   44,   -1,   -1,  124,  125,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,   59,   60,
   61,   62,   63,   -1,   -1,   38,   93,   94,   41,   -1,
   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   58,   59,   60,   61,   62,
   63,   -1,   93,   94,   -1,   -1,   -1,  124,  125,   -1,
   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,   -1,
   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   -1,  124,  125,   58,   59,   60,   61,   62,
   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,   44,   -1,
   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   58,   59,   60,   61,   62,   63,   -1,   -1,
  285,  286,  287,  288,  289,  290,  291,  292,  293,  294,
  295,  296,  297,  298,  299,  300,  301,  302,   -1,  304,
  305,  124,  125,   -1,   -1,   -1,   -1,   93,   94,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  285,  286,  287,
  288,  289,  290,  291,  292,  293,  294,  295,  296,  297,
  298,  299,  300,  301,  302,   -1,  304,  305,  124,  125,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,  304,  305,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  300,
  301,  302,   -1,  304,  305,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  287,  288,  289,  290,  291,  292,
  293,  294,  295,  296,  297,  298,  299,  300,  301,  302,
   -1,  304,  305,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  287,  288,  289,  290,  291,  292,
  293,  294,  295,  296,  297,  298,  299,  300,  301,  302,
   -1,  304,  305,   -1,   -1,   -1,   79,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   87,   -1,   -1,   -1,   -1,   -1,
   -1,  287,  288,  289,  290,  291,  292,  293,  294,  295,
  296,  297,  298,  299,  300,  301,  302,   38,  304,  305,
   41,   -1,   -1,   44,   -1,   -1,  119,   -1,   -1,  122,
  123,   -1,   -1,  126,  127,  128,   -1,   58,   59,   60,
   61,   62,   63,   38,   -1,   -1,   41,   -1,   -1,   44,
   -1,   -1,   -1,   -1,  147,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   58,   59,   -1,   61,   -1,   63,   -1,
   -1,   38,   93,   94,   41,  168,   -1,   44,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,
   41,   58,   59,   44,   61,   -1,   63,   -1,   93,   94,
   -1,   -1,   -1,  124,  125,   -1,   -1,   58,   59,   -1,
   61,   38,   63,   -1,   41,   -1,   -1,   44,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   93,   94,   -1,  124,
  125,   58,   59,   -1,   61,   -1,   63,   -1,   -1,   -1,
   -1,   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,
  243,   -1,   -1,   -1,   -1,   -1,   -1,  124,  125,   41,
   -1,   -1,   44,   -1,   -1,   -1,   93,   94,   -1,   -1,
   -1,   -1,  265,  124,  125,  268,   58,   59,   -1,   61,
   -1,   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  283,   -1,   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,
   -1,   -1,   41,   -1,   -1,   44,   -1,   -1,   -1,   -1,
   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,   58,
   59,   -1,   61,   -1,   63,   -1,   -1,   -1,   -1,   -1,
   41,   -1,   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  124,  125,   -1,   -1,   -1,   58,   59,   -1,
   61,   -1,   63,   -1,   93,   94,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  300,
  301,  302,   93,  304,  305,  124,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  289,  290,  291,  292,  293,  294,
  295,  296,  297,  298,  299,  300,  301,  302,   -1,  304,
  305,   -1,   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,  304,  305,   -1,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  300,
  301,  302,   -1,  304,  305,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,  304,  305,   -1,
   -1,   -1,   -1,   -1,   41,   -1,   -1,   44,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   59,   -1,   61,   -1,   63,   -1,   -1,  291,
  292,  293,  294,  295,  296,  297,  298,  299,  300,  301,
  302,   41,  304,  305,   44,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   93,   -1,   58,   59,
   -1,   61,   -1,   63,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  291,  292,  293,  294,  295,  296,  297,  298,
  299,  300,  301,  302,   -1,  304,  305,  124,  125,   -1,
   -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,   -1,   -1,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  300,
  301,  302,   41,  304,  305,   44,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  125,   -1,   -1,   41,   58,
   59,   44,   61,   73,   63,   -1,   -1,   -1,   -1,   -1,
   -1,   41,   -1,   -1,   44,   58,   59,   -1,   61,   -1,
   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,   59,
   -1,   61,   -1,   -1,   93,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   93,   -1,   -1,  125,  137,  138,   -1,
   -1,   -1,   -1,   -1,   -1,  145,   -1,   -1,   -1,   -1,
   -1,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  125,   -1,   -1,   -1,  169,
  170,  171,  172,  173,  174,  175,  176,  177,  178,  179,
   -1,  181,   -1,   -1,   -1,   -1,   -1,  187,   -1,   -1,
   -1,   -1,   -1,   -1,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,   -1,  304,  305,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,   -1,  304,  305,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  253,   -1,  255,  256,   -1,   -1,   -1,
   -1,  261,   -1,  263,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  291,  292,  293,  294,  295,  296,  297,  298,
  299,  300,  301,  302,   -1,  304,  305,   -1,   -1,  292,
  293,  294,  295,  296,  297,  298,  299,  300,  301,  302,
   -1,  304,  305,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,   -1,  304,  305,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 314
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"'!'",0,0,0,"'%'","'&'",0,"'('","')'","'*'","'+'","','","'-'",0,"'/'",0,0,0,0,0,
0,0,0,0,0,"':'","';'","'<'","'='","'>'","'?'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,"'{'","'|'","'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"FOR","VOID","DO",
"CONTINUE","INHERIT","MAPPING","INT","LOCK","NOMASK","CATCH","CASE","FLOAT",
"BREAK","MIXED","STATIC","VARARGS","STRING","ELSE","IF","WHILE","SWITCH",
"DEFAULT","RETURN","PRIVATE","OBJECT","ARROW","PLUS_PLUS","MIN_MIN","LSHIFT",
"RSHIFT","LE","GE","EQ","NE","LAND","LOR","PLUS_EQ","MIN_EQ","MULT_EQ","DIV_EQ",
"MOD_EQ","LSHIFT_EQ","RSHIFT_EQ","AND_EQ","XOR_EQ","OR_EQ","COLON_COLON",
"DOT_DOT","ELLIPSIS","STRING_CONST","IDENTIFIER","INT_CONST","FLOAT_CONST",
"MARK","HASH","HASH_HASH","INCL_CONST","NR_TOKENS",
};
char *yyrule[] = {
"$accept : program",
"$$1 :",
"program : $$1 top_level_declarations",
"top_level_declarations :",
"top_level_declarations : top_level_declarations top_level_declaration",
"top_level_declaration : INHERIT opt_inherit_label inherit_string ';'",
"top_level_declaration : data_declaration",
"top_level_declaration : function_declaration",
"opt_inherit_label :",
"opt_inherit_label : ident",
"ident : IDENTIFIER",
"inherit_string : string",
"inherit_string : inherit_string '+' string",
"string : STRING_CONST",
"data_declaration : class_specifier_list type_specifier list_dcltr ';'",
"$$2 :",
"function_declaration : class_specifier_list type_specifier function_dcltr $$2 compound_stmt",
"$$3 :",
"function_declaration : class_specifier_list ident '(' formals_declaration ')' $$3 compound_stmt",
"local_data_declaration : class_specifier_list type_specifier list_dcltr ';'",
"formals_declaration :",
"formals_declaration : VOID",
"formals_declaration : formal_declaration_list",
"formals_declaration : formal_declaration_list ELLIPSIS",
"formal_declaration_list : formal_declaration",
"formal_declaration_list : formal_declaration_list ',' formal_declaration",
"formal_declaration : type_specifier data_dcltr",
"formal_declaration : ident",
"class_specifier_list :",
"class_specifier_list : class_specifier_list class_specifier",
"class_specifier : PRIVATE",
"class_specifier : STATIC",
"class_specifier : NOMASK",
"class_specifier : VARARGS",
"type_specifier : INT",
"type_specifier : FLOAT",
"type_specifier : STRING",
"type_specifier : OBJECT",
"type_specifier : MAPPING",
"type_specifier : MIXED",
"type_specifier : VOID",
"star_list :",
"star_list : star_list '*'",
"data_dcltr : star_list ident",
"function_dcltr : star_list ident '(' formals_declaration ')'",
"dcltr : data_dcltr",
"dcltr : function_dcltr",
"list_dcltr : dcltr",
"list_dcltr : list_dcltr ',' dcltr",
"dcltr_or_stmt_list :",
"dcltr_or_stmt_list : dcltr_or_stmt_list dcltr_or_stmt",
"dcltr_or_stmt : local_data_declaration",
"dcltr_or_stmt : stmt",
"dcltr_or_stmt : error ';'",
"stmt : list_exp ';'",
"stmt : compound_stmt",
"stmt : IF '(' f_list_exp ')' stmt",
"stmt : IF '(' f_list_exp ')' stmt ELSE stmt",
"$$4 :",
"stmt : DO $$4 stmt WHILE '(' f_list_exp ')' ';'",
"$$5 :",
"stmt : WHILE '(' f_list_exp ')' $$5 stmt",
"$$6 :",
"stmt : FOR '(' opt_list_exp ';' f_opt_list_exp ';' opt_list_exp ')' $$6 stmt",
"$$7 :",
"stmt : SWITCH '(' f_list_exp ')' $$7 compound_stmt",
"$$8 :",
"stmt : CASE exp ':' $$8 stmt",
"$$9 :",
"stmt : CASE exp DOT_DOT exp ':' $$9 stmt",
"$$10 :",
"stmt : DEFAULT ':' $$10 stmt",
"stmt : BREAK ';'",
"stmt : CONTINUE ';'",
"stmt : RETURN f_opt_list_exp ';'",
"stmt : ';'",
"$$11 :",
"compound_stmt : '{' $$11 dcltr_or_stmt_list '}'",
"function_name : ident",
"function_name : COLON_COLON ident",
"function_name : ident COLON_COLON ident",
"primary_p1_exp : INT_CONST",
"primary_p1_exp : FLOAT_CONST",
"primary_p1_exp : string",
"primary_p1_exp : '(' '{' opt_arg_list_comma '}' ')'",
"primary_p1_exp : '(' '[' opt_assoc_arg_list_comma ']' ')'",
"primary_p1_exp : ident",
"primary_p1_exp : '(' list_exp ')'",
"primary_p1_exp : function_name '(' opt_arg_list ')'",
"primary_p1_exp : CATCH '(' list_exp ')'",
"primary_p1_exp : LOCK '(' list_exp ')'",
"primary_p1_exp : primary_p2_exp ARROW ident '(' opt_arg_list ')'",
"primary_p2_exp : primary_p1_exp",
"primary_p2_exp : primary_p2_exp '[' f_list_exp ']'",
"primary_p2_exp : primary_p2_exp '[' f_opt_list_exp DOT_DOT f_opt_list_exp ']'",
"postfix_exp : primary_p2_exp",
"postfix_exp : postfix_exp PLUS_PLUS",
"postfix_exp : postfix_exp MIN_MIN",
"prefix_exp : postfix_exp",
"prefix_exp : PLUS_PLUS cast_exp",
"prefix_exp : MIN_MIN cast_exp",
"prefix_exp : '-' cast_exp",
"prefix_exp : '+' cast_exp",
"prefix_exp : '!' cast_exp",
"prefix_exp : '~' cast_exp",
"cast_exp : prefix_exp",
"cast_exp : '(' type_specifier star_list ')' cast_exp",
"mult_oper_exp : cast_exp",
"mult_oper_exp : mult_oper_exp '*' cast_exp",
"mult_oper_exp : mult_oper_exp '/' cast_exp",
"mult_oper_exp : mult_oper_exp '%' cast_exp",
"add_oper_exp : mult_oper_exp",
"add_oper_exp : add_oper_exp '+' mult_oper_exp",
"add_oper_exp : add_oper_exp '-' mult_oper_exp",
"shift_oper_exp : add_oper_exp",
"shift_oper_exp : shift_oper_exp LSHIFT add_oper_exp",
"shift_oper_exp : shift_oper_exp RSHIFT add_oper_exp",
"rel_oper_exp : shift_oper_exp",
"rel_oper_exp : rel_oper_exp '<' shift_oper_exp",
"rel_oper_exp : rel_oper_exp '>' shift_oper_exp",
"rel_oper_exp : rel_oper_exp LE shift_oper_exp",
"rel_oper_exp : rel_oper_exp GE shift_oper_exp",
"equ_oper_exp : rel_oper_exp",
"equ_oper_exp : equ_oper_exp EQ rel_oper_exp",
"equ_oper_exp : equ_oper_exp NE rel_oper_exp",
"bitand_oper_exp : equ_oper_exp",
"bitand_oper_exp : bitand_oper_exp '&' equ_oper_exp",
"bitxor_oper_exp : bitand_oper_exp",
"bitxor_oper_exp : bitxor_oper_exp '^' bitand_oper_exp",
"bitor_oper_exp : bitxor_oper_exp",
"bitor_oper_exp : bitor_oper_exp '|' bitxor_oper_exp",
"and_oper_exp : bitor_oper_exp",
"and_oper_exp : and_oper_exp LAND bitor_oper_exp",
"or_oper_exp : and_oper_exp",
"or_oper_exp : or_oper_exp LOR and_oper_exp",
"cond_exp : or_oper_exp",
"cond_exp : or_oper_exp '?' list_exp ':' cond_exp",
"exp : cond_exp",
"exp : cond_exp '=' exp",
"exp : cond_exp PLUS_EQ exp",
"exp : cond_exp MIN_EQ exp",
"exp : cond_exp MULT_EQ exp",
"exp : cond_exp DIV_EQ exp",
"exp : cond_exp MOD_EQ exp",
"exp : cond_exp LSHIFT_EQ exp",
"exp : cond_exp RSHIFT_EQ exp",
"exp : cond_exp AND_EQ exp",
"exp : cond_exp XOR_EQ exp",
"exp : cond_exp OR_EQ exp",
"list_exp : exp",
"list_exp : list_exp ',' exp",
"opt_list_exp :",
"opt_list_exp : list_exp",
"f_list_exp : list_exp",
"f_opt_list_exp : opt_list_exp",
"arg_list : exp",
"arg_list : arg_list ',' exp",
"opt_arg_list :",
"opt_arg_list : arg_list",
"opt_arg_list : arg_list ELLIPSIS",
"opt_arg_list_comma :",
"opt_arg_list_comma : arg_list",
"opt_arg_list_comma : arg_list ','",
"assoc_exp : exp ':' exp",
"assoc_arg_list : assoc_exp",
"assoc_arg_list : assoc_arg_list ',' assoc_exp",
"opt_assoc_arg_list_comma :",
"opt_assoc_arg_list_comma : assoc_arg_list",
"opt_assoc_arg_list_comma : assoc_arg_list ','",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#line 721 "parser.y"

/*
 * NAME:	t_void()
 * DESCRIPTION:	if the argument is of type void, an error will result
 */
static void t_void(n)
register node *n;
{
    if (n != (node *) NULL && n->mod == T_VOID) {
	c_error("void value not ignored");
	n->mod = T_MIXED;
    }
}

/*
 * NAME:	t_unary()
 * DESCRIPTION:	typecheck the argument of a unary operator
 */
static bool t_unary(n, name)
register node *n;
char *name;
{
    t_void(n);
    if (typechecking && !T_ARITHMETIC(n->mod) && n->mod != T_MIXED) {
	c_error("bad argument type for %s (%s)", name, i_typename(n->mod));
	n->mod = T_MIXED;
	return FALSE;
    }
    return TRUE;
}

/*
 * NAME:	uassign()
 * DESCRIPTION:	handle a unary assignment operator
 */
static node *uassign(op, n, name)
int op;
register node *n;
char *name;
{
    t_unary(n, name);
    return node_mon((n->mod == T_INT) ? op + 1 : op, n->mod, c_lvalue(n, name));
}

/*
 * NAME:	cast()
 * DESCRIPTION:	cast an expression to a type
 */
static node *cast(n, type)
register node *n;
register unsigned short type;
{
    xfloat flt;

    if (type != n->mod) {
	if (type == T_INT) {
	    if (n->type == N_FLOAT) {
		/* cast float constant to int */
		NFLT_GET(n, flt);
		return node_int(flt_ftoi(&flt));
	    } else if (n->type == N_TOFLOAT && n->l.left->mod == N_INT) {
		/* (int) (float) i */
		return n->l.left;
	    } else if (n->mod == T_FLOAT || n->mod == T_MIXED) {
		return node_mon(N_TOINT, T_INT, n);
	    }
	} else if (type == T_FLOAT) {
	    if (n->type == N_INT) {
		/* cast int constant to float */
		flt_itof(n->l.number, &flt);
		return node_float(&flt);
	    } else if (n->mod == T_INT || n->mod == T_MIXED) {
		return node_mon(N_TOFLOAT, T_FLOAT, n);
	    }
	}

	if ((n->mod & T_TYPE) != T_MIXED) {
	    c_error("cast of invalid type (%s)", i_typename(n->mod));
	} else if ((type & T_TYPE) == T_VOID) {
	    c_error("cannot cast to %s", i_typename(type));
	    n->mod = T_MIXED;
	} else if ((type & T_REF) < (n->mod & T_REF)) {
	    c_error("illegal cast of array type (%s)", i_typename(n->mod));
	} else if ((type & T_REF) == 0 || (n->mod & T_REF) == 0) {
	    return node_mon(N_CAST, type, n);
	}
    }
    return n;
}

/*
 * NAME:	idx()
 * DESCRIPTION:	handle the [ ] operator
 */
static node *idx(n1, n2)
register node *n1, *n2;
{
    register unsigned short type;

    if (n1->type == N_STR && n2->type == N_INT) {
	/* str [ int ] */
	n2->l.number = UCHAR(n1->l.string->text[str_index(n1->l.string,
						         (long) n2->l.number)]);
	return n2;
    }

    if ((n1->mod & T_REF) != 0) {
	/*
	 * array
	 */
	if (typechecking) {
	    type = n1->mod - (1 << REFSHIFT);
	    if (n2->mod != T_INT && n2->mod != T_MIXED) {
		c_error("bad index type (%s)", i_typename(n2->mod));
	    }
	    if (type != T_MIXED) {
		/* you can't trust these arrays */
		return node_mon(N_CAST, type, node_bin(N_INDEX, type, n1, n2));
	    }
	}
	type = T_MIXED;
    } else if (n1->mod == T_STRING) {
	/*
	 * string
	 */
	if (typechecking && n2->mod != T_INT && n2->mod != T_MIXED) {
	    c_error("bad index type (%s)", i_typename(n2->mod));
	}
	type = T_INT;
    } else {
	if (typechecking && n1->mod != T_MAPPING && n1->mod != T_MIXED) {
	    c_error("bad indexed type (%s)", i_typename(n1->mod));
	}
	type = T_MIXED;
    }
    return node_bin(N_INDEX, type, n1, n2);
}

/*
 * NAME:	range()
 * DESCRIPTION:	handle the [ .. ] operator
 */
static node *range(n1, n2, n3)
register node *n1, *n2, *n3;
{
    if (n1->type == N_STR && (n2 == (node *) NULL || n2->type == N_INT) &&
	(n3 == (node *) NULL || n3->type == N_INT)) {
	/* str [ int .. int ] */
	return node_str(str_range(n1->l.string,
				  (n2 == (node *) NULL) ? 0 : n2->l.number,
				  (n3 == (node *) NULL) ?
				    n1->l.string->len - 1 : n3->l.number));
    }

    if (typechecking) {
	/* indices */
	if ((n2 != (node*) NULL && n2->mod != T_INT && n2->mod != T_MIXED) ||
	    (n3 != (node*) NULL && n3->mod != T_INT && n3->mod != T_MIXED)) {
	    c_error("bad index type (%s)", i_typename(n2->mod));
	}
	/* range */
	if ((n1->mod & T_REF) == 0 && n1->mod != T_STRING && n1->mod != T_MIXED)
	{
	    c_error("bad indexed type (%s)", i_typename(n1->mod));
	}
    }

    return node_bin(N_RANGE, n1->mod, n1, node_bin(N_PAIR, 0, n2, n3));
}

/*
 * NAME:	bini()
 * DESCRIPTION:	handle a binary int operator
 */
static node *bini(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    t_void(n1);
    t_void(n2);

    if (typechecking &&
	((n1->mod != T_INT && n1->mod != T_MIXED) ||
	 (n2->mod != T_INT && n2->mod != T_MIXED))) {
	c_error("bad argument types for %s (%s, %s)", name,
		i_typename(n1->mod), i_typename(n2->mod));
    }
    if (n1->mod == T_INT && n2->mod == T_INT) {
	op++;
    }
    return node_bin(op, T_INT, n1, n2);
}

/*
 * NAME:	bina()
 * DESCRIPTION:	handle a binary arithmetic operator
 */
static node *bina(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    register unsigned short type;

    t_void(n1);
    t_void(n2);

    type = T_MIXED;
    if (typechecking &&
	((n1->mod != n2->mod && n1->mod != T_MIXED && n2->mod != T_MIXED) ||
	 (!T_ARITHMETIC(n1->mod) && n1->mod != T_MIXED) ||
	 (!T_ARITHMETIC(n2->mod) && n2->mod != T_MIXED))) {
	c_error("bad argument types for %s (%s, %s)", name,
		i_typename(n1->mod), i_typename(n2->mod));
    } else if (n1->mod == T_INT || n2->mod == T_INT) {
	if (n1->mod == T_INT && n2->mod == T_INT) {
	    op++;
	}
	type = T_INT;
    } else if (n1->mod == T_FLOAT || n2->mod == T_FLOAT) {
	type = T_FLOAT;
    }

    return node_bin(op, type, n1, n2);
}

/*
 * NAME:	mult()
 * DESCRIPTION:	handle the * *= operators
 */
static node *mult(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    xfloat f1, f2;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i * i */
	n1->l.number *= n2->l.number;
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_mult(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }
    return bina(op, n1, n2, name);
}

/*
 * NAME:	mdiv()
 * DESCRIPTION:	handle the / /= operators
 */
static node *mdiv(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    xfloat f1, f2;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i / i */
	if (n2->l.number == 0) {
	    /* i / 0 */
	    c_error("division by zero");
	    return n1;
	}
	n1->l.number /= n2->l.number;
	return n1;
    } else if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	/* f / f */
	if (NFLT_ISZERO(n2)) {
	    /* f / 0.0 */
	    c_error("division by zero");
	    return n1;
	}
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_div(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }

    return bina(op, n1, n2, name);
}

/*
 * NAME:	mod()
 * DESCRIPTION:	handle the % %= operators
 */
static node *mod(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    if (n1->type == N_INT && n2->type == N_INT) {
	/* i % i */
	if (n2->l.number == 0) {
	    /* i % 0 */
	    c_error("modulus by zero");
	    return n1;
	}
	n1->l.number %= n2->l.number;
	return n1;
    }

    return bini(op, n1, n2, name);
}

/*
 * NAME:	add()
 * DESCRIPTION:	handle the + += operators
 */
static node *add(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    char buffer[16];
    xfloat f1, f2;
    register unsigned short type;

    t_void(n1);
    t_void(n2);

    if (n1->mod == T_STRING) {
	if (n2->type == N_INT) {
	    sprintf(buffer, "%ld", (long) n2->l.number);
	    n2 = node_str(str_new(buffer, (long) strlen(buffer)));
	} else if (n2->type == N_FLOAT) {
	    NFLT_GET(n2, f1);
	    flt_ftoa(&f1, buffer);
	    n2 = node_str(str_new(buffer, (long) strlen(buffer)));
	}
    } else if (n2->mod == T_STRING) {
	if (n1->type == N_INT) {
	    sprintf(buffer, "%ld", (long) n1->l.number);
	    n1 = node_str(str_new(buffer, (long) strlen(buffer)));
	} else if (n1->type == N_FLOAT) {
	    NFLT_GET(n1, f1);
	    flt_ftoa(&f1, buffer);
	    n1 = node_str(str_new(buffer, (long) strlen(buffer)));
	}
    }

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i + i */
	n1->l.number += n2->l.number;
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	/* f + f */
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_add(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }
    if (n1->type == N_STR && n2->type == N_STR) {
	/* s + s */
	return node_str(str_add(n1->l.string, n2->l.string));
    }

    type = c_tmatch(n1->mod, n2->mod);
    if (type == T_OBJECT ||
	(type == T_INVALID &&	/* only if not adding a to s */
	 (!T_ARITHSTR(n1->mod) || !T_ARITHSTR(n2->mod) ||
	  (n1->mod != T_STRING && (op == N_ADD_EQ || n2->mod != T_STRING))))) {
	type = T_MIXED;
	if (typechecking) {
	    c_error("bad argument types for %s (%s, %s)", name,
		    i_typename(n1->mod), i_typename(n2->mod));
	}
    } else if (type == T_INT) {
	op++;
    } else if (type == T_INVALID) {
	type = T_STRING;
    }
    return node_bin(op, type, n1, n2);
}

/*
 * NAME:	sub()
 * DESCRIPTION:	handle the - -= operators
 */
static node *sub(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    xfloat f1, f2;
    register unsigned short type;

    t_void(n1);
    t_void(n2);

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i - i */
	n1->l.number -= n2->l.number;
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	/* f - f */
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);
	flt_sub(&f1, &f2);
	NFLT_PUT(n1, f1);
	return n1;
    }

    type = c_tmatch(n1->mod, n2->mod);
    if (type == T_STRING || type == T_OBJECT || type == T_MAPPING ||
	type == T_INVALID) {
	if ((type=n1->mod) != T_MAPPING ||
	    (n2->mod != T_MIXED && (n2->mod & T_REF) == 0)) {
	    type = T_MIXED;
	    if (typechecking) {
		c_error("bad argument types for %s (%s, %s)", name,
			i_typename(n1->mod), i_typename(n2->mod));
	    }
	}
    } else if (type == T_INT) {
	op++;
    } else if (type == T_MIXED) {
	type = (n1->mod == T_MIXED) ? n2->mod : n1->mod;
    }
    return node_bin(op, type, n1, n2);
}

/*
 * NAME:	umin()
 * DESCRIPTION:	handle unary minus
 */
static node *umin(n)
register node *n;
{
    xfloat flt;

    if (t_unary(n, "unary -")) {
	if (n->mod == T_FLOAT) {
	    FLT_ZERO(flt.high, flt.low);
	    n = sub(N_SUB, node_float(&flt), n, "-");
	} else {
	    n = sub(N_SUB, node_int((Int) 0), n, "-");
	}
    }
    return n;
}

/*
 * NAME:	lshift()
 * DESCRIPTION:	handle the << <<= operators
 */
static node *lshift(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    if (n1->type == N_INT && n2->type == N_INT) {
	/* i << i */
	n1->l.number = (Uint) n1->l.number << n2->l.number;
	return n1;
    }

    return bini(op, n1, n2, name);
}

/*
 * NAME:	rshift()
 * DESCRIPTION:	handle the >> >>= operators
 */
static node *rshift(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    if (n1->type == N_INT && n2->type == N_INT) {
	/* i >> i */
	n1->l.number = (Uint) n1->l.number >> n2->l.number;
	return n1;
    }

    return bini(op, n1, n2, name);
}

/*
 * NAME:	rel()
 * DESCRIPTION:	handle the < > <= >= operators
 */
static node *rel(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    t_void(n1);
    t_void(n2);

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i . i */
	switch (op) {
	case N_GE:
	    n1->l.number = (n1->l.number >= n2->l.number);
	    break;

	case N_GT:
	    n1->l.number = (n1->l.number > n2->l.number);
	    break;

	case N_LE:
	    n1->l.number = (n1->l.number <= n2->l.number);
	    break;

	case N_LT:
	    n1->l.number = (n1->l.number < n2->l.number);
	    break;
	}
	return n1;
    }
    if (n1->type == N_FLOAT && n2->type == N_FLOAT) {
	xfloat f1, f2;

	/* f . f */
	NFLT_GET(n1, f1);
	NFLT_GET(n2, f2);

	switch (op) {
	case N_GE:
	    return node_int((Int) (flt_cmp(&f1, &f2) >= 0));

	case N_GT:
	    return node_int((Int) (flt_cmp(&f1, &f2) > 0));

	case N_LE:
	    return node_int((Int) (flt_cmp(&f1, &f2) <= 0));

	case N_LT:
	    return node_int((Int) (flt_cmp(&f1, &f2) < 0));
	}
	return n1;
    }
    if (n1->type == N_STR && n2->type == N_STR) {
	/* s . s */
	switch (op) {
	case N_GE:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) >= 0));

	case N_GT:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) > 0));

	case N_LE:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) <= 0));

	case N_LT:
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) < 0));
	}
    }

    if (typechecking &&
	((n1->mod != n2->mod && n1->mod != T_MIXED && n2->mod != T_MIXED) ||
	 (!T_ARITHSTR(n1->mod) && n1->mod != T_MIXED) ||
	 (!T_ARITHSTR(n2->mod) && n2->mod != T_MIXED))) {
	c_error("bad argument types for %s (%s, %s)", name,
		i_typename(n1->mod), i_typename(n2->mod));
    } else if (n1->mod == T_INT && n2->mod == T_INT) {
	op++;
    }
    return node_bin(op, T_INT, n1, n2);
}

/*
 * NAME:	eq()
 * DESCRIPTION:	handle the == operator
 */
static node *eq(n1, n2)
register node *n1, *n2;
{
    xfloat f1, f2;
    int op;

    t_void(n1);
    t_void(n2);

    switch (n1->type) {
    case N_INT:
	if (n2->type == N_INT) {
	    /* i == i */
	    n1->l.number = (n1->l.number == n2->l.number);
	    return n1;
	}
	if (n1->l.number == 0 && n2->type == N_STR) {
	    /* 0 == s */
	    return n1;	/* FALSE */
	}
	break;

    case N_FLOAT:
	if (n2->type == N_FLOAT) {
	    /* f == f */
	    NFLT_GET(n1, f1);
	    NFLT_GET(n2, f2);
	    return node_int((Int) (flt_cmp(&f1, &f2) == 0));
	}
	break;

    case N_STR:
	if (n2->type == N_STR) {
	    /* s == s */
	    return node_int((Int) (str_cmp(n1->l.string, n2->l.string) == 0));
	}
	if (n2->type == N_INT && n2->l.number == 0) {
	    /* s == 0 */
	    return n2;	/* FALSE */
	}
	break;
    }

    op = N_EQ;
    if (n1->mod != n2->mod && n1->mod != T_MIXED && n2->mod != T_MIXED &&
	(!c_zero(n1) || n2->mod == T_FLOAT) &&
	(!c_zero(n2) || n1->mod == T_FLOAT)) {
	if (typechecking) {
	    c_error("incompatible types for equality (%s, %s)",
		    i_typename(n1->mod), i_typename(n2->mod));
	}
    } else if (n1->mod == T_INT && n2->mod == T_INT) {
	op++;
    }
    return node_bin(op, T_INT, n1, n2);
}

/*
 * NAME:	and()
 * DESCRIPTION:	handle the & &= operators
 */
static node *and(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    register unsigned short type;

    if (n1->type == N_INT && n2->type == N_INT) {
	/* i & i */
	n1->l.number &= n2->l.number;
	return n1;
    }
    if ((((type=n1->mod) == T_MIXED || type == T_MAPPING) &&
	 ((n2->mod & T_REF) != 0 || n2->mod == T_MIXED)) ||
	((type=c_tmatch(n1->mod, n2->mod)) & T_REF) != 0) {
	/*
	 * possibly array & array or mapping & array
	 */
	return node_bin(op, type, n1, n2);
    }
    return bini(op, n1, n2, name);
}

/*
 * NAME:	xor()
 * DESCRIPTION:	handle the ^ ^= operators
 */
static node *xor(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    if (n1->type == N_INT && n2->type == N_INT) {
	/* i ^ i */
	n1->l.number ^= n2->l.number;
	return n1;
    }
    return bini(op, n1, n2, name);
}

/*
 * NAME:	or()
 * DESCRIPTION:	handle the | |= operators
 */
static node *or(op, n1, n2, name)
int op;
register node *n1, *n2;
char *name;
{
    if (n1->type == N_INT && n2->type == N_INT) {
	/* i | i */
	n1->l.number |= n2->l.number;
	return n1;
    }
    return bini(op, n1, n2, name);
}

/*
 * NAME:	land()
 * DESCRIPTION:	handle the && operator
 */
static node *land(n1, n2)
register node *n1, *n2;
{
    t_void(n1);
    t_void(n2);

    if ((n1->flags & F_CONST) && (n2->flags & F_CONST)) {
	n1 = c_tst(n1);
	n2 = c_tst(n2);
	n1->l.number &= n2->l.number;
	return n1;
    }

    return node_bin(N_LAND, T_INT, n1, n2);
}

/*
 * NAME:	lor()
 * DESCRIPTION:	handle the || operator
 */
static node *lor(n1, n2)
register node *n1, *n2;
{
    t_void(n1);
    t_void(n2);

    if ((n1->flags & F_CONST) && (n2->flags & F_CONST)) {
	n1 = c_tst(n1);
	n2 = c_tst(n2);
	n1->l.number |= n2->l.number;
	return n1;
    }

    return node_bin(N_LOR, T_INT, n1, n2);
}

/*
 * NAME:	quest()
 * DESCRIPTION:	handle the ? : operator
 */
static node *quest(n1, n2, n3)
register node *n1, *n2, *n3;
{
    register unsigned short type;

    t_void(n1);

    if ((n2->flags & F_CONST) && n3->type == n2->type) {
	switch (n1->type) {
	case N_INT:
	    return (n1->l.number == 0) ? n3 : n2;

	case N_FLOAT:
	    return (NFLT_ISZERO(n1)) ? n3 : n2;

	case N_STR:
	    return n2;
	}
    }

    type = T_MIXED;
    if (c_zero(n2) && n3->mod != T_FLOAT) {
	/*
	 * expr ? 0 : expr
	 */
	type = n3->mod;
    } else if (c_zero(n3) && n2->mod != T_FLOAT) {
	/*
	 * expr ? expr : 0;
	 */
	type = n2->mod;
    } else if (typechecking) {
	/*
	 * typechecked
	 */
	if ((type=n2->mod) != T_VOID || n3->mod != T_VOID) {
	    type = c_tmatch(n2->mod, n3->mod);
	    if (type == T_INVALID) {
		c_error("incompatible types for ? : (%s, %s)",
			i_typename(n2->mod), i_typename(n3->mod));
		type = T_MIXED;
	    }
	}
    }

    return node_bin(N_QUEST, type, n1, node_bin(N_PAIR, 0, n2, n3));
}

/*
 * NAME:	assign()
 * DESCRIPTION:	handle the assignment operator
 */
static node *assign(n1, n2)
register node *n1, *n2;
{
    if (typechecking && (!c_zero(n2) || n1->mod == T_FLOAT)) {
	/*
	 * typechecked
	 */
	if (c_tmatch(n1->mod, n2->mod) == T_INVALID) {
	    c_error("incompatible types for = (%s, %s)",
		    i_typename(n1->mod), i_typename(n2->mod));
	} else if (n1->mod != T_MIXED && n2->mod == T_MIXED) {
	    n2 = node_mon(N_CAST, n1->mod, n2);
	}
    }

    return node_bin(N_ASSIGN, n1->mod, n1, n2);
}
#line 1726 "y.tab.c"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 108 "parser.y"
{
		  nerrors = 0;
		  ndeclarations = 0;
		}
break;
case 2:
#line 113 "parser.y"
{
		  if (nerrors > 0) {
		      YYABORT;
		  }
		}
break;
case 4:
#line 123 "parser.y"
{
		  if (nerrors > 0) {
		      YYABORT;
		  }
		}
break;
case 5:
#line 132 "parser.y"
{
		  if (ndeclarations > 0) {
		      c_error("inherit must precede all declarations");
		  } else if (!c_inherit(yyvsp[-1].node->l.string->text, yyvsp[-2].node)) {
		      /*
		       * The object to be inherited is unloaded. Load it first,
		       * then recompile.
		       */
		      YYABORT;
		  }
		}
break;
case 6:
#line 144 "parser.y"
{ ndeclarations++; }
break;
case 7:
#line 146 "parser.y"
{ ndeclarations++; }
break;
case 8:
#line 151 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 10:
#line 157 "parser.y"
{ yyval.node = node_str(str_new(yytext, (long) yyleng)); }
break;
case 12:
#line 163 "parser.y"
{ yyval.node = node_str(str_add(yyvsp[-2].node->l.string, yyvsp[0].node->l.string)); }
break;
case 13:
#line 168 "parser.y"
{ yyval.node = node_str(str_new(yytext, (long) yyleng)); }
break;
case 14:
#line 173 "parser.y"
{ c_global(yyvsp[-3].type, yyvsp[-2].type, yyvsp[-1].node); }
break;
case 15:
#line 178 "parser.y"
{ 
		  typechecking = TRUE;
		  c_function(yyvsp[-2].type, yyvsp[-1].type, yyvsp[0].node);
		}
break;
case 16:
#line 183 "parser.y"
{
		  if (nerrors == 0) {
		      c_funcbody(yyvsp[0].node);
		  }
		}
break;
case 17:
#line 189 "parser.y"
{
		  typechecking = FALSE;
		  c_function(yyvsp[-4].type, T_INVALID, node_bin(N_FUNC, 0, yyvsp[-3].node, yyvsp[-1].node));
		}
break;
case 18:
#line 194 "parser.y"
{
		  if (nerrors == 0) {
		      c_funcbody(yyvsp[0].node);
		  }
		}
break;
case 19:
#line 203 "parser.y"
{ c_local(yyvsp[-3].type, yyvsp[-2].type, yyvsp[-1].node); }
break;
case 20:
#line 208 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 21:
#line 209 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 23:
#line 212 "parser.y"
{
		  yyval.node = yyvsp[-1].node;
		  if (yyval.node->type == N_PAIR) {
		      yyval.node->r.right->mod |= T_ELLIPSIS;
		  } else {
		      yyval.node->mod |= T_ELLIPSIS;
		  }
		}
break;
case 25:
#line 225 "parser.y"
{ yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node); }
break;
case 26:
#line 230 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->mod |= yyvsp[-1].type;
		}
break;
case 27:
#line 234 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->mod = T_INVALID;	/* only if typechecking, though */
		}
break;
case 28:
#line 242 "parser.y"
{ yyval.type = 0; }
break;
case 29:
#line 244 "parser.y"
{ yyval.type = yyvsp[-1].type | yyvsp[0].type; }
break;
case 30:
#line 249 "parser.y"
{ yyval.type = C_STATIC | C_PRIVATE; }
break;
case 31:
#line 251 "parser.y"
{ yyval.type = C_STATIC; }
break;
case 32:
#line 253 "parser.y"
{ yyval.type = C_NOMASK; }
break;
case 33:
#line 255 "parser.y"
{ yyval.type = C_VARARGS; }
break;
case 34:
#line 259 "parser.y"
{ yyval.type = T_INT; }
break;
case 35:
#line 260 "parser.y"
{ yyval.type = T_FLOAT; }
break;
case 36:
#line 262 "parser.y"
{ yyval.type = T_STRING; }
break;
case 37:
#line 264 "parser.y"
{ yyval.type = T_OBJECT; }
break;
case 38:
#line 266 "parser.y"
{ yyval.type = T_MAPPING; }
break;
case 39:
#line 267 "parser.y"
{ yyval.type = T_MIXED; }
break;
case 40:
#line 268 "parser.y"
{ yyval.type = T_VOID; }
break;
case 41:
#line 273 "parser.y"
{ yyval.type = 0; }
break;
case 42:
#line 275 "parser.y"
{
		  yyval.type = (yyvsp[-1].type + (1 << REFSHIFT)) & T_REF;
		  if (yyval.type == 0) {
		      yyval.type = T_REF;
		  }
		}
break;
case 43:
#line 285 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  yyval.node->mod = yyvsp[-1].type;
		}
break;
case 44:
#line 293 "parser.y"
{ yyval.node = node_bin(N_FUNC, yyvsp[-4].type, yyvsp[-3].node, yyvsp[-1].node); }
break;
case 48:
#line 304 "parser.y"
{ yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node); }
break;
case 49:
#line 309 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 50:
#line 311 "parser.y"
{ yyval.node = c_concat(yyvsp[-1].node, yyvsp[0].node); }
break;
case 51:
#line 316 "parser.y"
{
		  if (nstatements > 0) {
		      c_error("declaration after statement");
		  }
		  yyval.node = (node *) NULL;
		}
break;
case 52:
#line 322 "parser.y"
{
		  nstatements++;
		  yyval.node = yyvsp[0].node;
		}
break;
case 53:
#line 327 "parser.y"
{
		  if (nerrors >= MAX_ERRORS) {
		      YYABORT;
		  }
		  yyval.node = (node *) NULL;
		}
break;
case 54:
#line 337 "parser.y"
{ yyval.node = c_exp_stmt(yyvsp[-1].node); }
break;
case 56:
#line 340 "parser.y"
{ yyval.node = c_if(yyvsp[-2].node, yyvsp[0].node, (node *) NULL); }
break;
case 57:
#line 343 "parser.y"
{ yyval.node = c_if(yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); }
break;
case 58:
#line 344 "parser.y"
{ c_loop(); }
break;
case 59:
#line 346 "parser.y"
{ yyval.node = c_do(yyvsp[-2].node, yyvsp[-5].node); }
break;
case 60:
#line 348 "parser.y"
{ c_loop(); }
break;
case 61:
#line 349 "parser.y"
{ yyval.node = c_while(yyvsp[-3].node, yyvsp[0].node); }
break;
case 62:
#line 351 "parser.y"
{ c_loop(); }
break;
case 63:
#line 352 "parser.y"
{ yyval.node = c_for(c_exp_stmt(yyvsp[-7].node), yyvsp[-5].node, c_exp_stmt(yyvsp[-3].node), yyvsp[0].node); }
break;
case 64:
#line 354 "parser.y"
{ c_startswitch(yyvsp[-1].node, typechecking); }
break;
case 65:
#line 356 "parser.y"
{ yyval.node = c_endswitch(yyvsp[-3].node, yyvsp[0].node); }
break;
case 66:
#line 358 "parser.y"
{ yyvsp[-1].node = c_case(yyvsp[-1].node, (node *) NULL); }
break;
case 67:
#line 359 "parser.y"
{
		  yyval.node = yyvsp[-3].node;
		  if (yyval.node != (node *) NULL) {
		      yyval.node->l.left = yyvsp[0].node;
		  } else {
		      yyval.node = yyvsp[0].node;
		  }
		}
break;
case 68:
#line 368 "parser.y"
{ yyvsp[-3].node = c_case(yyvsp[-3].node, yyvsp[-1].node); }
break;
case 69:
#line 369 "parser.y"
{
		  yyval.node = yyvsp[-5].node;
		  if (yyval.node != (node *) NULL) {
		      yyval.node->l.left = yyvsp[0].node;
		  } else {
		      yyval.node = yyvsp[0].node;
		  }
		}
break;
case 70:
#line 378 "parser.y"
{ yyvsp[0].node = c_default(); }
break;
case 71:
#line 379 "parser.y"
{
		  yyval.node = yyvsp[-2].node;
		  if (yyval.node != (node *) NULL) {
		      yyval.node->l.left = yyvsp[0].node;
		  } else {
		      yyval.node = yyvsp[0].node;
		  }
		}
break;
case 72:
#line 388 "parser.y"
{
		  yyval.node = c_break();
		}
break;
case 73:
#line 392 "parser.y"
{
		  yyval.node = c_continue();
		}
break;
case 74:
#line 396 "parser.y"
{ yyval.node = c_return(yyvsp[-1].node, typechecking); }
break;
case 75:
#line 397 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 76:
#line 401 "parser.y"
{
		  nstatements = 0;
		  c_startcompound();
		}
break;
case 77:
#line 406 "parser.y"
{
		  nstatements = 1;	/* any non-zero value will do */
		  yyval.node = c_endcompound(yyvsp[-1].node);
		}
break;
case 78:
#line 413 "parser.y"
{ yyval.node = c_flookup(yyvsp[0].node, typechecking); }
break;
case 79:
#line 415 "parser.y"
{ yyval.node = c_iflookup(yyvsp[0].node, (node *) NULL); }
break;
case 80:
#line 417 "parser.y"
{ yyval.node = c_iflookup(yyvsp[0].node, yyvsp[-2].node); }
break;
case 81:
#line 422 "parser.y"
{ yyval.node = node_int(yyvsp[0].number); }
break;
case 82:
#line 424 "parser.y"
{ yyval.node = node_float(&yyvsp[0].real); }
break;
case 84:
#line 427 "parser.y"
{ yyval.node = node_mon(N_AGGR, T_MIXED | (1 << REFSHIFT), yyvsp[-2].node); }
break;
case 85:
#line 429 "parser.y"
{ yyval.node = node_mon(N_AGGR, T_MAPPING, yyvsp[-2].node); }
break;
case 86:
#line 430 "parser.y"
{
		  yyval.node = c_variable(yyvsp[0].node);
		  if (typechecking) {
		      if (yyval.node->type == N_GLOBAL && yyval.node->mod != T_MIXED) {
			  /*
			   * global vars might be modified by untypechecked
			   * functions...
			   */
			  yyval.node = node_mon(N_CAST, yyval.node->mod, yyval.node);
		      }
		  } else {
		      /* the variable could be anything */
		      yyval.node->mod = T_MIXED;
		  }
		}
break;
case 87:
#line 446 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
case 88:
#line 448 "parser.y"
{
		  yyval.node = c_funcall(yyvsp[-3].node, yyvsp[-1].node);
		  if (typechecking) {
		      yyval.node = c_checkcall(yyval.node);
		  } else if (yyval.node->mod == T_VOID) {
		      yyval.node->mod = T_INT;	/* get rid of void */
		  }
		}
break;
case 89:
#line 457 "parser.y"
{ yyval.node = node_mon(N_CATCH, T_STRING, yyvsp[-1].node); }
break;
case 90:
#line 459 "parser.y"
{ yyval.node = c_lock(yyvsp[-1].node); }
break;
case 91:
#line 461 "parser.y"
{
		  t_void(yyvsp[-5].node);
		  yyval.node = c_arrow(yyvsp[-5].node, yyvsp[-3].node, yyvsp[-1].node);
		  /*
		   * call_other() may have been redeclared
		   */
		  if (typechecking) {
		      yyval.node = c_checkcall(yyval.node);
		  } else if (yyval.node->mod == T_VOID) {
		      yyval.node->mod = T_INT;	/* get rid of void */
		  }
		}
break;
case 93:
#line 478 "parser.y"
{ yyval.node = idx(yyvsp[-3].node, yyvsp[-1].node); }
break;
case 94:
#line 480 "parser.y"
{ yyval.node = range(yyvsp[-5].node, yyvsp[-3].node, yyvsp[-1].node); }
break;
case 96:
#line 486 "parser.y"
{ yyval.node = uassign(N_PLUS_PLUS, yyvsp[-1].node, "++"); }
break;
case 97:
#line 488 "parser.y"
{ yyval.node = uassign(N_MIN_MIN, yyvsp[-1].node, "--"); }
break;
case 99:
#line 494 "parser.y"
{ yyval.node = uassign(N_ADD_EQ_1, yyvsp[0].node, "++"); }
break;
case 100:
#line 496 "parser.y"
{ yyval.node = uassign(N_SUB_EQ_1, yyvsp[0].node, "--"); }
break;
case 101:
#line 498 "parser.y"
{ yyval.node = umin(yyvsp[0].node); }
break;
case 102:
#line 500 "parser.y"
{ yyval.node = node_mon(N_UPLUS, yyvsp[0].node->mod, yyvsp[0].node); }
break;
case 103:
#line 502 "parser.y"
{
		  t_void(yyvsp[0].node);
		  yyval.node = c_not(yyvsp[0].node);
		}
break;
case 104:
#line 507 "parser.y"
{
		  yyval.node = yyvsp[0].node;
		  t_void(yyval.node);
		  if (typechecking && yyval.node->mod != T_INT && yyval.node->mod != T_MIXED) {
		      c_error("bad argument type for ~ (%s)",
			      i_typename(yyval.node->mod));
		      yyval.node->mod = T_MIXED;
		  } else {
		      yyval.node = xor(N_XOR, yyval.node, node_int((Int) -1), "^");
		  }
		}
break;
case 106:
#line 523 "parser.y"
{ yyval.node = cast(yyvsp[0].node, yyvsp[-3].type | yyvsp[-2].type); }
break;
case 108:
#line 529 "parser.y"
{ yyval.node = mult(N_MULT, yyvsp[-2].node, yyvsp[0].node, "*"); }
break;
case 109:
#line 531 "parser.y"
{ yyval.node = mdiv(N_DIV, yyvsp[-2].node, yyvsp[0].node, "/"); }
break;
case 110:
#line 533 "parser.y"
{ yyval.node = mod(N_MOD, yyvsp[-2].node, yyvsp[0].node, "%"); }
break;
case 112:
#line 539 "parser.y"
{ yyval.node = add(N_ADD, yyvsp[-2].node, yyvsp[0].node, "+"); }
break;
case 113:
#line 541 "parser.y"
{ yyval.node = sub(N_SUB, yyvsp[-2].node, yyvsp[0].node, "-"); }
break;
case 115:
#line 547 "parser.y"
{ yyval.node = lshift(N_LSHIFT, yyvsp[-2].node, yyvsp[0].node, "<<"); }
break;
case 116:
#line 549 "parser.y"
{ yyval.node = rshift(N_RSHIFT, yyvsp[-2].node, yyvsp[0].node, ">>"); }
break;
case 118:
#line 555 "parser.y"
{ yyval.node = rel(N_LT, yyval.node, yyvsp[0].node, "<"); }
break;
case 119:
#line 557 "parser.y"
{ yyval.node = rel(N_GT, yyval.node, yyvsp[0].node, ">"); }
break;
case 120:
#line 559 "parser.y"
{ yyval.node = rel(N_LE, yyval.node, yyvsp[0].node, "<="); }
break;
case 121:
#line 561 "parser.y"
{ yyval.node = rel(N_GE, yyval.node, yyvsp[0].node, ">="); }
break;
case 123:
#line 567 "parser.y"
{ yyval.node = eq(yyvsp[-2].node, yyvsp[0].node); }
break;
case 124:
#line 569 "parser.y"
{ yyval.node = c_not(eq(yyvsp[-2].node, yyvsp[0].node)); }
break;
case 126:
#line 575 "parser.y"
{ yyval.node = and(N_AND, yyvsp[-2].node, yyvsp[0].node, "&"); }
break;
case 128:
#line 581 "parser.y"
{ yyval.node = xor(N_XOR, yyvsp[-2].node, yyvsp[0].node, "^"); }
break;
case 130:
#line 587 "parser.y"
{ yyval.node = or(N_OR, yyvsp[-2].node, yyvsp[0].node, "|"); }
break;
case 132:
#line 593 "parser.y"
{ yyval.node = land(yyvsp[-2].node, yyvsp[0].node); }
break;
case 134:
#line 599 "parser.y"
{ yyval.node = lor(yyvsp[-2].node, yyvsp[0].node); }
break;
case 136:
#line 605 "parser.y"
{ yyval.node = quest(yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); }
break;
case 138:
#line 611 "parser.y"
{ yyval.node = assign(c_lvalue(yyvsp[-2].node, "assignment"), yyvsp[0].node); }
break;
case 139:
#line 613 "parser.y"
{ yyval.node = add(N_ADD_EQ, c_lvalue(yyvsp[-2].node, "+="), yyvsp[0].node, "+="); }
break;
case 140:
#line 615 "parser.y"
{ yyval.node = sub(N_SUB_EQ, c_lvalue(yyvsp[-2].node, "-="), yyvsp[0].node, "-="); }
break;
case 141:
#line 617 "parser.y"
{ yyval.node = mult(N_MULT_EQ, c_lvalue(yyvsp[-2].node, "*="), yyvsp[0].node, "*="); }
break;
case 142:
#line 619 "parser.y"
{ yyval.node = mdiv(N_DIV_EQ, c_lvalue(yyvsp[-2].node, "/="), yyvsp[0].node, "/="); }
break;
case 143:
#line 621 "parser.y"
{ yyval.node = mod(N_MOD_EQ, c_lvalue(yyvsp[-2].node, "%="), yyvsp[0].node, "%="); }
break;
case 144:
#line 623 "parser.y"
{ yyval.node = lshift(N_LSHIFT_EQ, c_lvalue(yyvsp[-2].node, "<<="), yyvsp[0].node, "<<="); }
break;
case 145:
#line 625 "parser.y"
{ yyval.node = rshift(N_RSHIFT_EQ, c_lvalue(yyvsp[-2].node, ">>="), yyvsp[0].node, ">>="); }
break;
case 146:
#line 627 "parser.y"
{ yyval.node = and(N_AND_EQ, c_lvalue(yyvsp[-2].node, "&="), yyvsp[0].node, "&="); }
break;
case 147:
#line 629 "parser.y"
{ yyval.node = xor(N_XOR_EQ, c_lvalue(yyvsp[-2].node, "^="), yyvsp[0].node, "^="); }
break;
case 148:
#line 631 "parser.y"
{ yyval.node = or(N_OR_EQ, c_lvalue(yyvsp[-2].node, "|="), yyvsp[0].node, "|="); }
break;
case 150:
#line 637 "parser.y"
{
		  if (yyvsp[0].node->type == N_COMMA) {
		      /* a, (b, c) --> (a, b), c */
		      yyval.node = node_bin(N_COMMA, yyvsp[0].node->mod, yyvsp[0].node, yyvsp[0].node->r.right);
		      yyvsp[0].node->r.right = yyvsp[0].node->l.left;
		      yyvsp[0].node->l.left = yyvsp[-2].node;
		  } else {
		      yyval.node = node_bin(N_COMMA, yyvsp[0].node->mod, yyvsp[-2].node, yyvsp[0].node);
		  }
		}
break;
case 151:
#line 651 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 153:
#line 657 "parser.y"
{ t_void(yyval.node = yyvsp[0].node); }
break;
case 154:
#line 662 "parser.y"
{ t_void(yyval.node = yyvsp[0].node); }
break;
case 155:
#line 666 "parser.y"
{ t_void(yyval.node = yyvsp[0].node); }
break;
case 156:
#line 668 "parser.y"
{
		  t_void(yyvsp[0].node);
		  yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node);
		}
break;
case 157:
#line 676 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 159:
#line 679 "parser.y"
{
		  yyval.node = yyvsp[-1].node;
		  if (yyval.node->type == N_PAIR) {
		      yyval.node->r.right = node_mon(N_SPREAD, 0, yyval.node->r.right);
		  } else {
		      yyval.node = node_mon(N_SPREAD, 0, yyval.node);
		  }
		}
break;
case 160:
#line 691 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 162:
#line 694 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
case 163:
#line 699 "parser.y"
{
		  t_void(yyvsp[-2].node);
		  t_void(yyvsp[0].node);
		  yyval.node = node_bin(N_COMMA, 0, yyvsp[-2].node, yyvsp[0].node);
		}
break;
case 165:
#line 709 "parser.y"
{ yyval.node = node_bin(N_PAIR, 0, yyvsp[-2].node, yyvsp[0].node); }
break;
case 166:
#line 714 "parser.y"
{ yyval.node = (node *) NULL; }
break;
case 168:
#line 717 "parser.y"
{ yyval.node = yyvsp[-1].node; }
break;
#line 2579 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
