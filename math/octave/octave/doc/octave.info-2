This is Info file octave.info, produced by Makeinfo-1.52 from the input
file octave.texi.

   Copyright (C) 1993 John W. Eaton.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: octave.info,  Node: Predefined Constants,  Next: User Preferences,  Prev: Built-in Variables,  Up: Built-in Variables

Predefined Constants
====================

`I, i, J, j'
     A pure imaginary number, defined as   `sqrt (-1)'.

`Inf, inf'
     Infinity.  This is the result of an operation like 1/0, or an
     operation that results in a floating point overflow.

`NaN, nan'
     Not a number.  This is the result of an operation like `0/0', or
     `Inf - Inf', or any operation with a NaN.

`SEEK_SET'
`SEEK_CUR'
`SEEK_END'
     These variables may be used as the optional third argument for the
     function `fseek'.

`eps'
     The machine precision.  More precisely, `eps' is the smallest value
     such that `1+eps' is not equal to 1.

`pi'
     The ratio of the circumference of a circle to its diameter.
     Internally, `pi' is computed as `4.0 * atan (1.0)'.

`stdin'
`stdout'
`stderr'
     These variables are the file numbers corresponding to the standard
     input, standard output, and standard error streams.  These streams
     are preconnected and available when Octave starts.


File: octave.info,  Node: User Preferences,  Next: Other Built-in Variables,  Prev: Predefined Constants,  Up: Built-in Variables

User Preferences
================

`LOADPATH'
     A colon separated list of directories in which to search for macro
     files.  The value of `LOADPATH' overrides the environment variable
     `OCTAVE_PATH'.  *Note Installation::.

`PAGER'
     The default value is `less', or, if `less' is not available on
     your system, `more'.  *Note Installation::, and *Note Input and
     Output::.

`PS1'
     The primary prompt string.  When executing interactively, Octave
     displays the primary prompt `PS1' when it is ready to read a
     command.  Octave allows the prompt to be customized by inserting a
     number of backslash-escaped special characters that are decoded as
     follows:

    `\t'
          The time.

    `\d'
          The date.

    `\n'
          Begins a new line by printing the equivalent of a carriage
          return followed by a line feed.

    `\s'
          The name of the program (usually just `octave').

    `\w'
          The current working directory.

    `\W'
          The basename of the current working directory.

    `\u'
          The username of the current user.

    `\h'
          The hostname.

    `\#'
          The command number of this command, counting from when Octave
          starts.

    `\!'
          The history number of this command.  This differs from `\#'
          by the number of commands in the history list when Octave
          starts.

    `\$'
          If the effective UID is 0, a #, otherwise a $.

    `\nnn'
          The character whose character code in octal is `nnn'.

    `\\'
          A backslash.

     The default value of `PS1' is `\s:\#> '.  To change it, use a
     command like

          octave:13> PS1 = '\u@\h> '

     which will result in the prompt `boris@kremvax> ' for the user
     `boris' logged in on the host `kremvax'.

`PS2'
     The secondary prompt string, which is printed when Octave is
     expecting additional input to complete a command.  For example,
     when defining a function over several lines, Octave will print the
     value of `PS1' at the beginning of each line after the first.
     Octave allows `PS2' to be customized in the same way as `PS1'.
     The default value of `PS2' is `> '.

`do_fortran_indexing'
     If the value of `do_fortran_indexing' is `true', Octave allows you
     to select elements of a two-dimensional matrix using a single index
     by treating the matrix as a single vector created from the columns
     of the matrix.  The default value is `false'.

`empty_list_elements_ok'
     This variable controls whether Octave ignores empty matrices in a
     matrix list.

     For example, if the value of `empty_list_elements_ok' is `true',
     Octave will ignore the empty matrices in the expression

          a = [1, [], 3, [], 5]

     and the variable `a' will be assigned the value `[ 1 3 5 ]'.

     The default value is `warn'.

`gnuplot_binary'
     The name of the program invoked by the plot command.  The default
     value is `gnuplot'.  *Note Installation::.

`implicit_str_to_num_ok'
     If the value of `implicit_str_to_num_ok' is `true', implicit
     conversions of strings to their numeric ASCII equivalents are
     allowed.  Otherwise, an error message is printed and control is
     returned to the top level.  The default value is `true'.

`ok_to_lose_imaginary_part'
     If the value of `ok_to_lose_imaginary_part' is `true', implicit
     conversions of complex numbers to real numbers are allowed (for
     example, by fsolve).  If the value is `warn', the conversion is
     allowed, but a warning is printed.  Otherwise, an error message is
     printed and control is returned to the top level.  The default
     value is `warn'.

`output_max_field_width'
     This variable specifies the maximum width of a numeric output
     field.  The default value is 10.

     It is possible to achieve a wide range of output styles by using
     different values of `output_precision' and
     `output_max_field_width'.  Reasonable combinations can be set using
     the `format' function.  *Note Basic Input and Output::.

`output_precision'
     This variable specifies the minimum number of significant figures
     to display for numeric output.  The default value is 5.

     It is possible to achieve a wide range of output styles by using
     different values of `output_precision' and
     `output_max_field_width'.  Reasonable combinations can be set using
     the `format' function.  *Note Basic Input and Output::.

`page_screen_output'
     If the value of `page_screen_output' is `true', all output
     intended for the screen that is longer than one page is sent
     through a pager.  This allows you to view one screenful at a time.
     Some pagers (such as `less'--see *Note Installation::) are also
     capable of moving backward on the output.  The default value is
     `true'.  *Note Input and Output::.

     You can choose the program to use as the pager by setting the
     variable `PAGER'.

`prefer_column_vectors'
     If `prefer_column_vectors' is `true', operations like

          for i = 1:10
            a (i) = i;
          endfor

     (for `a' previously  undefined) produce column vectors.
     Otherwise, row vectors are preferred.  The default value is
     `false'.

     If a variable is already defined to be a vector (a matrix with a
     single row or column), the original orientation is respected,
     regardless of the value of `prefer_column_vectors'.

`prefer_zero_one_indexing'
     If the value of `prefer_zero_one_indexing' is `true', Octave will
     perform zero-one style indexing when there is a conflict with the
     normal indexing rules.  *Note Index Expressions::.  For example,
     given a matrix

          a = [1, 2, 3, 4]

     with `prefer_zero_one_indexing' is set to `true', the statement

          a ([1, 1, 1, 1])

     results in the matrix `[ 1  2  3  4 ]'.  If the value of
     `prefer_zero_one_indexing' set to `false', the result would be the
     matrix `[ 1 1 1 1 ]'.

     In the first case, Octave is selecting each element corresponding
     to a `1' in the index vector.  In the second, Octave is selecting
     the first element multiple times.

     The default value for `prefer_zero_one_indexing' is `false'.

`print_answer_id_name'
     If the value of `print_answer_id_name' is `true', variable names
     are printed along with the result.  Otherwise, only the result
     values are printed.  The default value is `true'.

`print_empty_dimensions'
     If the value of `print_empty_dimensions' is `true', the dimensions
     of empty matrices are printed along with the empty matrix symbol,
     `[]'.  For example, the expression

          zeros (3, 0)

     will print

          ans =
          
          [](3x0)

`propagate_empty_matrices'
     If the value of `propagate_empty_matrices' is `true', functions
     like `inverse' and `svd' will return an empty matrix if they are
     given one as an argument.  The default value is `true'.  Not
     entirely correct now.  *Note Empty Matrices::.

`resize_on_range_error'
     If the value of `resize_on_range_error' is `true', expressions like

          for i = 1:10
            a (i) = i;
          endfor

     (for `a' previously undefined) result in the variable `a' being
     resized to be just large enough to hold the new value.  Otherwise
     uninitialized elements are set to zero.  If the value of
     `resize_on_range_error' is `false', an error message is printed
     and control is returned to the top level.  The default value is
     `true'.

`return_last_computed_value'
     If the value of `return_last_computed_value' is true, and a
     function is defined without explicitly specifying a return value,
     the function will return the value of the last expression.
     Otherwise, no value will be returned.  The default value is
     `false'.

     For example, the function

          function f ()
            2 + 2;
          endfunction

     will either return nothing, if `return_last_computed_value' is
     `false', or 4, if it is `true'.

`silent_functions'
     If the value of `silent_functions' is `true', internal output from
     a function is suppressed.  Otherwise, the results of statements
     within a function body that are not terminated with a semicolon
     will have their values printed.  The default value is `false'.

     For example, if the function

          function f ()
            2 + 2
          endfunction

     is executed, Octave will either print `ans = 4' or nothing
     depending on the value of `silent_functions'.

`split_long_rows'
     For large matrices, Octave may not be able to display all the
     columns of a given row on one line of your screen.  This can
     result in missing information or output that is nearly impossible
     to decipher, depending on whether your terminal truncates or wraps
     long lines.

     If the value of `split_long_rows' is `true', Octave will display
     the matrix in a series of smaller pieces, each of which can fit
     within the limits of your terminal width.  Each set of rows is
     labeled so that you can easily see which columns are currently
     being displayed.  For example:

          octave:13> rand (2, 9)
          ans =
          
           Columns 1 through 7:
          
             0.92205  0.72628  0.99841  0.62590  0.82422  0.77486  0.30258
             0.15999  0.79484  0.75443  0.86995  0.91430  0.23980  0.64591
          
           Columns 8 and 9:
          
            0.08894  0.13266
            0.28008  0.65575

     The default value of `split_long_rows' is `true'.

`treat_neg_dim_as_zero'
     If the value of `treat_neg_dim_as_zero' is `true', expressions like

          eye (-1)

     produce an empty matrix (i.e., row and column dimensions are zero).
     Otherwise, an error message is printed and control is returned to
     the top level.  The default value is `false'.

`warn_assign_as_truth_value'
`warn_comma_in_global_decl'
     If the value of `warn_comma_in_global_decl' is `true', a warning
     is issued for statements like

          global a = 1, b

     which makes the variables `a' and `b' global and assigns the value
     1 to the variable `a', because in this context, the comma is not
     interpreted as a statement separator.

     The default value of `warn_comma_in_global_decl' is `true'.

`warn_divide_by_zero'

File: octave.info,  Node: Other Built-in Variables,  Prev: User Preferences,  Up: Built-in Variables

Other Built-in Variables
========================

   In addition to these variables, there are two other special built-in
variables whose values are automatically updated.

`ans'
     This variable holds the most recently computed result that was not
     explicitly assigned to a variable.  For example, after the
     expression

          3^2 + 4^2

     is evaluated, the value of `ans' is `25'.

`PWD'
     The current working directory.  The value of `PWD' is updated each
     time the current working directory is changed with the `cd'
     command.  *Note System Utilities::.


File: octave.info,  Node: Arithmetic,  Next: Linear Algebra,  Prev: Built-in Variables,  Up: Top

Arithmetic
**********

   Unless otherwise noted, all of the functions described in this
chapter will work for real and complex scalar or matrix arguments.

* Menu:

* Utility Functions::
* Complex Arithmetic::
* Trigonometry::
* Sums and Products::


File: octave.info,  Node: Utility Functions,  Next: Complex Arithmetic,  Prev: Arithmetic,  Up: Arithmetic

Utility Functions
=================

   The following functions are available for working with complex
numbers.  Each expects a single argument, and given a matrix, they work
on an element by element basis.

`ceil (X)'
     Return the smallest integer not less than X.  If X is complex,
     return `ceil (real (X)) + ceil (imag (X)) * I'.

`floor (X)'
     Return the largest integer not greater than X.  If X is complex,
     return `floor (real (X)) + floor (imag (X)) * I'.

`fix (X)'
     Truncate X toward zero.  If X is complex, return `fix (real (X)) +
     fix (imag (X)) * I'.

`round (X)'
     Return the integer nearest to X.  If X is complex, return `round
     (real (X)) + round (imag (X)) * I'.

`sign (X)'
     Compute the "signum" function, which is defined as
                     -1, x < 0;
          sign (x) =  0, x = 0;
                      1, x > 0.
     For complex arguments, `sign' returns `x ./ abs (X)'.

`exp (X)'
     Compute the exponential of X.  To compute the matrix exponential,
     see *Note Linear Algebra::.

`log (X)'
     Compute the natural log of X.  To compute the matrix logarithm,
     see *Note Linear Algebra::.

`log10 (X)'
     Compute the base-10 log of X.

`sqrt (X)'
     Compute the square root of X.  To compute the matrix square root,
     see *Note Linear Algebra::.

`max (X)'
     For a vector argument, return the maximum value.  For a matrix
     argument, return the maximum value from each column, as a row
     vector.  Thus,

          max (max (X))

     returns the largest element of X.

     For complex arguments, the magnitude of the elements are used for
     comparison.

`min (X)'
     Like `max', but return the minimum value.

`rem (X, Y)'
     Return the remainder of `X / Y', computed using the expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.


File: octave.info,  Node: Complex Arithmetic,  Next: Trigonometry,  Prev: Utility Functions,  Up: Arithmetic

Complex Arithmetic
==================

   The following functions are available for working with complex
numbers.  Each expects a single argument.  Given a matrix they work on
an element by element basis.

`abs (X)'
     Compute the magnitude of X.

`angle (X)'
`arg (X)'
     Compute the argument of X.

`conj (X)'
     Return the complex conjugate of X.

`imag (X)'
     Return the imaginary part of X.

`real (X)'
     Return the real part of X.


File: octave.info,  Node: Trigonometry,  Next: Sums and Products,  Prev: Complex Arithmetic,  Up: Arithmetic

Trigonometry
============

   Octave provides the following trigonometric functions:

     sin    asin    sinh    asinh
     cos    acos    cosh    acosh
     tan    atan    tanh    atanh

Each of these functions expect a single argument.  For matrix arguments,
they work on an element by element basis.  For example, the expression

     sin ([1, 2; 3, 4])

produces

     ans =
     
        0.84147   0.90930
        0.14112  -0.75680


File: octave.info,  Node: Sums and Products,  Prev: Trigonometry,  Up: Arithmetic

Sums and Products
=================

`sum (X)'
     For a vector argument, return the sum of all the elements.  For a
     matrix argument, return the sum of the elements in each column, as
     a row vector.  The sum of an empty matrix is 0 if it has no
     columns, or a vector of zeros if it has no rows (*note Empty
     Matrices::.).

`prod (X)'
     For a vector argument, return the product of all the elements.
     For a matrix argument, return the product of the elements in each
     column, as a row vector.  The product of an empty matrix is 1 if
     it has no columns, or a vector of ones if it has no rows (*note
     Empty Matrices::.).

`cumsum (X)'
     Return the cumulative sum of each column of X.  For example,

          cumsum ([1, 2; 3, 4])

     produces

          ans =
          
            1  2
            4  6

`cumprod (X)'
     Return the cumulative product of each column of X.  For example,

          cumprod ([1, 2; 3, 4])

     produces

          ans =
          
            1  2
            3  8

`sumsq (X)'
     For a vector argument, return the sum of the squares of all the
     elements.  For a matrix argument, return the sum of the squares of
     the elements in each column, as a row vector.


File: octave.info,  Node: Linear Algebra,  Next: Nonlinear Equations,  Prev: Arithmetic,  Up: Top

Linear Algebra
**************

   This chapter documents the linear algebra functions of Octave.
Reference material for many of these options may be found in Golub and
Van Loan, `Matrix Computations, 2nd Ed.', Johns Hopkins, 1989, and in
`LAPACK Users' Guide', SIAM, 1992.

* Menu:

* Basic Matrix Functions::
* Matrix Factorizations::
* Functions of a Matrix::


File: octave.info,  Node: Basic Matrix Functions,  Next: Matrix Factorizations,  Prev: Linear Algebra,  Up: Linear Algebra

Basic Matrix Functions
======================

`balance'
          aa = balance (a, opt)
          [dd, aa] =  balance(a, opt)
          [dd, aa] = balance (a, opt)
          [cc, dd, aa, bb] = balance (a, b, opt)

     `[dd, aa] = balance (a)' returns `aa = dd \ a * dd'.  `aa' is a
     matrix whose row/column norms are roughly equal in magnitude, and
     `dd' = `p * d', where `p' is a permutation matrix and `d' is a
     diagonal matrix of powers of two.  This allows the equilibration
     to be computed without roundoff.  Results of eigenvalue
     calculation are typically improved by balancing first.

     `[cc, dd, aa, bb] = balance (a, b)'  returns `aa' (`bb') `=
     cc*a*dd (cc*b*dd)'), where `aa' and `bb' have non-zero elements of
     approximately the same magnitude and `cc' and `dd'  are permuted
     diagonal matrices as in `dd' for the algebraic eigenvalue problem.

     The eigenvalue balancing option `opt' is selected as follows:

    `"N"', `"n"'
          No balancing; arguments copied, transformation(s) set to
          identity.

    `"P"', `"p"'
          Permute argument(s) to isolate eigenvalues where possible.

    `"S"', `"s"'
          Scale to improve accuracy of computed eigenvalues.

    `"B"', `"b"'
          Permute and scale, in that order. Rows/columns of a (and b)
          that are isolated by permutation are not scaled.  This is the
          default behavior.

     Algebraic eigenvalue balancing uses standard LAPACK routines.

     Generalized eigenvalue problem balancing uses Ward's algorithm
     (SIAM J. Sci Stat. Comput., 1981).

`cond (A)'
     Compute the (two-norm) condition number of a matrix. `cond (a)' is
     defined as `norm (a) * norm (inv (a))', and is computed via a
     singular value decomposition.

`det (A)'
     Compute the determinant of A using LINPACK.

`eig'
                      = eig (a)
          [lambda, v] = eig (a)

     The eigenvalues (and eigenvectors) of a matrix are computed in a
     several step process which begins with a Hessenberg decomposition
     (see `hess'), followed by a Schur decomposition (see `schur'), from
     which the eigenvalues are apparent.  The eigenvectors, when
     desired, are computed by further manipulations of the Schur
     decomposition.

     See also: `hess', `schur'.

`givens'
          [c, s] = givens (x, y)
          G = givens (x, y)

     `G = givens(x, y)' returns a 2 x 2 orthogonal matrix `G = [c s;
     -s' c]' such that `G [x; y] = [*; 0]'  (x, y scalars)

`inv (A)'
`inverse (A)'
     Compute the inverse of the square matrix A.

`norm (A, P)'
     Compute the p-norm of the matrix A.  If the second argument is
     missing, `p = 2' is assumed.

     If A is a matrix:

    P = `1'
          1-norm, the largest column sum of A.

    P = `2'
          Largest singular value of A.

    P = `Inf'
          Infinity norm, the largest row sum of A.

    P = `"fro"'
          Frobenius norm of A, `sqrt (sum (diag (a' * a)))'.

     If A is a vector or a scalar:

    P = `Inf'
          `max (abs (a))'.

    P = `-Inf'
          `min (abs (a))'.

    other
          p-norm of A, `sum (abs (a) .^ p) ^ (1/p)'.

`rank (A)'
     Compute the rank of A, using the singular value decomposition.

`trace (A)'
     Compute the trace of A, `sum (diag (a))'.


File: octave.info,  Node: Matrix Factorizations,  Next: Functions of a Matrix,  Prev: Basic Matrix Functions,  Up: Linear Algebra

Matrix Factorizations
=====================

`hess'
               h = hess (a)
          [p, h] = hess (a)

     The Hessenberg decomposition is usually used as the first step in
     an eigenvalue computation, but has other applications as well (see
     Golub, Nash, and Van Loan, IEEE Trans. Auto. Contr., 1979.  The
     Hessenberg decomposition is `p * h * p' = a' where `p' is a square
     unitary matrix (`p' * p = I', using complex-conjugate
     transposition) and `h' is upper Hessenberg (`i >= j+1 => h(i,j) =
     0').

`lu (A)'
     Compute the LU decomposition of A, using subroutines from LAPACK.
     The result is returned in a permuted form, according to the
     optional return value P.  For example, given the matrix `a = [1,
     2; 3, 4]',

          [l, u, p] = lu (a)

     returns

          l =
          
            1.00000  0.00000
            0.33333  1.00000
          
          u =
          
            3.00000  4.00000
            0.00000  0.66667
          
          p =
          
            0  1
            1  0

`qr (A)'
     Compute the QR factorization of A, using standard LAPACK
     subroutines.  For example, given the matrix `a = [1, 2; 3, 4]',

          [q, r] = qr (a)

     returns

          q =
          
            -0.31623  -0.94868
            -0.94868   0.31623
          
          r =
          
            -3.16228  -4.42719
             0.00000  -0.63246

     The `qr' factorization has applications in the solution of least
     squares problems
          `min norm(A x - b)'
     for overdetermined systems of equations (i.e., `a'  is a tall,
     thin matrix).  The `qr' factorization is `q * r = a' where `q' is
     an orthogonal matrix and `r' is upper triangular.

     The permuted `qr' factorization `[q, r, pi] = qr (a)' will be
     implemented in a future version of Octave.  The `[q, r, pi]'
     factorization allows the construction of an orthogonal basis of
     `span (a)'.

`schur'
          [u, s] = schur (a, opt)   opt = "a", "d", or "u"
               s = schur (a)

     The Schur decomposition is used to compute eigenvalues of a square
     matrix, and has applications in the solution of algebraic Riccati
     equations in control (see `are' and `dare').  `schur' always
     returns `s = u' * a * u' where `u'  is a unitary matrix (`u'* u'
     is identity) and `s' is upper triangular.  The eigenvalues of `a'
     (and `s') are the diagonal elements of `s' If the matrix `a' is
     real, then the real Schur decomposition is computed, in which the
     matrix `u' is orthogonal and `s' is block upper triangular with
     blocks of size at most `2 x 2' blocks along the diagonal.  The
     diagonal elements of `s' (or the eigenvalues of the `2 x 2'
     blocks, when appropriate) are the eigenvalues of `a' and `s'.  `s'.

     The eigenvalues are optionally ordered along the diagonal
     according to the value of `opt'.  `opt = "a"' indicates that all
     eigenvalues with negative real parts should be moved to the leading
     block of `s' (used in `are'), `opt = "d"' indicates that all
     eigenvalues with magnitude less than one should be moved to the
     leading block of `s' (used in `dare'), and `opt = "u"', the
     default, indicates that no ordering of eigenvalues should occur.
     The leading `k' columns of `u' always span the `a'-invariant
     subspace corresponding to the `k' leading eigenvalues of `s'.

`svd (A)'
     Compute the singular value decomposition of A a = u * sigma * v'

     The function `svd' normally returns the vector of singular values.
     If asked for three return values, it computes U, S, and V.  For
     example,

          svd (hilb (3))

     returns

          ans =
          
            1.4083189
            0.1223271
            0.0026873

     and

          [u, s, v] = svd (hilb (3))

     returns

          u =
          
            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867
          
          s =
          
            1.40832  0.00000  0.00000
            0.00000  0.12233  0.00000
            0.00000  0.00000  0.00269
          
          v =
          
            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867


File: octave.info,  Node: Functions of a Matrix,  Prev: Matrix Factorizations,  Up: Linear Algebra

Functions of a Matrix
=====================

`expm'
          expm (a)

     Returns the exponential of a matrix, defined as the infinite
     Taylor series
          expm(a) = I + a + a^2/2! + a^3/3! + ...
     The Taylor series is *not* the way to compute the matrix
     exponential; see Moler and Van Loan, `Nineteen Dubious Ways to
     Compute the Exponential of a Matrix', SIAM Review, 1978.  This
     routine uses Ward's diagonal Pade' approximation method with three
     step preconditioning (SIAM J. Numer Anal, 1977).

     Diagonal Pade'  approximations are rational polynomials of matrices
               -1
          D (a)   N (a)
      whose Taylor series matches the first `2q+1' terms of the Taylor
     series above; direct evaluation of the Taylor series (with the
     same preconditioning steps) may be desirable in lieu of the Pade'
     approximation when `Dq(a)' is ill-conditioned.

`logm (A)'
     Compute the matrix logarithm of the square matrix A.  Note that
     this is currently implemented in terms of an eigenvalue expansion
     and needs to be improved to be more robust.

`sqrtm (A)'
     Compute the matrix square root of the square matrix A.  Note that
     this is currently implemented in terms of an eigenvalue expansion
     and needs to be improved to be more robust.

`kron (A, B)'
     Form the kronecker product of two matrices, defined block by block
     as

          x = [a(i,j) b]

`qzhess (A, B)'
     Compute the Hessenberg-triangular decomposition of the matrix
     pencil `(a, b)'.  This function returns `aa = q * a * z', `bb = q
     * b * z', `q', `z' orthogonal.  For example,

          [aa, bb, q, z] = qzhess (a, b)

     The Hessenberg-triangular decomposition is the first step in Moler
     and Stewart's QZ decomposition algorithm.  (The QZ decomposition
     will be included in a later release of Octave.)

     Algorithm taken from Golub and Van Loan, `Matrix Computations, 2nd
     edition'.

`qzval (A, B)'
     Compute generalized eigenvalues.

`syl (A, B, C)'
     Solve the Sylvester equation A X + X B + C = 0 using standard
     LAPACK subroutines.


File: octave.info,  Node: Nonlinear Equations,  Next: Differential Equations,  Prev: Linear Algebra,  Up: Top

Nonlinear Equations
*******************

   Octave can solve sets of nonlinear equations of the form F (x) = 0

using the function `fsolve', which is based on the MINPACK subroutine
`hybrd'.

   For example, to solve the set of equations -2x^2 + 3xy   + 4 sin(y)
= 6  3x^2 - 2xy^2 + 3 cos(x) = -4

you first need to write a function to compute the value of the given
function.  For example:

     function y = f (x)
     
       y(1) = -2*x(1)^2 + 3*x(1)*x(2)   + 4*sin(x(2)) - 6;
       y(2) =  3*x(1)^2 - 2*x(1)*x(2)^2 + 3*cos(x(1)) + 4;
     
     endfunction

   Then, call `fsolve' with a specified initial condition to find the
roots of the system of equations.  For example

     [x, info] = fsolve ("f", [1; 2])

results in the solution

     x =
     
       0.57983
       2.54621
     
     info = 1

   A value of `info = 1' indicates that the solution has converged.

   The function `perror' may be used to print English messages
corresponding to the numeric error codes.  For example,

     perror ("fsolve", 1)

prints

     solution converged to requested tolerance


File: octave.info,  Node: Differential Equations,  Next: Optimization,  Prev: Nonlinear Equations,  Up: Top

Differential Equations
**********************

   Octave has two built-in functions for solving differential equations.
Both are based on reliable ODE solvers written in Fortran.

* Menu:

* Ordinary Differential Equations::
* Differential-Algebraic Equations::


File: octave.info,  Node: Ordinary Differential Equations,  Next: Differential-Algebraic Equations,  Prev: Differential Equations,  Up: Differential Equations

Ordinary Differential Equations
===============================

   The function `lsode' can be used Solve ODEs of the form dx/dt = f
(x, t)

using Hindmarsh's ODE solver LSODE.

     lsode (FCN, X0, T_OUT, T_CRIT)

   The first argument is the name of the function to call to compute
the vector of right hand sides.  It must have the form

     XDOT = f (X, T)

where XDOT and X are vectors and T is a scalar.

   The second argument specifies the initial condition, and the third
specifies a vector of output times at which the solution is desired,
including the time corresponding to the initial condition.

   The fourth argument is optional, and may be used to specify a set of
times that the ODE solver should not integrate past.  It is useful for
avoiding difficulties with singularities and points where there is a
discontinuity in the derivative.

   Here is an example of solving a set of two differential equations
using `lsode'.  The function

     function xdot = f (x, t)
     
       r = 0.25;
       k = 1.4;
       a = 1.5;
       b = 0.16;
       c = 0.9;
       d = 0.8;
     
       xdot(1) = r*x(1)*(1 - x(1)/k) - a*x(1)*x(2)/(1 + b*x(1));
       xdot(2) = c*a*x(1)*x(2)/(1 + b*x(1)) - d*x(2);
     
     endfunction

is integrated with the command

     x = lsode ("f", [1; 2], (t = linspace (0, 50, 200)'));

producing a set of 200 values stored in the variable X.  Note that this
example takes advantage of the fact that an assignment produces a value
to store the values of the output times in the variable T directly in
the function call   The results can then be plotted using the command

     plot (t, x)

   See Alan C. Hindmarsh, `ODEPACK, A Systematized Collection of ODE
Solvers', in Scientific Computing, R. S. Stepleman, editor, (1983) for
more information about this family of ODE solvers.


File: octave.info,  Node: Differential-Algebraic Equations,  Prev: Ordinary Differential Equations,  Up: Differential Equations

Differential-Algebraic Equations
================================

   The function `dassl' can be used Solve DAEs of the form 0 = f
(x-dot, x, t),    x(t=0) = x_0, x-dot(t=0) = x-dot_0 $$

     dassl (FCN, X_0, XDOT_0, T_OUT, T_CRIT)

   The first argument is the name of the function to call to compute
the vector of residuals.  It must have the form

     RES = f (X, XDOT, T)

where X, XDOT, and RES are vectors, and T is a scalar.

   The second and third arguments to `dassl' specify the initial
condition of the states and their derivatives, and the fourth argument
specifies a vector of output times at which the solution is desired,
including the time corresponding to the initial condition.

   The set of initial states and derivatives are not strictly required
to be consistent.  In practice, however, DASSL is not very good at
determining a consistent set for you, so it is best if you ensure that
the initial values result in the function evaluating to zero.

   The fifth argument is optional, and may be used to specify a set of
times that the DAE solver should not integrate past.  It is useful for
avoiding difficulties with singularities and points where there is a
discontinuity in the derivative.

   See K. E. Brenan, et al., `Numerical Solution of Initial-Value
Problems in Differential-Algebraic Equations', North-Holland (1989) for
more information about the implementation of DASSL.


File: octave.info,  Node: Optimization,  Next: Quadrature,  Prev: Differential Equations,  Up: Top

Optimization
************

* Menu:

* Linear Programming::
* Quadratic Programming::
* Nonlinear Programming::


File: octave.info,  Node: Linear Programming,  Next: Quadratic Programming,  Prev: Optimization,  Up: Optimization

Linear Programming
==================

`lp_solve'
          lp_solve ()

     Sorry, this hasn't been implemented yet.


File: octave.info,  Node: Quadratic Programming,  Next: Nonlinear Programming,  Prev: Linear Programming,  Up: Optimization

Quadratic Programming
=====================

`qpsol'
          [x, obj, info, lambda]
             = qpsol (x, H, c, lb, ub, lb, A, ub)
     Solve quadratic programs using Gill and Murray's QPSOL.  Because
     QPSOL is not freely redistributable, this function is only
     available if you have obtained your own copy of QPSOL.  *Note
     Installation::.


File: octave.info,  Node: Nonlinear Programming,  Prev: Quadratic Programming,  Up: Optimization

Nonlinear Programming
=====================

`fsqp'
          fsqp ()

     Sorry, this hasn't been implemented yet.

`npsol'
          [x, obj, info, lambda]
             = npsol (x, 'phi', lb, ub, lb, A, ub, lb, 'g', ub)
     Solve nonlinear programs using Gill and Murray's NPSOL.  Because
     NPSOL is not freely redistributable, this function is only
     available if you have obtained your own copy of NPSOL.  *Note
     Installation::.

     The second argument is a string containing the name of the
     objective function to call.  The objective function must be of the
     form

          y = phi (x)

     where x is a vector and y is a scalar.


File: octave.info,  Node: Quadrature,  Next: Control Theory,  Prev: Optimization,  Up: Top

Quadrature
**********

* Menu:

* Functions of one Variable::
* Orthogonal Collocation::


File: octave.info,  Node: Functions of one Variable,  Next: Orthogonal Collocation,  Prev: Quadrature,  Up: Quadrature

Functions of one Variable
=========================

`quad'
          [v, ier, nfun] = quad ('f', a, b)
          [v, ier, nfun] = quad ('f', a, b, tol)
          [v, ier, nfun] = quad ('f', a, b, tol, sing)

     Integrate a nonlinear function of one variable using Quadpack.

     Where the first argument is the name of the  function to call to
     compute the value of the integrand.  It must have the form

          y = f (x)

     where y and x are scalars.

     The second and third arguments are limits of integration.  Either
     or both may be infinite.  The optional argument tol specifies the
     desired accuracy of the result.  The optional argument SING is a
     vector of values at which the integrand is singular.


File: octave.info,  Node: Orthogonal Collocation,  Prev: Functions of one Variable,  Up: Quadrature

Orthogonal Collocation
======================

`colloc'
          [r, A, B, q] = colloc (n)
          [r, A, B, q] = colloc (n, 'left')
          [r, A, B, q] = colloc (n, 'left', 'right')

     Compute derivative and integral weight matrices for orthogonal
     collocation using the subroutines given in J. Michelsen and M. L.
     Villadsen, `Solution of Differential Equation Models by Polynomial
     Approximation'.


File: octave.info,  Node: Control Theory,  Next: Signal Processing,  Prev: Quadrature,  Up: Top

Control Theory
**************

`abcddim (A, B, C, D)'
     Check for compatibility of the dimensions of the matrices defining
     the linear system [A, B, C, D] corresponding to
          dx/dt = a x + b u
          y = c x + d u
     or a similar discrete-time system.

     If the matrices are compatibly dimensioned, then `abcddim' returns
     N = number of system states, M = number of system inputs, and P =
     number of system outputs.  Otherwise `abcddim' returns N = M = P =
     -1.

`are (A, B, C, OPT)'
     Returns the solution, X, of the algebraic Riccati equation

          a' x + x a - x b x + c = 0

     for identically dimensioned square matrices A, B, C.  If B (C) is
     not square, then the function attempts to use `B*B'' (`C'*C')
     instead.

     Solution method: apply Laub's Schur method (IEEE Trans. Auto.
     Contr, 1979) to the appropriate Hamiltonian matrix.

     OPT is an option passed to the eigenvalue balancing routine.
     Default is `"B"'.

`dare (A, B, C, R, OPT)'
     Returns the solution, X of the discrete-time algebraic Riccati
     equation

          a' x a - x + a' x b (r + b' x b)^(-1) b' x a + c = 0

     for matrices with dimensions:

          A: N by N
          B: N by M
          C: N by N, symmetric positive semidefinite
          R: M by M, symmetric positive definite (invertible)

     If C is not square, then the function attempts to use `C'*C'
     instead.

     Solution method: Laub's Schur method (IEEE Transactions on
     Automatic Control, 1979) is applied to the appropriate symplectic
     matrix.

     See also: Ran and Rodman, `Stable Hermitian Solutions of Discrete
     Algebraic Riccati Equations', Mathematics of Control, Signals and
     Systems, Volume 5, Number 2 (1992).

     OPT is an option passed to the eigenvalue balancing routine.  The
     default is `"B"'.

`dlyap (A, B)'
     Solve the discrete-time Lyapunov equation

          a x a' - x + b = 0

     for square matrices A, B.  If B is not square, then the function
     attempts to solve either

          a x a' - x + b b' = 0

     or

          a' x a - x + b' b = 0

     whichever is appropriate.

     Uses Schur decomposition method as in Kitagawa (International J.
     Control, 1977); column-by-column solution method as suggested in
     Hammarling, IMA J. Num. Anal., 1982.

`is_controllable (A, B, TOL)'
     If the pair (a, b) is controllable, then return value 1.
     Otherwise, returns a value of 0

     TOL is a roundoff parameter, set to `2*eps' if omitted.

     Currently just constructs the controllability matrix and checks
     rank.  A better method is as follows (Boley and Golub, Sys. and
     Contr. Letters, 1984):  Controllability is determined by applying
     Arnoldi iteration with complete re-orthogonalization to obtain an
     orthogonal basis of the Krylov subspace
                             n-1
           span([b,a*b,...,a^   b]).

`is_observable (A, C, TOL)'
     Returns 1 if the pair `(a, c)' is observable.  Otherwise, returns
     a value of 0.

`lqe (A, G, C, SIGW, SIGV, Z)'
          [k, p, e] = lqe (a, g, c, sigw, sigv, z)

     Linear quadratic estimator (Kalman filter) design for the
     continuous time system

          dx/dt = A x + B u + G w
              y = C x + D u + w

     where W, V are zero-mean gaussian noise processes with respective
     intensities

          sigw = cov (w, w)
          sigv = cov (v, v)

     Z (if specified) is the cross-covariance `cov (W, V)'; the default
     value is `cov (W, V) = 0'.

     Observer structure is `dz/dt = A z + B u + k (y - C z - D u)'

     returns:

     K is observer gain:  `(A - K C)' is stable.

     P is solution of algebraic Riccati equation.

     E is the vector of closed loop poles of `(A - K C)'.

`lqr (A, B, Q, R, Z)'
          [k, p, e] = lqr (a, b, q, r, z)

     Linear quadratic regulator design for the continuous time system
          dx/dt = A x + B u
     to minimize the cost functional
                infinity
                /
            J = |  x' Q x + u' R u
               /
              t=0

     Z omitted or
                infinity
                /
            J = |  x' Q x + u' R u + 2 x' Z u
               /
              t=0
     Z included

     Returns:

     K is state feedback gain:  `(A - B K)' is stable.

     P is the stabilizing solution of appropriate algebraic Riccati
     equation.

     E is the vector of the closed loop poles of `(A - B K)'.

`lyap (A, B, C)'
     Solve the Lyapunov (or Sylvester) equation via the Bartels-Stewart
     algorithm (Comm. ACM, 1972).

     If `(a, b, c)' are specified, then `lyap' returns the solution of
     the  Sylvester equation

          a x + x b + c = 0

     If only `(a, b)' are specified, then `lyap' returns the solution
     of the Lyapunov equation

          a' x + x a + b = 0

     If B is not square, then `lyap' returns the solution of either

          a' x + x a + b' b = 0

     or

          a x + x a' + b b' = 0

     whichever is appropriate.

     Solves by using the Bartels-Stewart algorithm (1972).

`tzero (A, B, C, D, BAL)'
     Compute the transmission zeros of [A, B, C, D].

     BAL = balancing option (see balance); default is `"B"'.

     Needs to incorporate `mvzero' algorithm to isolate finite zeros;
     see Hodel, `Computation of System Zeros with Balancing', Lin. Alg.
     Appl., July 1993.


File: octave.info,  Node: Signal Processing,  Next: Statistics,  Prev: Control Theory,  Up: Top

Signal Processing
*****************

   I hope that someday Octave will include more signal processing
functions.  If you would like to help improve Octave in this area,
please contact `bug-octave@che.utexas.edu'.

`fft (A)'
     Compute the FFT of A using subroutines from FFTPACK.

`ifft (A)'
     Compute the inverse FFT of A using subroutines from FFTPACK.


File: octave.info,  Node: Statistics,  Next: Plotting,  Prev: Signal Processing,  Up: Top

Statistics
**********

   I hope that someday Octave will include more statistics functions.
If you would like to help improve Octave in this area, please contact
`bug-octave@che.utexas.edu'.

`mean (A)'
     If A is a vector, compute the mean of the elements of A.  If A is
     a matrix, compute the mean for each column and return them in a
     row vector.

`median (A)'
     If A is a vector, compute the median value of the elements of A.
     If A is a matrix, compute the median value for each column and
     return them in a row vector.

`std (A)'
     If A is a vector, compute the standard deviation of the elements
     of A.  If A is a matrix, compute the standard deviation for each
     column and return them in a row vector.


File: octave.info,  Node: Plotting,  Next: Input and Output,  Prev: Statistics,  Up: Top

Plotting
********

   All of Octave's plotting functions use gnuplot to handle the actual
graphics.  There are two primitive functions, `gplot' and `gsplot',
that behave almost exactly like the corresponding `gnuplot' functions
`plot' and `splot' functions.  A number of other higher level plotting
functions, patterned after the graphics functions found in MATLAB
version 3.5, are also available.  These higher leverl functions are all
implemented in terms of the two primitive plotting functions.

* Menu:

* Two-Dimensional Plotting::
* Three-Dimensional Plotting::
* Miscellaneous Plotting Functions::


File: octave.info,  Node: Two-Dimensional Plotting,  Next: Three-Dimensional Plotting,  Prev: Plotting,  Up: Plotting

Two-Dimensional Plotting
========================

   The syntax for Octave's primitive two-dimensional plotting function,
`gplot', is

     gplot RANGES EXPRESSION USING TITLE STYLE

where the RANGES, USING, TITLE, and STYLE arguments are optional, and
the USING, TITLE and STYLE qualifiers may appear in any order after the
expression.  You may plot multiple expressions with a single command by
separating them with commas.  Each expression may have its own set of
qualifiers.

   The optional item RANGES has the syntax

     [ x_lo : x_up ] [ y_lo : y_up ]

and may be used to specify the ranges for the axes of the plot,
independent of the actual range of the data.  The range for the y axes
and any of the individual limits may be omitted.  A range `[:]'
indicates that the default limits should be used.  This normally means
that a range just large enough to include all the data points will be
used.

   The expression to be plotted must not contain any literal matrices
(e.g. `[ 1, 2; 3, 4 ]') since it is nearly impossible to distinguish a
plot range from a matrix of data.

   See the help for gnuplot for a description of the syntax for the
optional items.

   By default, the `gplot' command plots the second column of a matrix
versus the first.  If the matrix only has one column, it is taken as a
vector of y-coordinates and the x-coordinate is taken as the element
index, starting with zero.  If there are more than two columns, you can
choose which columns to plot with the USING qualifier.

   For example,

     gplot rand (100,1) with linespoints

will plot 100 random values and connect them with lines.  When `gplot'
is used to plot a column vector, the indices of the elements are taken
as x values.

   Here is another example that demonstrates the use of the USING
qualifier.  Given the data

     x = (-10:0.1:10)';
     data = [x, sin(x), cos(x)];

the command

     gplot [-11:11] [-1.1:1.1] data with lines, data using 1:3 with impulses

will plot two lines.  The first line is generated by the command `data
with lines', and is a graph of the sine function over the range -10 to
10.  The data is taken from the first two columns of the matrix because
columns to plot were not specified with the USING qualifier.

   The clause `using 1:3' in the second part of this plot command
specifies that the first and third columns of the matrix `data' should
be taken as the values to plot.

   In this example, the ranges have been explicitly specified to be a
bit larger than the actual range of the data so that the curves do not
touch the border of the plot.

   In addition to the basic plotting commands, the whole range of `set'
and `show' commands from `gnuplot' are available, as is `replot'.  For
example,

     set term tek40
     set title "sine with lines and cosine with impulses"
     replot
     show title

   The MATLAB-style two-dimensional plotting commands are:

`plot (X, Y)'
     This function produces two-dimensional plots.

     If the first argument is a vector and the second is a matrix, the
     the vector is plotted versus the columns (or rows) of the matrix.
     (using whichever combination matches, with columns tried first.)

     If the first argument is a matrix and the second is a vector, the
     the columns (or rows) of the matrix are plotted versus the vector.
     (using whichever combination matches, with columns tried first.)

     If both arguments are vectors, the elements of Y are plotted versus
     the elements of X.

     If both arguments are matrices, the columns of y are plotted
     versus the columns of X.  In this case, both matrices must have
     the same number of rows and columns and no attempt is made to
     transpose the arguments to make the number of rows match.

     If both arguments are scalars, a single point is plotted.

     If only one argument is given, it is taken as the set of y
     coordinates and the X coordinates are taken to be the indices of
     the elements, starting with 1.

`loglog (X, Y)'
     Make a two-dimensional plot of Y versus X using log scales for
     both axes.

`semilogx (X, Y)'
     Make a two-dimensional plot of Y versus X using a log scale for
     the X axis.

`semilogy (X, Y)'
     Make a two-dimensional plot of Y versus X using a log scale for
     the Y axis.

`contour (Z, N, X, Y)'
`polar (THETA, RHO)'
     Make a two-dimensional plot given polar the coordinates THETA and
     RHO.

