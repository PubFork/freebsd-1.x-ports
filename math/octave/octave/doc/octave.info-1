This is Info file octave.info, produced by Makeinfo-1.52 from the input
file octave.texi.

   Copyright (C) 1993 John W. Eaton.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: octave.info,  Node: Top,  Next: Acknowledgements,  Prev: (dir),  Up: (dir)



   This manual documents how to run, install and port Octave, as well as
its new features and incompatibilities, and how to report bugs.  It
corresponds to Octave version 0.79.

* Menu:

* Acknowledgements::            Thanks.
* Introduction::                A brief introduction to Octave.
* Expressions::                 Expressions.
* Statements::                  Looping and program flow control.
* Built-in Variables::          Descriptions of all built-in variables.
* Arithmetic::
* Linear Algebra::
* Nonlinear Equations::
* Differential Equations::
* Optimization::
* Quadrature::
* Control Theory::
* Signal Processing::
* Statistics::
* Plotting::
* Input and Output::
* Special Matrices::
* Matrix Manipulation::
* String Functions::
* System Utilities::
* Command History Functions::
* Help::
* Programming Utilities::
* Amusements::
* Invoking Octave::             Command options supported by Octave.
* Command Line Editing::        Command history and editing.
* Installation::                How to configure, compile and install Octave.
* Trouble::                     If you have trouble installing Octave.
* Concept Index::               An item for each concept.
* Variable Index::              An item for each documented variable.
* Function Index::              An item for each documented function.
* Operator Index::              An item for each documented operator.

 -- The Detailed Node Listing --

Acknowledgements

* Contributors::                People who contributed to developing of Octave.

A Brief Introduction to Octave

* Running Octave::
* Simple Examples::

Expressions

* Constant Expressions::
* Matrices::
* Ranges::
* Variables::
* Index Expressions::
* Calling Functions::
* Global Variables::
* Keywords::
* Arithmetic Ops::
* Comparison Ops::
* Boolean Expressions::
* Assignment Ops::
* Increment Ops::
* Operator Precedence::

Constant Expressions

* Numeric Constants::
* String Constants::

Matrices

* Empty Matrices::

Statements

* Statement Lists::
* Declaration Statements::
* Selection Statements::
* Iteration Statements::
* Defining Functions::
* Jump Statements::

Built-in Variables

* Predefined Constants::
* User Preferences::
* Other Built-in Variables::

Arithmetic

* Utility Functions::
* Complex Arithmetic::
* Trigonometry::
* Sums and Products::

Linear Algebra

* Basic Matrix Functions::
* Matrix Factorizations::
* Functions of a Matrix::

Differential Equations

* Ordinary Differential Equations::
* Differential-Algebraic Equations::

Optimization

* Linear Programming::
* Quadratic Programming::
* Nonlinear Programming::

Quadrature

* Functions of one Variable::
* Orthogonal Collocation::

Plotting

* Two-Dimensional Plotting::
* Three-Dimensional Plotting::
* Miscellaneous Plotting Functions::

Input and Output

* Basic Input and Output::
* C-Style I/O Functions::

C-Style I/O Functions

* Opening and Closing Files::
* Formatted Output::
* Output Conversion Syntax::
* Table of Output Conversions::
* Integer Conversions::
* Floating-Point Conversions::
* Other Output Conversions::
* Formatted Input::
* Input Conversion Syntax::
* Table of Input Conversions::
* Numeric Input Conversions::
* String Input Conversions::
* Other I/O Functions::

Special Matrices

* Special Utility Matrices::
* Famous Matrices::

Matrix Manipulation

* Finding Elements and Checking Conditions::
* Rearranging Matrices::

Help

* Using Info::
* Cursor Commands::
* Scrolling Commands::
* Node Commands::
* Searching Commands::
* Xref Commands::
* Window Commands::
* Printing Nodes::
* Other Info Commands::
* Info Variables::

Using Info

* Cursor Commands::	    Commands which move the cursor within a node.
* Scrolling Commands::	    Commands for moving the node around in a window.
* Node Commands::	    Commands for selecting a new node.
* Searching Commands::	    Commands for searching an info file.
* Xref Commands::	    Commands for selecting cross references.
* Window Commands::	    Commands which manipulate multiple windows.
* Printing Nodes::	    How to print out the contents of a node.
* Other Info Commands::     A few commands that defy categories.
* Info Variables::	    How to change the default behaviour of Info.

Selecting Cross References

* Parts of an Xref::            What a cross reference is made of.
* Selecting Xrefs::             Commands for selecting menu or note items.

Manipulating Multiple Windows

* The Mode Line::               What appears in the mode line?
* Basic Windows::               Manipulating windows in Info.
* The Echo Area::               Used for displaying errors and reading input.

Programming Utilities

* Evaluating Strings as Commands::
* Miscellaneous Utilities::

Command Line Editing

* Introduction and Notation::   Notation used in this text.
* Readline Interaction::        The minimum set of commands for editing a line.
* Readline Init File::          Customizing Readline from a user's view.

Readline Interaction

* Readline Bare Essentials::    The least you need to know about Readline.
* Readline Movement Commands::  Moving about the input line.
* Readline Killing Commands::   How to delete text, and how to get it back!
* Readline Arguments::          Giving numeric arguments to commands.

Readline Init File

* Readline Init Syntax::        Syntax for the commands in `~/.inputrc'.
* Readline Vi Mode::            Switching to `vi' mode in Readline.

Readline Init Syntax

* Commands For Moving::         Moving about the line.
* Commands For History::        Getting at previous lines.
* Commands For Text::           Commands for changing text.
* Commands For Killing::        Commands for killing and yanking.
* Numeric Arguments::           Specifying numeric arguments, repeat counts.
* Commands For Completion::     Getting Readline to do the typing for you.
* Miscellaneous Commands::      Other miscellaneous commands.

Installing Octave

* Binary Distributions::

Binary Distributions

* Installing Octave from a Binary Distribution::
* Creating a Binary Distribution::

Known Causes of Trouble with Octave

* Actual Bugs::                 Bugs we will fix later.
* Installation Problems::       Problems that manifest when you install Octave.
* Disappointments::             Regrettable things we can't change.
* Reporting Bugs::
* Bug Criteria::
* Bug Lists::
* Bug Reporting::
* Sending Patches::
* Service::

Reporting Bugs

* Bug Criteria::
* Where: Bug Lists.             Where to send your bug report.
* Reporting: Bug Reporting.     How to report a bug effectively.
* Patches: Sending Patches.     How to send a patch for Octave.


File: octave.info,  Node: Acknowledgements,  Next: Introduction,  Prev: Top,  Up: Top

Acknowledgements
****************

* Menu:

* Contributors::                People who contributed to developing of Octave.


File: octave.info,  Node: Contributors,  Prev: Acknowledgements,  Up: Acknowledgements

Contributors to Octave
======================

   In addition to John W. Eaton, several people have written parts of
Octave.

   * A. Scottedward Hodel (scotte@eng.auburn.edu) contributed a number
     of functions including `expm', `qzval', `qzhess', `syl', `lyap',
     and `balance'.

   * John Campbell (jcc@che.utexas.edu) wrote most of the file and
     C-style input and output functions.

   * R. Bruce Tenison (Bruce.Tenison@eng.auburn.edu) wrote the `hess'
     and `schur' functions.

   * Fook Fah Yap (ffy@eng.cam.ac.uk) provided the `fft' and `ifft'
     functions and valuable bug reports for early versions.

   * Brian Fox (bfox@gnu.ai.mit.edu) wrote the readline library used for
     command history editing, and the portion of this manual that
     documents it.

   Special thanks to the following people and organizations for
supporting the development of Octave:

   * Digital Equipment Corporation, for an equipment grant as part of
     their External Research Program.

   * Sun Microsystems, Inc., for an Academic Equipment grant.

   * The University of Texas College of Engineering, for providing a
     Challenge for Excellence Research Supplement, and for providing an
     Academic Development Funds grant.

   * Texaco Chemical Company, for providing funding to continue the
     development of this software.

   * Noel Bell, Senior Engineer, Texaco Chemical Company, Austin Texas.

   * James B. Rawlings, Associate Professor, Department of Chemical
     Engineering, The University of Texas at Austin.

   Portions of this document have been adapted from the GAWK, readline,
GCC, and C library manuals, published by the Free Software Foundation,
675 Mass Ave, Cambridge, MA 02139, USA.

   This project would not have been possible without the GNU software
used in and used to produce Octave.


File: octave.info,  Node: Introduction,  Next: Expressions,  Prev: Acknowledgements,  Up: Top

A Brief Introduction to Octave
******************************

   This manual documents how to run, install and port Octave, and how
to report bugs.

   Octave is a high-level language for numerical computations.  It
provides a convenient command line interface for performing numerical
experiments, and may also be used as a batch-oriented language.

   This document corresponds to Octave version 0.79.

* Menu:

* Running Octave::
* Simple Examples::


File: octave.info,  Node: Running Octave,  Next: Simple Examples,  Prev: Introduction,  Up: Introduction

Running Octave
==============

   On most systems, the way to invoke Octave is with the shell command
`octave'.  Octave displays an initial message and then a prompt
indicating it is ready to accept input.  You can begin typing Octave
commands immediately afterward.

   If you get into trouble, you can usually interrupt Octave by typing
`C-c'.  This will normally return you to Octave's prompt.

   To exit Octave, type `quit', or `exit' at the Octave prompt.

   On systems that support job control, you can suspend Octave by
sending it a SIGTSTP signal, usually by typing `C-z'.


File: octave.info,  Node: Simple Examples,  Prev: Running Octave,  Up: Introduction

Simple Examples
===============

   The following chapters describe all of Octave's features in detail,
but before doing that, it might be helpful to give a sampling of some
of its capabilities.

   If you are new to Octave, I recommend that you try these examples to
begin learning Octave by using it.  Lines marked with `octave:13>' are
lines you type, ending each with a carriage return.  Octave will
respond with an answer, or by displaying a graph.

Creating a Matrix
-----------------

   To create a new matrix and store it in a variable so that it you can
refer to it later, type the command

     octave:1> a = [ 1, 1, 2; 3, 5, 8; 13, 21, 34 ]

Octave will respond by printing the matrix in neatly aligned columns.
Ending a command with a semicolon tells Octave to not print the result
of a command.  For example

     octave:2> b = rand (3, 2);

will create a 3 row, 2 column matrix with each element set to a random
value between zero and one.

   To display the value of any variable, simply type the name of the
variable.  For example, to display the value stored in the matrix `b',
type the command

     octave:3> b

Matrix Arithmetic
-----------------

   Octave has a convenient operator notation for performing matrix
arithmetic.  For example, to multiply the matrix `a' by a scalar value,
type the command

     octave:4> 2 * a

   To multiply two matrices, type the command

     octave:4> a * b

   To form the matrix product  `transpose (a) * a', type the command

     octave:5> a' * a

Solving Linear Equations
------------------------

   To solve the set of linear equations `Ax = b', use the left division
operator, `\':

     octave:6> a \ b

This is conceptually equivalent to inv (A) * b, but avoids computing
the inverse of a matrix directly.

   If the coefficient matrix is singular, Octave will print a warning
message and compute a minimum norm solution.

Integrating Differential Equations
----------------------------------

   Octave has built-in functions for solving nonlinear differential
equations of the form
     dx
     -- = f (x, t)
     dt

with the initial condition

     x(t = t0) = x0

For Octave to integrate equations of this form, you must first provide a
definition of the function `f(x,t)'.  This is straightforward, and may
be accomplished by entering the function body directly on the command
line.  For example, the following commands define the right hand side
function for an interesting pair of nonlinear differential equations.
Note that while you are entering a function, Octave responds with a
different prompt, to indicate that it is waiting for you to complete
your input.

     octave:7> function xdot = f (x, t)
     >
     >  r = 0.25;
     >  k = 1.4;
     >  a = 1.5;
     >  b = 0.16;
     >  c = 0.9;
     >  d = 0.8;
     >
     >  xdot(1) = r*x(1)*(1 - x(1)/k) - a*x(1)*x(2)/(1 + b*x(1));
     >  xdot(2) = c*a*x(1)*x(2)/(1 + b*x(1)) - d*x(2);
     >
     > endfunction

Given the initial condition

     x0 = [1; 2];

and the set of output times as a column vector (note that the first
output time corresponds to the initial condition given above)

     t = linspace (0, 50, 200)';

it is easy to integrate the set of differential equations:

     x = lsode ("f", x0, t);

The function `lsode' uses the Livermore Solver for Ordinary
Differential Equations, described in A. C. Hindmarsh, `ODEPACK, a
Systematized Collection of ODE Solvers', in: Scientific Computing, R. S.
Stepleman et al. (Eds.), North-Holland, Amsterdam, 1983, pages 55-64.

Producing Graphical Output
--------------------------

   To display the solution of the previous example graphically, use the
command

     plot (t, x)

   If you are using the X Window System, Octave will automatically
create a separate window to display the plot.  If you are using a
terminal that supports some other graphics commands, you will need to
tell Octave what kind of terminal you have.  Type the command

     set term

to see a list of the supported terminal types.  Octave uses `gnuplot'
to display graphics, and can display graphics on any terminal that is
supported by `gnuplot'.

   To capture the output of the plot command in a file rather than
sending the output directly to your terminal, you can use a set of
commands like this

     set term postscript
     set output "foo.ps"
     replot

This will work for other types of output devices as well.  Octave's
`set' command is really just piped to the `gnuplot' subprocess, so that
once you have a plot on the screen that you like, you should be able to
do something like this to create an output file suitable for your
graphics printer.

   Or, you can eliminate the intermediate file by using commands like
this

     set term postscript
     set output "|lpr -Pname_of_your_graphics_printer"
     replot


File: octave.info,  Node: Expressions,  Next: Statements,  Prev: Introduction,  Up: Top

Expressions
***********

   Expressions are the basic building block of statements in Octave.  An
expression evaluates to a value, which you can print, test, store in a
variable, pass to a function, or assign a new value to a variable with
an assignment operator.

   An expression can serve as a statement on its own.  Most other kinds
of statements contain one or more expressions which specify data to be
operated on.  As in other languages, expressions in Octave include
variables, array references, constants, and function calls, as well as
combinations of these with various operators.

* Menu:

* Constant Expressions::
* Matrices::
* Ranges::
* Variables::
* Index Expressions::
* Calling Functions::
* Global Variables::
* Keywords::
* Arithmetic Ops::
* Comparison Ops::
* Boolean Expressions::
* Assignment Ops::
* Increment Ops::
* Operator Precedence::


File: octave.info,  Node: Constant Expressions,  Next: Matrices,  Prev: Expressions,  Up: Expressions

Constant Expressions
====================

   The simplest type of expression is the "constant", which always has
the same value.  There are two types of constants: numeric constants and
string constants.

* Menu:

* Numeric Constants::
* String Constants::


File: octave.info,  Node: Numeric Constants,  Next: String Constants,  Prev: Constant Expressions,  Up: Constant Expressions

Numeric Constants
-----------------

   A "numeric constant" may be a scalar, a vector, or a matrix, and it
may contain complex values.

   The simplest form of a numeric constant, a scalar, is a single number
that can be an integer, a decimal fraction, a number in scientific
(exponential) notation, or a complex number.  Note that all numeric
values are represented within Octave in double-precision floating point
format (complex constants are stored as pairs of double-precision
floating point values).  Here are some examples of real-valued numeric
constants, which all have the same value:

     105
     1.05e+2
     1050e-1

   To specify complex constants, you can write an expression of the form

     3 + 4i
     3.0 + 4.0i
     0.3e1 + 40e-1i

   all of which are equivalent.  The letter `i' in the previous example
stands for the pure imaginary constant, defined as   `sqrt (-1)'.

   For Octave to recognize a value as the imaginary part of a complex
constant, a space must not appear between the number and the `i'.  If
it does, Octave will print an error message, like this:

     octave:13> 3 + 4 i
     
     parse error:
     
       3 + 4 i
             ^

   You may also use `j', `I', or `J' in place of the `i' above.  All
four forms are equivalent.


File: octave.info,  Node: String Constants,  Prev: Numeric Constants,  Up: Constant Expressions

String Constants
----------------

   A "string constant" consists of a sequence of characters enclosed in
either double-quote or single-quote marks.  For example, both of the
following expressions

     "parrot"
     'parrot'

represent the string whose contents are `parrot'.  Strings in Octave
can be of any length.

   Since the single-quote mark is also used for the transpose operator
(*note Arithmetic Ops::.) but double-quote marks have no other purpose
in Octave, it is best to use double-quote marks to denote strings.

   Some characters cannot be included literally in a string constant.
You represent them instead with "escape sequences", which are character
sequences beginning with a backslash (`\').

   One use of an escape sequence is to include a double-quote
(single-quote) character in a string constant that has been defined
using double-quote (single-quote) marks.  Since a plain double-quote
would end the string, you must use `\"' to represent a single
double-quote character as a part of the string.  The backslash character
itself is another character that cannot be included normally.  You must
write `\\' to put one backslash in the string.  Thus, the string whose
contents are the two characters `"\' must be written `"\"\\"'.

   Another use of backslash is to represent unprintable characters such
as newline.  While there is nothing to stop you from writing most of
these characters directly in a string constant, they may look ugly.

   Here is a table of all the escape sequences used in Octave:

`\\'
     Represents a literal backslash, `\'.

`\"'
     Represents a literal double-quote character, `"'.

`\''
     Represents a literal single-quote character, `''.

`\a'
     Represents the "alert" character, control-g, ASCII code 7.

`\b'
     Represents a backspace, control-h, ASCII code 8.

`\f'
     Represents a formfeed, control-l, ASCII code 12.

`\n'
     Represents a newline, control-j, ASCII code 10.

`\r'
     Represents a carriage return, control-m, ASCII code 13.

`\t'
     Represents a horizontal tab, control-i, ASCII code 9.

`\v'
     Represents a vertical tab, control-k, ASCII code 11.

   Strings may be concatenated using the notation for defining matrices.
For example, the expression

     [ "foo" , "bar" , "baz" ]

produces the string whose contents are `foobarbaz'


File: octave.info,  Node: Matrices,  Next: Ranges,  Prev: Constant Expressions,  Up: Expressions

Matrices
========

   It is easy to define a matrix of values in Octave.  The size of the
matrix is determined automatically, so it is not necessary to explicitly
state the dimensions.  The expression

     a = [1, 2; 3, 4]

results in the matrix

     a =
     
       1  2
       3  4

   The commas which separate the elements on a row may be omitted, and
the semicolon that marks the beginning of a new row may be replaced by
one or more new lines.  The expression

     a = [ 1 2
           3 4 ]

is equivalent to the one above.

   Elements of a matrix may be arbitrary expressions, provided that the
dimensions all agree.  For example, given the above matrix

   Inside the square brackets that delimit a matrix expression, Octave
looks at the surrounding context to determine whether spaces should be
converted into element separators, or simply ignored, so commands like

     [ linspace (1, 2) ]

will work.  However, some possible sources of confusion remain.  For
example, in the expression

     [ 1 - 1 ]

the `-' is treated as a binary operator and the result is the scalar 0,
but in the expression

     [ 1 -1 ]

the `-' is treated as a unary operator and the result is the vector `[
1 -1 ]'.

   Given `a = 1', the expression

     [ 1 a' ]

results in the single quote character `'' being treated as a transpose
operator and the result is the vector `[ 1 1 ]', but the expression

     [ 1 a ' ]

produces the error message

     error: unterminated string constant

because to not do so would make it impossible to correctly parse the
valid expression

     [ a 'foo' ]

   For clarity, it is probably best to always use commas and semicolons
to separate matrix elements and rows.

* Menu:

* Empty Matrices::


File: octave.info,  Node: Empty Matrices,  Prev: Matrices,  Up: Matrices

Empty Matrices
--------------

   A matrix may have one or both dimensions zero, and operations on
empty matrices are handled as described by Carl de Boor in `An Empty
Exercise', SIGNUM, Volume 25, pages 2-6, 1990 and C. N. Nett and W. M.
Haddad, in `A System-Theoretic Appropriate Realization of the Empty
Matrix Concept', IEEE Transactions on Automatic Control, Volume 38,
Number 5, May 1993.  Briefly, given a scalar `s', and an M by N matrix
`M(mxn)', and an M by N empty matrix `[](mxn)' (with either one or both
dimensions equal to zero), the following are true:

     s * [](mxn) = [](mxn) * s = [](mxn)
     
         [](mxn) + [](mxn) = [](mxn)
     
         [](0xm) * M(mxn) = [](0xn)
     
         M(mxn) * [](nx0) = [](mx0)
     
         [](mx0) + [](0xn) = 0(mxn)

   By default, dimensions of the empty matrix are now printed along
with the empty matrix symbol, `[]'.  For example:

     octave:13> zeros (3, 0)
     ans =
     
     [](3x0)

   The built-in variable `print_empty_dimensions' controls this
behavior (*note User Preferences::.).


File: octave.info,  Node: Ranges,  Next: Variables,  Prev: Matrices,  Up: Expressions

Ranges
======

   A "range" is a convenient way to write a row vector with evenly
spaced elements.  A range constant is defined by the value of the first
element in the range, a maximum value which the elements of the range
will not exceed, and an optional value for the increment between
elements.  The base, limit, and increment are separated by colons (the
`:' character) and may contain any arithmetic expressions and function
calls.  If the increment is omitted, it is assumed to be 1.  For
example,

     1 : 5

defines the set of values `[ 1 2 3 4 5 ]', and the range

     1 : 3 : 5

defines the set of values `[ 1 4 ]'.

   The increment is specified between the base and the limit in order to
be compatible with MATLAB(1).

   Note that the upper bound on the range is not always included in the
set of values, and that ranges defined by floating point values can
produce surprising results because Octave uses floating point
arithmetic to compute the values in the range.  If it is important to
include the endpoints of a range and the number of elements is known,
you should use the `linspace' function instead (*note Special
Matrices::.).

   ---------- Footnotes ----------

   (1)  MATLAB is a trademark of the MathWorks, Inc.


File: octave.info,  Node: Variables,  Next: Index Expressions,  Prev: Ranges,  Up: Expressions

Variables
=========

   Variables let you give names to values and refer to them later.  You
have already seen variables in many of the examples.  The name of a
variable must be a sequence of letters, digits and underscores, but it
may not begin with a digit.  Case is significant in variable names.
The symbols `a' and `A' are distinct variables.

   A variable name is a valid expression by itself.  It represents the
variable's current value.  Variables are given new values with
"assignment operators" and "increment operators".  *Note Assignment
Expressions: Assignment Ops.

   A number of variables have special built-in meanings, such as `PWD',
which holds the current working directory, and `pi', the ratio of the
circumference of a circle to its diameter.  *Note Built-in Variables::,
for a list of them.  Most of these built-in variables can be used and
assigned just like all other variables, but their values are also used
or changed automatically by Octave.

   Variables in Octave can be assigned either numeric or string values.
Variables may not be used before they have been given a value.  Doing so
results in an error.


File: octave.info,  Node: Index Expressions,  Next: Calling Functions,  Prev: Variables,  Up: Expressions

Index Expressions
=================

   An "index expression" allows you to reference or extract selected
elements of a matrix or vector.

   Indices may be scalars, vectors, ranges, or the special operator
`:', which may be used to select entire rows or columns.

   Vectors are indexed using a single expression.  Matrices require two
indices unless the value of the built-in variable `do_fortran_indexing'
is `true', in which case a matrix may also be indexed by a single
expression (*note User Preferences::.).

   Given the matrix

     a = [1, 2; 3, 4]

all of the following expressions are equivalent

     a (1, [1, 2])
     a (1, 1:2)
     a (1, :)

and select the first row of the matrix.

   A special form of indexing may be used to select elements of a
matrix or vector.  If the indices are vectors made up of only ones and
zeros, the result is a new matrix whose elements correspond to the
elements of the index vector that are equal to one.  For example,

     a = [1, 2; 3, 4];
     a ([1, 0], :)

selects the first row of the matrix `a'.

   This operation can be useful for selecting elements of a matrix
based on some condition, since the comparison operators return matrices
of ones and zeros.

   This special zero-one form of indexing leads to a conflict with the
standard indexing operation.  For example, do the following statements

     a = [1, 2; 3, 4];
     a ([1, 1], :)

return the original matrix, or the matrix formed by selecting the first
row twice?  Although this conflict is not likely to arise very often in
practice, you may select the behavior you prefer by setting the built-in
variable `prefer_zero_one_indexing' (*note User Preferences::.).

   Finally, indexing a scalar with a vector of ones can be used to
create a vector the same size as the the index vector, with each
element equal to the value of the original scalar.  For example, the
following statements

     a = 13;
     a ([1, 1, 1, 1])

produce a vector whose four elements are all equal to 13.

   Similarly, indexing a scalar with two vectors of ones can be used to
create a matrix.  For example the following statements

     a = 13;
     a ([1, 1], [1, 1, 1])

create a 2 by 3 matrix with all elements equal to 13.

   This form of indexing is rarely used.  The same effect can be
achieved using the `ones' function.  *Note Special Matrices::.


File: octave.info,  Node: Calling Functions,  Next: Global Variables,  Prev: Index Expressions,  Up: Expressions

Calling Functions
=================

   A "function" is a name for a particular calculation.  Because it has
a name, you can ask for it by name at any point in the program.  For
example, the function `sqrt' computes the square root of a number.

   A fixed set of functions are "built-in", which means they are
available in every Octave program.  The `sqrt' function is one of
these.  In addition, you can define your own functions in the program
for use elsewhere in the same program.  *Note Defining Functions::, for
how to do this.

   The way to use a function is with a "function call" expression,
which consists of the function name followed by a list of "arguments"
in parentheses. The arguments are expressions which give the raw
materials for the calculation that the function will do.  When there is
more than one argument, they are separated by commas.  If there are no
arguments, write just `()' after the function name (1).  Here are some
examples:

     sqrt (x^2 + y^2)      # One argument
     ones (n, m)           # Two arguments
     rand ()               # No arguments

   Each function expects a particular number of arguments.  For
example, the `sqrt' function must be called with a single argument, the
number to take the square root of:

     sqrt (ARGUMENT)

   Some of the built-in functions take a variable number of arguments,
depending on the particular usage, and their behavior is different
depending on the number of arguments supplied.

   Like every other expression, the function call has a value, which is
computed by the function based on the arguments you give it.  In this
example, the value of `sqrt (ARGUMENT)' is the square root of the
argument.  A function can also have side effects, such as assigning the
values of certain variables or doing input or output operations.

   Unlike most languages, functions in Octave may return multiple
values.  For example, the following statement

     [u, s, v] = svd (a)

computes the singular value decomposition of the matrix `a', and
assigns the result to `u', `s', and `v'.

   The left side of a multiple assignment expression is itself a list of
expressions, and is allowed to be a list of variable names or index
expressions.  See also *Note Index Expressions::, and *Note Assignment
Ops::.

   ---------- Footnotes ----------

   (1)  You can omit the parenthesis for functions that do not require
any arguments, but it is a good idea to include them anyway, to clearly
indicate that a function call was intended.


File: octave.info,  Node: Global Variables,  Next: Keywords,  Prev: Calling Functions,  Up: Expressions

Global Variables
================

   A variable that has been declared "global" may be accessed from
within a function body without having to pass it as a formal parameter.

   A variable may be declared "global" using a `global' declaration
statement.  The following statements are all global declarations.

     global a
     global b = 2
     global c = 3, d, e = 5

   It is necessary declare a variable as global within a function body
in order to access it.  For example,

     global x
     function f ()
     x = 1;
     endfunction
     f ()

does *not* set the value of the global variable `x' to 1.  In order to
change the value of the global variable `x', you must also declare it
to be global within the function body, like this

     function f ()
       global x;
       x = 1;
     endfunction

   Passing a global variable in a function parameter list will make a
local copy and not modify the global value.  For example:

     octave:1> function f (x)
     > x = 3
     > endfunction
     octave:2> global x = 0
     octave:3> x              # This is the value of the global variable.
     x = 0
     octave:4> f (x)
     x = 3                    # The value of the local variable x is 3.
     octave:5> x              # But it was a *copy* so the global variable
     x = 0                    # remains unchanged.


File: octave.info,  Node: Keywords,  Next: Arithmetic Ops,  Prev: Global Variables,  Up: Expressions

Keywords
========

   The following identifiers are keywords, and may not be used as
variable or function names:

     break       endfor         function    return
     continue    endfunction    global      while
     else        endif          gplot
     elseif      endwhile       gsplot
     end         for            if

   The following text-style functions are also keywords, and may not be
used as variable or function names:

     casesen   document       history       set
     cd        edit_history   load          show
     clear     help           ls            who
     dir       format         run_history   save


File: octave.info,  Node: Arithmetic Ops,  Next: Comparison Ops,  Prev: Keywords,  Up: Expressions

Arithmetic Operators
====================

   The following arithmetic operators are available, and work on scalars
and matrices.

`X + Y'
     Addition.  If both operands are matrices, the number of rows and
     columns must both agree.  If one operand is a scalar, its value is
     added to all the elements of the other operand.

`X .+ Y'
     Element by element addition.  This operator is equivalent to `+'.

`X - Y'
     Subtraction.  If both operands are matrices, the number of rows and
     columns of both must agree.

`X .- Y'
     Element by element subtraction.  This operator is equivalent to
     `-'.

`X * Y'
     Matrix multiplication.  The number of columns of `x' must agree
     with the number of rows of `y'.

`X .* Y'
     Element by element multiplication.  If both operands are matrices,
     the number of rows and columns must both agree.

`X / Y'
     Right division.  This is conceptually equivalent to the expression

          (inverse (y') * x')'

     but it is computed without computing the inverse of `y''.

     If the system is not square, or if the coefficient matrix is
     singular, a minimum norm solution is computed.

`X ./ Y'
     Element by element right division.

`X \ Y'
     Left division.  This is conceptually equivalent to the expression

          inverse (x) * y

     but it is computed without computing the inverse of.

     If the system is not square, or if the coefficient matrix is
     singular, a minimum norm solution is computed.

`X .\ Y'
     Element by element left division.  Each element of `y' is divided
     by each corresponding element of `x'.

`X ^ Y'
`X ** Y'
     Power operator.  If X and Y are both scalars, this operator
     returns X raised to the power Y.  If X is a scalar and Y is a
     square matrix, the result is computed using an eigenvalue
     expansion.  If X is a square matrix. the result is computed by
     repeated multiplication if Y is an integer, and by an eigenvalue
     expansion if Y is not an integer.  An error results if both X and
     Y are matrices.

     The implementation of this operator needs to be improved.

`X .^ Y'
`X .** Y'
     Element by element power operator.  If both operands are matrices,
     the number of rows and columns must both agree.

`-X'
     Negation.

`+X'
     Unary plus.  This operator has no effect on the operand.

`X''
     Complex conjugate transpose.  For real arguments, this operator is
     the same as the transpose operator.  For complex arguments, this
     operator is equivalent to the expression

          conj (x.')

`X.''
     Transpose.


File: octave.info,  Node: Comparison Ops,  Next: Boolean Expressions,  Prev: Arithmetic Ops,  Up: Expressions

Comparison Operators
====================

   "Comparison operators" compare numeric values for relationships such
as equality.  They are written using *relational operators*, which are
a superset of those in C.

   For matrix values, they all work on an element by element basis.  For
example, evaluating the expression

     [1, 2; 3, 4] == [1, 3; 2, 4]

returns the result

     ans =
     
       1  0
       0  1

`X < Y'
     True if X is less than Y.

`X <= Y'
     True if X is less than or equal to Y.

`X == Y'
     True if X is equal to Y.

`X >= Y'
     True if X is greater than or equal to Y.

`X > Y'
     True if X is greater than Y.

`X != Y'
`X ~= Y'
`X <> Y'
     True if X is not equal to Y.

   String comparisons should be performed with the `strcmp' function,
not with the comparison operators listed above.  *Note Calling
Functions::.


File: octave.info,  Node: Boolean Expressions,  Next: Assignment Ops,  Prev: Comparison Ops,  Up: Expressions

Boolean Expressions
===================

   A "boolean expression" is a combination of comparison expressions or
matching expressions, using the boolean operators "or" (`||'), "and"
(`&&'), and "not" (`!'), along with parentheses to control nesting.
The truth of the boolean expression is computed by combining the truth
values of the component expressions.

   Boolean expressions can be used wherever comparison and matching
expressions can be used.  They can be used in `if' and `while'
statements.  They have numeric values (1 if true, 0 if false), which
come into play if the result of the boolean expression is stored in a
variable, or used in arithmetic.

   In addition, every boolean expression is also a valid boolean
pattern, so you can use it as a pattern to control the execution of
rules.

   Here are descriptions of the three boolean operators, with an
example of each.  It may be instructive to compare these examples with
the analogous examples of boolean patterns (*note Boolean
Expressions::.), which use the same boolean operators in patterns
instead of expressions.

`BOOLEAN1 & BOOLEAN2'
`BOOLEAN1 && BOOLEAN2'
     True if both BOOLEAN1 and BOOLEAN2 are true.

`BOOLEAN1 | BOOLEAN2'
`BOOLEAN1 || BOOLEAN2'
     True if at least one of BOOLEAN1 or BOOLEAN2 is true.

     Both subexpressions BOOLEAN1 and BOOLEAN2 are evaluated before
     computing the result.  This can make a difference when the
     expressions have side effects.

`! BOOLEAN'
`~ BOOLEAN'
     True if BOOLEAN is false.

   For matrix operands, the boolean operators work on an element by
element basis.  For example, the expression

     [1, 2; 3, 4] && [1, 3; 2, 4]

returns a two by two identity matrix.

   For the binary boolean operators, both subexpressions BOOLEAN1 and
BOOLEAN2 are evaluated before computing the result.  This can make a
difference when the expressions have side effects.  For example, in the
expression

     a && b++

the value of the variable B is incremented even if A zero.

   This behavior is necessary for the boolean operators to work as
described for matrix-valued operands.


File: octave.info,  Node: Assignment Ops,  Next: Increment Ops,  Prev: Boolean Expressions,  Up: Expressions

Assignment Expressions
======================

   An "assignment" is an expression that stores a new value into a
variable.  For example, let's assign the value 1 to the variable `z':

     z = 1

   After this expression is executed, the variable `z' has the value 1.
Whatever old value `z' had before the assignment is forgotten.

   Assignments can store string values also.  For example, this would
store the value `"this food is good"' in the variable `message':

     thing = "food"
     predicate = "good"
     message = [ "this " , thing , " is " , predicate ]

(This also illustrates concatenation of strings.)

   The `=' sign is called an "assignment operator".  It is the simplest
assignment operator because the value of the right-hand operand is
stored unchanged.

   Most operators (addition, concatenation, and so on) have no effect
except to compute a value.  If you ignore the value, you might as well
not use the operator.  An assignment operator is different.  It does
produce a value, but even if you ignore the value, the assignment still
makes itself felt through the alteration of the variable.  We call this
a "side effect".

   The left-hand operand of an assignment need not be a variable (*note
Variables::.).  It can also be an element of a matrix (*note Index
Expressions::.) or a list of return values (*note Calling
Functions::.).  These are all called "lvalues", which means they can
appear on the left-hand side of an assignment operator.  The right-hand
operand may be any expression.  It produces the new value which the
assignment stores in the specified variable, matrix element, or list of
return values.

   It is important to note that variables do *not* have permanent types.
The type of a variable is simply the type of whatever value it happens
to hold at the moment.  In the following program fragment, the variable
`foo' has a numeric value at first, and a string value later on:

     octave:13> foo = 1
     foo = 1
     octave:13> foo = "bar"
     foo = bar

When the second assignment gives `foo' a string value, the fact that it
previously had a numeric value is forgotten.

   An assignment is an expression, so it has a value: the same value
that is assigned.  Thus, `z = 1' as an expression has the value 1.  One
consequence of this is that you can write multiple assignments together:

     x = y = z = 0

stores the value 0 in all three variables.  It does this because the
value of `z = 0', which is 0, is stored into `y', and then the value of
`y = z = 0', which is 0, is stored into `x'.

   This is also true of assignments to lists of values, so the
following is a valid expression

     [a, b, c] = [u, s, v] = svd (a)

that is exactly equivalent to

     [u, s, v] = svd (a)
     a = u
     b = s
     c = v

   In expressions like this, the number of values in each part of the
expression need not match.  Extra values on the the right or left of the
`=' sign are ignored.  For example, the expression

     [a, b, c, d] = [u, s, v] = svd (a)

is equivalent to the expression above, except that the value of the
variable `d' is left unchanged, and the expression

     [a, b] = [u, s, v] = svd (a)

is equivalent to

     [u, s, v] = svd (a)
     a = u
     b = s

   You can use an assignment anywhere an expression is called for.  For
example, it is valid to write `x != (y = 1)' to set `y' to 1 and then
test whether `x' equals 1.  But this style tends to make programs hard
to read.  Except in a one-shot program, you should rewrite it to get
rid of such nesting of assignments.  This is never very hard.


File: octave.info,  Node: Increment Ops,  Next: Operator Precedence,  Prev: Assignment Ops,  Up: Expressions

Increment Operators
===================

   *Increment operators* increase or decrease the value of a variable
by 1.

   The operator to increment a variable is written as `++'.  It may be
used to increment a variable either before or after taking its value.

   For example, to pre-increment the variable X, you would write `++X'.
This would add one to X and then return the new value of X as the
result of the expression.  It is exactly the same as the expression `X
= X + 1'.

   To post-increment a variable X, you would write `X++'.  This adds
one to the variable X, but returns the value that X had prior to
incrementing it.  For example, if X is equal to 2, the result of the
expression `X++' is 2, and the new value of X is 3.

   Here is a list of all the increment and decrement expressions.

`++X'
     This expression increments the variable X.  The value of the
     expression is the *new* value of X.  It is equivalent to the
     expression `X = X + 1'.

`--X'
     This expression decrements the variable X.  The value of the
     expression is the *new* value of X.  It is equivalent to the
     expression `X = X - 1'.

`X++'
     This expression causes the variable X to be incremented.  The
     value of the expression is the *old* value of X.

`X--'
     This expression causes the variable X to be decremented.  The
     value of the expression is the *old* value of X.


File: octave.info,  Node: Operator Precedence,  Prev: Increment Ops,  Up: Expressions

Operator Precedence
===================

   "Operator precedence" determines how operators are grouped, when
different operators appear close by in one expression.  For example,
`*' has higher precedence than `+'.  Thus, the expression `a + b * c'
means to multiply `b' and `c', and then add `a' to the product (i.e.,
`a + (b * c)').

   You can overrule the precedence of the operators by using
parentheses.  You can think of the precedence rules as saying where the
parentheses are assumed if you do not write parentheses yourself.  In
fact, it is wise to always use parentheses whenever you have an unusual
combination of operators, because other people who read the program may
not remember what the precedence is in this case.  You might forget as
well, and then you too could make a mistake.  Explicit parentheses will
help prevent any such mistake.

   When operators of equal precedence are used together, the leftmost
operator groups first, except for the assignment, and exponentiation
operators, which group in the opposite order.  Thus, the expression `a
- b + c' groups as `(a - b) + c', but the expression `a = b = c' groups
as `a = (b = c)'.

   The precedence of prefix unary operators is important when another
operator follows the operand.  For example, `-x^2' means `-(x^2)',
because `-' has lower precedence than `^'.

   Here is a table of the operators in `octave', in order of increasing
precedence.

`statement separators'
     `;', `,'.

`assignment'
     `='.  This operator groups right to left.

`logical ``or'' and ``and'''
     `|', `||', `&', `&&'.

`relational'
     `<', `<=', `==', `>=', `>', `!=', `~=', `<>'.

`colon'
     `:'.

`add, subtract'
     `+', `-'.

`multiply, divide'
     `*', `/', `\', `.\', `.*', `./'.

`transpose'
     `'', `.''

`unary plus, minus, increment, decrement, and ``not'''
     `+', `-', `++', `--', `!', `~'.

`exponentiation'
     `^', `**', `.^', `.**'.


File: octave.info,  Node: Statements,  Next: Built-in Variables,  Prev: Expressions,  Up: Top

Statements
**********

* Menu:

* Statement Lists::
* Declaration Statements::
* Selection Statements::
* Iteration Statements::
* Defining Functions::
* Jump Statements::


File: octave.info,  Node: Statement Lists,  Next: Declaration Statements,  Prev: Statements,  Up: Statements

Statement Lists
===============

   A statement list is formed from a set of statements, separated by
commas, semicolons, or, in some contexts, newline characters.


File: octave.info,  Node: Declaration Statements,  Next: Selection Statements,  Prev: Statement Lists,  Up: Statements

Declaration Statements
======================

DECLARATION-STMT:
     global GLOBAL-DECL-LIST

GLOBAL-DECL-LIST:
     IDENTIFIER
     IDENTIFIER = EXPR
     GLOBAL-DECL-LIST IDENTIFIER
     GLOBAL-DECL-LIST IDENTIFIER = EXPR
     GLOBAL-DECL-LIST , IDENTIFIER
     GLOBAL-DECL-LIST , IDENTIFIER = EXPR


File: octave.info,  Node: Selection Statements,  Next: Iteration Statements,  Prev: Declaration Statements,  Up: Statements

Selection Statements
====================

   A selection statement executes one of several possible lists of
statements.

SELECTION-STATEMENT:
     if EXPR STMT-LIST ELSEIF-CLAUSE ELSE-CLAUSE endif

where the ELSEIF-CLAUSE and the ELSE-CLAUSE may be omitted.

ELSE-CLAUSE:
     else STMT-LIST

ELSEIF-CLAUSE:
     elseif EXPR STMT-LIST
     ELSEIF-CLAUSE elseif EXPR STMT-LIST

   Although it is not required, it is a good idea to surround the test
expression in parentheses to make the meaning clear.


File: octave.info,  Node: Iteration Statements,  Next: Defining Functions,  Prev: Selection Statements,  Up: Statements

Iteration Statements
====================

   An iteration statements specifies looping.

ITERATION-STMT:
     while EXPR STMT-LIST endwhile
     for IDENTIFIER = EXPR STMT-LIST endfor


File: octave.info,  Node: Defining Functions,  Next: Jump Statements,  Prev: Iteration Statements,  Up: Statements

Defining Functions
==================

   The `function' statement allows you to define your own functions.
The syntax of the `function' statement is:

FUNCTION:
     function RET-LIST IDENTIFIER ARG-LIST STMT-LIST endfunction

where the RET-LIST and ARG-LIST may be omitted.

RET-LIST:
     IDENTIFIER =
     [ IDENTIFIER-LIST ] =

ARG-LIST:
     ( )
     ( IDENTIFIER-LIST )

IDENTIFIER-LIST:
     IDENTIFIER
     IDENTIFIER-LIST IDENTIFIER


File: octave.info,  Node: Jump Statements,  Prev: Defining Functions,  Up: Statements

Jump Statements
===============

   A jump statement transfers control unconditionally.

   The `break' statement terminates execution of the innermost
enclosing loop statement.

   The `continue' statement transfers control to the end of the
innermost enclosing loop statement.  The condition controlling the
execution of loop is then tested again, and if it is not equal to zero,
the loop body is executed again.

JUMP-STMT:
     break
     continue
     return

   The `break' and `continue' statements may only be used within the
body of a loop, and the `return' statement may only be used within a
function body.


File: octave.info,  Node: Built-in Variables,  Next: Arithmetic,  Prev: Statements,  Up: Top

Built-in Variables
******************

   Octave provides a number of predefined variables.  Some, like the
constants `pi' and `Inf' are available to make programming easier.
Others, like `do_fortran_indexing' and `page_screen_output' change
Octave's behavior.

* Menu:

* Predefined Constants::
* User Preferences::
* Other Built-in Variables::

