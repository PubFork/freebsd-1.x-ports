This is Info file octave.info, produced by Makeinfo-1.52 from the input
file octave.texi.

   Copyright (C) 1993 John W. Eaton.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: octave.info,  Node: Rearranging Matrices,  Prev: Finding Elements and Checking Conditions,  Up: Matrix Manipulation

Rearranging Matrices
====================

   The function `fliplr' reverses the order of the columns in a matrix,
and `flipud' reverses the order of the rows.  For example,

     octave:13> fliplr ([1, 2; 3, 4])
     ans =
     
       2  1
       4  3
     
     octave:13> flipud ([1, 2; 3, 4])
     ans =
     
       3  4
       1  2

   The function `rot90 (A, N)' rotates a matrix counterclockwise in
90-degree increments.  The second argument is optional, and specifies
how many 90-degree rotations are to be applied (the default value is
1).  Negative values of N rotate the matrix in a clockwise direction.
For example,

     rot90 ([1, 2; 3, 4], -1)
     ans =
     
       3  1
       4  2

rotates the given matrix clockwise by 90 degrees.  The following are all
equivalent statements:

     rot90 ([1, 2; 3, 4], -1)
     rot90 ([1, 2; 3, 4], 3)
     rot90 ([1, 2; 3, 4], 7)

   The function `reshape (A, M, N)' returns a matrix with M rows and N
columns whose elements are taken from the matrix A.  To decide how to
order the elements, Octave pretends that the elements of a matrix are
stored in column-major order (like Fortran arrays are stored).

   For example,

     octave:13> reshape ([1, 2, 3, 4], 2, 2)
     ans =
     
       1  3
       2  4

   If the variable `do_fortran_indexing' is `"true"', the `reshape'
function is equivalent to

     retval = zeros (m, n);
     retval (:) = a;

but it is somewhat less cryptic to use `reshape' instead of the colon
operator.  Note that the total number of elements in the original
matrix must match the total number of elements in the new matrix.

   The function `sort' can be used to arrange the elements of a vector
in increasing order.  For matrices, `sort' orders the elements in each
column.

   For example,

     octave:63> sort (rand (4))
     ans =
     
       0.065359  0.039391  0.376076  0.384298
       0.111486  0.140872  0.418035  0.824459
       0.269991  0.274446  0.421374  0.938918
       0.580030  0.975784  0.562145  0.954964

   Unfortunately, `sort' does not allow sort keys to be specified, so
it can't be used to order the rows of a matrix according to the values
of the elements in a specific column.  Perhaps someday someone will add
this feature.

   The functions `triu (A, K)' and `tril (A, K)' extract the upper or
lower triangular part of the matrix A, and set all other elements to
zero.  The second argument is optional, and specifies how many
diagonals above or below the main diagonal should also be set to zero.

   The default value of K is zero, so that `triu' and `tril' normally
include the main diagonal as part of the result matrix.

   If the value of K is negative, additional elements above (for
`tril') or below (for `triu') the main diagonal are also selected.

   The absolute value of K must not be greater than the number of sub-
or super-diagonals.

   For example,
     octave:13> tril (rand (4), 1)
     ans =
     
       0.00000  0.00000  0.00000  0.00000
       0.09012  0.00000  0.00000  0.00000
       0.01215  0.34768  0.00000  0.00000
       0.00302  0.69518  0.91940  0.00000

forms a lower triangular matrix from a random 4 by 4 matrix, omitting
the main diagonal, and

     octave:13> tril (rand (4), -1)
     ans =
     
       0.06170  0.51396  0.00000  0.00000
       0.96199  0.11986  0.35714  0.00000
       0.16185  0.61442  0.79343  0.52029
       0.68016  0.48835  0.63609  0.72113

forms a lower triangular matrix from a random 4 by 4 matrix, including
the main diagonal and the first super-diagonal.


File: octave.info,  Node: String Functions,  Next: System Utilities,  Prev: Matrix Manipulation,  Up: Top

String Functions
****************

   Octave currently has a limited ability to work with strings.  There
are plans to improve this, but there are many other more important
things to be done first.

   The function `strcmp (S1, S2)' compares two strings, returning 1 if
they are the same, and 0 otherwise.

   *Note: For compatibility with MATLAB, Octave's strcmp function
returns 1 if the strings are equal, and 0 otherwise.  This is just the
opposite of the corresponding C library function.*

   The functions `int2str' and `num2str' convert a numeric argument to
a string.  These functions are not very flexible, but are provided for
compatibility with MATLAB.  For better control over the results, use
`sprintf' (*note Formatted Output::.).

   The function `setstr' can be used to convert a vector to a string.
Each element of the vector is converted to the corresponding ASCII
character.  For example,

     setstr ([97, 98, 99])

creates the string

     abc


File: octave.info,  Node: System Utilities,  Next: Command History Functions,  Prev: String Functions,  Up: Top

System Utilities
****************

   The function `clock' returns a vector containing the current year,
month (1-12), day (1-31), hour (0-23), minute (0-59) and second (0-60).
For example,

     octave:13> clock
     ans =
     
       1993     8    20     4    56     1

   To get the date as a character string in the form DD-MMM-YY, use the
command `date'.  For example,

     octave:13> date
     ans = 20-Aug-93

   You can execute any shell command using the function `shell_cmd
(CMD, FLAG)'.  The second argument is optional.  If it is present, the
output of the command is returned by `shell_cmd' as a string.  If it is
not supplied, any output from the command is printed, with the standard
output filtered through the pager.  For example,

     users = shell_cmd ("finger", 1)

places the output of the command `finger' in the variable `users'.

   You can find the values of environment variables using the function
`getenv'.  For example,

     getenv ("PATH")

returns a string containing the value of your path.

   The functions `clc', and `home' clear your terminal screen and move
the cursor to the upper left corner.

   You can change the current working directory using the `cd' command.
Tilde expansion is performed on the path.  For example,

     cd ~/octave

Changes the current working directory to `~/octave'.  If the directory
does not exist, an error message is printed and the working directory
is not changed.

   The command `pwd' prints the current working directory.

   The functions `dir' and `ls' list directory contents.  For example,

     octave:13> ls -l
     total 12
     -rw-r--r--   1 jwe      users        4488 Aug 19 04:02 foo.m
     -rw-r--r--   1 jwe      users        1315 Aug 17 23:14 bar.m

   The `dir' and `ls' commands are implemented by calling your system's
directory listing command, so the available options may vary from
system to system.

   If possible, `computer' prints a string of the form CPU-VENDOR-OS
that identifies the kind of computer Octave is running on.  For example,

     octave:13> computer
     sparc-sun-sunos4.1.2

   The function `pause' allows you to suspend the execution of a
program.  If invoked without any arguments, Octave waits until you type
a character.  With a numeric argument, it pauses for the given number of
seconds.  For example, the following statement prints a message and then
waits 5 seconds before clearing the screen.

     fprintf (stderr, "wait please...\n"), pause (5), clc


File: octave.info,  Node: Command History Functions,  Next: Help,  Prev: System Utilities,  Up: Top

Command History Functions
*************************

   Octave provides three functions for viewing, editing, and re-running
chunks of commands from the history list.

   The function `history' displays a list of commands that you have
executed.  It also allows you to write the current history to a file for
safe keeping, and to replace the history list with the commands stored
in a named file.  Valid arguments are:

`-w file'
     Write the current history to the named file.  If the name is
     omitted, use the default history file (normally `~/.octave_hist').

`-r file'
     Read the named file, replacing the current history list with its
     contents.  If the name is omitted, use the default history file
     (normally `~/.octave_hist').

`N'
     Only display the most recent `N' lines of history.

`-q'
     Don't number the displayed lines of history.  This is useful for
     cutting and pasting commands if you are using the X Window System.

   For example, to display the five most recent commands that you have
typed without displaying line numbers, use the command `history -q 5'.

   The function `edit_history' allows you to edit a block of commands
from the history list using the editor named by the environment
variable `EDITOR', or the default editor (normally `vi'.  It is often
more convenient to use `edit_history' to define functions rather than
attempting to enter them directly on the command line.  By default, the
block of commands is executed as soon as you exit the editor.  To avoid
executing any commands, simply delete all the lines from the buffer
before exiting the editor.

   The `edit_history' command takes two optional arguments specifying
the history numbers of first and last commands to edit.  For example,
the command

     edit_history 13

extracts all the commands from the 13th through the last in the history
list.  The command

     edit_history 13 169

only extracts commands 13 through 169.  Specifying a larger number for
the first command than the last command reverses the list of commands
before placing them in the buffer to be edited.  If both arguments are
omitted, the previous command in the history list is used.

   The command `run_history' is like `edit_history', except that the
editor is not invoked, and the commands are simply executed as they
appear in the history list.


File: octave.info,  Node: Help,  Next: Programming Utilities,  Prev: Command History Functions,  Up: Top

Help
****

   Octave's `help' command can be used to print brief usage-style
messages, or to display information directly from an on-line version of
the printed manual, using the GNU Info browser.  If invoked without any
arguments, `help' prints a list of all the available operators,
functions, and built-in variables.  If the first argument is `-i', the
`help' command searches the index of the on-line version of this manual
for the given topics.

   For example, the command

     help help

prints a short message describing the `help' command, and

     help -i help

starts the GNU Info browser at this node in the on-line version of the
manual.

   The remainder of this chapter describes how to use the GNU Info
browser.

* Menu:

* Using Info::
* Cursor Commands::
* Scrolling Commands::
* Node Commands::
* Searching Commands::
* Xref Commands::
* Window Commands::
* Printing Nodes::
* Other Info Commands::
* Info Variables::


File: octave.info,  Node: Using Info,  Next: Cursor Commands,  Prev: Help,  Up: Help

Using Info
==========

   "Info" is a program which is used to view info files on an ASCII
terminal. "info files" are the result of processing texinfo files with
the program `makeinfo' or with  the Emacs command `M-x
texinfo-format-buffer'.  Finally, "texinfo" is a documentation language
which allows a printed manual and online documentation (an info file)
to be produced from a single source file.

* Menu:

* Cursor Commands::	    Commands which move the cursor within a node.
* Scrolling Commands::	    Commands for moving the node around in a window.
* Node Commands::	    Commands for selecting a new node.
* Searching Commands::	    Commands for searching an info file.
* Xref Commands::	    Commands for selecting cross references.
* Window Commands::	    Commands which manipulate multiple windows.
* Printing Nodes::	    How to print out the contents of a node.
* Other Info Commands::     A few commands that defy categories.
* Info Variables::	    How to change the default behaviour of Info.


File: octave.info,  Node: Cursor Commands,  Next: Scrolling Commands,  Prev: Using Info,  Up: Help

Moving the Cursor
=================

   Many people find that reading screens of text page by page is made
easier when one is able to indicate particular pieces of text with some
kind of pointing device.  Since this is the case, GNU Info (both the
Emacs and standalone versions) have several commands which allow you to
move the cursor about the screen.  The notation used in this manual to
describe keystrokes is identical to the notation used within the Emacs
manual, and the GNU Readline manual.  *Note Character Conventions:
(emacs)Characters, if you are unfamiliar with the notation.

   The following table lists the basic cursor movement commands in Info.
Each entry consists of the key sequence you should type to execute the
cursor movement, the `M-x'(1) command name (displayed in parentheses),
and a short description of what the command does.  All of the cursor
motion commands can take an "numeric" argument (*note
`universal-argument': Other Info Commands.), to find out how to supply
them.  With a numeric argument, the motion commands are simply executed
that many times; for example, a numeric argument of 4 given to
`next-line' causes the cursor to move down 4 lines.  With a negative
numeric argument, the motion is reversed; an argument of -4 given to the
`next-line' command would cause the cursor to move *up* 4 lines.

`C-n' (`next-line')
     Moves the cursor down to the next line.

`C-p' (`prev-line')
     Move the cursor up to the previous line.

`C-a' (`beginning-of-line')
     Move the cursor to the start of the current line.

`C-e' (`end-of-line')
     Moves the cursor to the end of the current line.

`C-f' (`forward-char')
     Move the cursor forward a character.

`C-b' (`backward-char')
     Move the cursor backward a character.

`M-f' (`forward-word')
     Moves the cursor forward a word.

`M-b' (`backward-word')
     Moves the cursor backward a word.

`M-<' (`beginning-of-node')
`b'
     Moves the cursor to the start of the current node.

`M->' (`end-of-node')
     Moves the cursor to the end of the current node.

`M-r' (`move-to-window-line')
     Moves the cursor to a specific line of the window.  Without a
     numeric argument, `M-r' moves the cursor to the start of the line
     in the center of the window.  With a numeric argument of N, `M-r'
     moves the cursor to the start of the Nth line in the window.

   ---------- Footnotes ----------

   (1)  `M-x' is also a command; it invokes `execute-extended-command'.
*Note Executing an extended command: (emacs)M-x, for more detailed
information.


File: octave.info,  Node: Scrolling Commands,  Next: Node Commands,  Prev: Cursor Commands,  Up: Help

Moving Text Within a Window
===========================

   Sometimes you are looking at a screenful of text, and only part of
the current paragraph you are reading is visible on the screen.  The
commands detailed in this section are used to shift which part of the
current node is visible on the screen.

`SPC' (`scroll-forward')
`C-v'
     Shift the text in this window up.  That is, show more of the node
     which is currently below the bottom of the window.  With a numeric
     argument, show that many more lines at the bottom of the window; a
     numeric argument of 4 would shift all of the text in the window up
     4 lines (discarding the top 4 lines), and show you four new lines
     at the bottom of the window.  Without a numeric argument, SPC
     takes the bottom two lines of the window and places them at the
     top of the window, redisplaying almost a completely new screenful
     of lines.

`DEL' (`scroll-backward')
`M-v'
     Shift the text in this window down.  The inverse of
     `scroll-forward'.

   The `scroll-forward' and `scroll-backward' commands can also move
forward and backward through the node structure of the file.  If you
press SPC while viewing the end of a node, or DEL while viewing the
beginning of a node, what happens is controlled by the variable
`scroll-behaviour'.  *Note `scroll-behaviour': Info Variables, for more
information.

`C-l' (`redraw-display')
     Redraw the display from scratch, or shift the line containing the
     cursor to a specified location.  With no numeric argument, `C-l'
     clears the screen, and then redraws its entire contents.  Given a
     numeric argument of N, the line containing the cursor is shifted
     so that it is on the Nth line of the window.

`C-x w' (`toggle-wrap')
     Toggles the state of line wrapping in the current window.
     Normally, lines which are longer than the screen width "wrap",
     i.e., they are continued on the next line.  Lines which wrap have
     a `\' appearing in the rightmost column of the screen.  You can
     cause such lines to be terminated at the rightmost column by
     changing the state of line wrapping in the window with `C-x w'.
     When a line which needs more space than one screen width to
     display is displayed, a `$' appears in the rightmost column of the
     screen, and the remainder of the line is invisible.


File: octave.info,  Node: Node Commands,  Next: Searching Commands,  Prev: Scrolling Commands,  Up: Help

Selecting a New Node
====================

   This section details the numerous Info commands which select a new
node to view in the current window.

   The most basic node commands are `n', `p', `u', and `l'.

   When you are viewing a node, the top line of the node contains some
Info "pointers" which describe where the next, previous, and up nodes
are.  Info uses this line to move about the node structure of the file
when you use the following commands:

`n' (`next-node')
     Selects the `Next' node.

`p' (`prev-node')
     Selects the `Prev' node.

`u' (`up-node')
     Selects the `Up' node.

   You can easily select a node that you have already viewed in this
window by using the `l' command - this name stands for "last", and
actually moves through the list of already visited nodes for this
window.  `l' with a negative numeric argument moves forward through the
history of nodes for this window, so you can quickly step between two
adjacent (in viewing history) nodes.

`l' (`history-node')
     Selects the most recently selected node in this window.

   Two additional commands make it easy to select the most commonly
selected nodes; they are `t' and `d'.

`t' (`top-node')
     Selects the node `Top' in the current info file.

`d' (`dir-node')
     Selects the directory node (i.e., the node `(dir)').

   Here are some other commands which immediately result in the
selection of a different node in the current window:

`<' (`first-node')
     Selects the first node which appears in this file.  This node is
     most often `Top', but it doesn't have to be.

`>' (`last-node')
     Selects the last node which appears in this file.

`]' (`global-next-node')
     Moves forward or down through node structure.  If the node that
     you are currently viewing has a `Next' pointer, that node is
     selected.  Otherwise, if this node has a menu, the first menu item
     is selected.  If there is no `Next' and no menu, the same process
     is tried with the `Up' node of this node.

`[' (`global-prev-node')
     Moves backward or up through node structure.  If the node that you
     are currently viewing has a `Prev' pointer, that node is selected.
     Otherwise, if the node has an `Up' pointer, that node is selected,
     and if it has a menu, the last item in the menu is selected.

   You can get the same behaviour as `global-next-node' and
`global-prev-node' while simply scrolling through the file with SPC and
DEL; *Note `scroll-behaviour': Info Variables, for more information.

`g' (`goto-node')
     Reads the name of a node and selects it.  No completion is done
     while reading the node name, since the desired node may reside in
     a separate file.  The node must be typed exactly as it appears in
     the info file.  A file name may be included as with any node
     specification, for example

          `g(emacs)Buffers'

     finds the node `Buffers' in the info file `emacs'.

`C-x k' (`kill-node')
     Kills a node.  The node name is prompted for in the echo area,
     with a default of the current node.  "Killing" a node means that
     Info tries hard to forget about it, removing it from the list of
     history nodes kept for the window where that node is found.
     Another node is selected in the window which contained the killed
     node.

`C-x C-f' (`view-file')
     Reads the name of a file and selects the entire file.  The command
          `C-x C-f FILENAME'
     is equivalent to typing
          `g(FILENAME)*'

`C-x C-b' (`list-visited-nodes')
     Makes a window containing a menu of all of the currently visited
     nodes.  This window becomes the selected window, and you may use
     the standard Info commands within it.

`C-x b' (`select-visited-node')
     Selects a node which has been previously visited in a visible
     window.  This is similar to `C-x C-b' followed by `m', but no
     window is created.


File: octave.info,  Node: Searching Commands,  Next: Xref Commands,  Prev: Node Commands,  Up: Help

Searching an Info File
======================

   GNU Info allows you to search for a sequence of characters
throughout an entire info file, search through the indices of an info
file, or find areas within an info file which discuss a particular
topic.

`s' (`search')
     Reads a string in the echo area and searches for it.

`C-s' (`isearch-forward')
     Interactively searches forward through the info file for a string
     as you type it.

`C-r' (`isearch-backward')
     Interactively searches backward through the info file for a string
     as you type it.

`i' (`index-search')
     Looks up a string in the indices for this info file, and selects a
     node where the found index entry points to.

`,' (`next-index-match')
     Moves to the node containing the next matching index item from the
     last `i' command.

   The most basic searching command is `s' (`search').  The `s' command
prompts you for a string in the echo area, and then searches the
remainder of the info file for an occurrence of that string.  If the
string is found, the node containing it is selected, and the cursor is
left positioned at the start of the found string.  Subsequent `s'
commands show you the default search string within `[' and `]';
pressing RET instead of typing a new string will use the default search
string.

   "Incremental searching" is similar to basic searching, but the
string is looked up while you are typing it, instead of waiting until
the entire search string has been specified.


File: octave.info,  Node: Xref Commands,  Next: Window Commands,  Prev: Searching Commands,  Up: Help

Selecting Cross References
==========================

   We have already discussed the `Next', `Prev', and `Up' pointers
which appear at the top of a node.  In addition to these pointers, a
node may contain other pointers which refer you to a different node,
perhaps in another info file.  Such pointers are called "cross
references", or "xrefs" for short.

* Menu:

* Parts of an Xref::            What a cross reference is made of.
* Selecting Xrefs::             Commands for selecting menu or note items.


File: octave.info,  Node: Parts of an Xref,  Next: Selecting Xrefs,  Prev: Xref Commands,  Up: Xref Commands

Parts of an Xref
----------------

   Cross references have two major parts: the first part is called the
"label"; it is the name that you can use to refer to the cross
reference, and the second is the "target"; it is the full name of the
node that the cross reference points to.

   The target is separated from the label by a colon `:'; first the
label appears, and then the target.  For example, in the sample menu
cross reference below, the single colon separates the label from the
target.

     * Foo Label: Foo Target.	More information about Foo.

   Note the `.' which ends the name of the target.  The `.' is not part
of the target; it serves only to let Info know where the target name
ends.

   A shorthand way of specifying references allows two adjacent colons
to stand for a target name which is the same as the label name:

     * Foo Commands::		Commands pertaining to Foo.

   In the above example, the name of the target is the same as the name
of the label, in this case `Foo Commands'.

   You will normally see two types of cross references while viewing
nodes: "menu" references, and "note" references.  Menu references
appear within a node's menu; they begin with a `*' at the beginning of
a line, and continue with a label, a target, and a comment which
describes what the contents of the node pointed to contains.

   Note references appear within the body of the node text; they begin
with `*Note', and continue with a label and a target.

   Like `Next', `Prev' and `Up' pointers, cross references can point to
any valid node.  They are used to refer you to a place where more
detailed information can be found on a particular subject.  Here is a
cross reference which points to a node within the Texinfo
documentation:  *Note Writing an Xref: (texinfo)xref, for more
information on creating your own texinfo cross references.


File: octave.info,  Node: Selecting Xrefs,  Prev: Parts of an Xref,  Up: Xref Commands

Selecting Xrefs
---------------

   The following table lists the Info commands which operate on menu
items.

`1' (`menu-digit')
`2' ... `9'
     Within an Info window, pressing a single digit, (such as `1'),
     selects that menu item, and places its node in the current window.
     For convenience, there is one exception; pressing `0' selects the
     *last* item in the node's menu.

`0' (`last-menu-item')
     Select the last item in the current node's menu.

`m' (`menu-item')
     Reads the name of a menu item in the echo area and selects its
     node.  Completion is available while reading the menu label.

`M-x find-menu'
     Moves the cursor to the start of this node's menu.

   This table lists the Info commands which operate on note cross
references.

`f' (`xref-item')
`r'
     Reads the name of a note cross reference in the echo area and
     selects its node.  Completion is available while reading the cross
     reference label.

   Finally, the next few commands operate on menu or note references
alike:

`TAB' (`move-to-next-xref')
     Moves the cursor to the start of the next nearest menu item or note
     reference in this node.  You can then use RET
     (`select-reference-this-line' to select the menu or note reference.

`M-TAB' (`move-to-prev-xref')
     Moves the cursor the start of the nearest previous menu item or
     note reference in this node.

`RET' (`select-reference-this-line')
     Selects the menu item or note reference appearing on this line.


File: octave.info,  Node: Window Commands,  Next: Printing Nodes,  Prev: Xref Commands,  Up: Help

Manipulating Multiple Windows
=============================

   A "window" is a place to show the text of a node.  Windows have a
view area where the text of the node is displayed, and an associated
"mode line", which briefly describes the node being viewed.

   GNU Info supports multiple windows appearing in a single screen; each
window is separated from the next by its modeline.  At any time, there
is only one "active" window, that is, the window in which the cursor
appears.  There are commands available for creating windows, changing
the size of windows, selecting which window is active, and for deleting
windows.

* Menu:

* The Mode Line::               What appears in the mode line?
* Basic Windows::               Manipulating windows in Info.
* The Echo Area::               Used for displaying errors and reading input.


File: octave.info,  Node: The Mode Line,  Next: Basic Windows,  Prev: Window Commands,  Up: Window Commands

The Mode Line
-------------

   A "mode line" is a line of inverse video which appears at the bottom
of an info window.  It describes the contents of the window just above
it; this information includes the name of the file and node appearing in
that window, the number of screen lines it takes to display the node,
and the percentage of text that is above the top of the window.  It can
also tell you if the indirect tags table for this info file needs to be
updated, and whether or not the info file was compressed when stored on
disk.

   Here is a sample mode line for a window containing an uncompressed
file named `dir', showing the node `Top'.

     -----Info: (dir)Top, 40 lines --Top---------------------------------------
                 ^^   ^   ^^^        ^^
               (file)Node #lines    where

   When a node comes from a file which is compressed on disk, this is
indicated in the mode line with two small `z''s.  In addition, if the
info file containing the node has been split into subfiles, the name of
the subfile containing the node appears in the modeline as well:

     --zz-Info: (emacs)Top, 291 lines --Top-- Subfile: emacs-1.Z---------------

   When Info makes a node internally, such that there is no
corresponding info file on disk, the name of the node is surrounded by
asterisks (`*').  The name itself tells you what the contents of the
window are; the sample mode line below shows an internally constructed
node showing possible completions:

     -----Info: *Completions*, 7 lines --All-----------------------------------


File: octave.info,  Node: Basic Windows,  Next: The Echo Area,  Prev: The Mode Line,  Up: Window Commands

Window Commands
---------------

   It can be convenient to view more than one node at a time.  To allow
this, Info can display more than one "window".  Each window has its own
mode line (*note The Mode Line::.) and history of nodes viewed in that
window (*note `history-node': Node Commands.).

`C-x o' (`next-window')
     Selects the next window on the screen.  Note that the echo area
     can only be selected if it is already in use, and you have left it
     temporarily.  Normally, `C-x o' simply moves the cursor into the
     next window on the screen, or if you are already within the last
     window, into the first window on the screen.  Given a numeric
     argument, `C-x o' moves over that many windows.  A negative
     argument causes `C-x o' to select the previous window on the
     screen.

`M-x prev-window'
     Selects the previous window on the screen.  This is identical to
     `C-x o' with a negative argument.

`C-x 2' (`split-window')
     Splits the current window into two windows, both showing the same
     node.  Each window is one half the size of the original window,
     and the cursor remains in the original window.  The variable
     `automatic-tiling' can cause all of the windows on the screen to
     be resized for you automatically, please *note automatic-tiling:
     Info Variables. for more information.

`C-x 0' (`delete-window')
     Deletes the current window from the screen.  If you have made too
     many windows and your screen appears cluttered, this is the way to
     get rid of some of them.

`C-x 1' (`keep-one-window')
     Deletes all of the windows excepting the current one.

`ESC C-v' (`scroll-other-window')
     Scrolls the other window, in the same fashion that `C-v' might
     scroll the current window.  Given a negative argument, the "other"
     window is scrolled backward.

`C-x ^' (`grow-window')
     Grows (or shrinks) the current window.  Given a numeric argument,
     grows the current window that many lines; with a negative numeric
     argument, the window is shrunk instead.

`C-x t' (`tile-windows')
     Divides the available screen space among all of the visible
     windows.  Each window is given an equal portion of the screen in
     which to display its contents.  The variable `automatic-tiling'
     can cause `tile-windows' to be called when a window is created or
     deleted.  *Note `automatic-tiling': Info Variables.


File: octave.info,  Node: The Echo Area,  Prev: Basic Windows,  Up: Window Commands

The Echo Area
-------------

   The "echo area" is a one line window which appears at the bottom of
the screen.  It is used to display informative or error messages, and to
read lines of input from you when that is necessary.  Almost all of the
commands available in the echo area are identical to their Emacs
counterparts, so please refer to that documentation for greater depth of
discussion on the concepts of editing a line of text.  The following
table briefly lists the commands that are available while input is being
read in the echo area:

`C-f' (`echo-area-forward')
     Moves forward a character.

`C-b' (`echo-area-backward')
     Moves backward a character.

`C-a' (`echo-area-beg-of-line')
     Moves to the start of the input line.

`C-e' (`echo-area-end-of-line')
     Moves to the end of the input line.

`M-f' (`echo-area-forward-word')
     Moves forward a word.

`M-b' (`echo-area-backward-word')
     Moves backward a word.

`C-d' (`echo-area-delete')
     Deletes the character under the cursor.

`DEL' (`echo-area-rubout')
     Deletes the character behind the cursor.

`C-g' (`echo-area-abort')
     Cancels or quits the current operation.  If completion is being
     read, `C-g' discards the text of the input line which does not
     match any completion.  If the input line is empty, `C-g' aborts
     the calling function.

`RET' (`echo-area-newline')
     Accepts (or forces completion of) the current input line.

`C-q' (`echo-area-quoted-insert')
     Inserts the next character verbatim.  This is how you can insert
     control characters into a search string, for example.

PRINTING CHARACTER (`echo-area-insert')
     Inserts the character.

`M-TAB' (`echo-area-tab-insert')
     Inserts a TAB character.

`C-t' (`echo-area-transpose-chars')
     Transposes the characters at the cursor.

   The next group of commands deal with "killing", and "yanking" text.
For an in depth discussion of killing and yanking, *note Killing and
Deleting: (emacs)Killing.

`M-d' (`echo-area-kill-word')
     Kills the word following the cursor.

`M-DEL' (`echo-area-backward-kill-word')
     Kills the word preceding the cursor.

`C-k' (`echo-area-kill-line')
     Kills the text from the cursor to the end of the line.

`C-x DEL' (`echo-area-backward-kill-line')
     Kills the text from the cursor to the beginning of the line.

`C-y' (`echo-area-yank')
     Yanks back the contents of the last kill.

`M-y' (`echo-area-yank-pop')
     Yanks back a previous kill, removing the last yanked text first.

   Sometimes when reading input in the echo area, the command that
needed input will only accept one of a list of several choices.  The
choices represent the "possible completions", and you must respond with
one of them.  Since there are a limited number of responses you can
make, Info allows you to abbreviate what you type, only typing as much
of the response as is necessary to uniquely identify it.  In addition,
you can request Info to fill in as much of the response as is possible;
this is called "completion".

   The following commands are available when completing in the echo
area:

`TAB' (`echo-area-complete')
`SPC'
     Inserts as much of a completion as is possible.

`?' (`echo-area-possible-completions')
     Displays a window containing a list of the possible completions of
     what you have typed so far.  For example, if the available choices
     are:
          bar
          foliate
          food
          forget
     and you have typed an `f', followed by `?', the possible
     completions would contain:
          foliate
          food
          forget
     i.e., all of the choices which begin with `f'.  Pressing SPC or
     TAB would result in `fo' appearing in the echo area, since all of
     the choices which begin with `f' continue with `o'.  Now, typing
     `l' followed by `TAB' results in `foliate' appearing in the echo
     area, since that is the only choice which begins with `fol'.

`ESC C-v' (`echo-area-scroll-completions-window')
     Scrolls the completions window, if that is visible, or the "other"
     window if not.


File: octave.info,  Node: Printing Nodes,  Next: Other Info Commands,  Prev: Window Commands,  Up: Help

Printing Out Nodes
==================

   You may wish to print out the contents of a node as  a quick
reference document for later use.  Info provides you with a command for
doing this.  In general, we recommend that you use TeX to format the
document and print sections of it, by running `tex' on the texinfo
source file.

`M-x print-node'
     Pipes the contents of the current node through the command in the
     environment variable `INFO_PRINT_COMMAND'.  If the variable doesn't
     exist, the node is simply piped to `lpr'.


File: octave.info,  Node: Other Info Commands,  Next: Info Variables,  Prev: Printing Nodes,  Up: Help

Miscellaneous Info Commands
===========================

   GNU Info contains several commands which self-document GNU Info:

`M-x describe-command'
     Reads the name of an Info command in the echo area and then
     displays a brief description of what that command does.

`M-x describe-key'
     Reads a key sequence in the echo area, and then displays the name
     and documentation of the Info command that the key sequence
     invokes.

`M-x describe-variable'
     Reads the name of a variable in the echo area and then displays a
     brief description of what the variable affects.

`M-x where-is'
     Reads the name of an Info command in the echo area, and then
     displays a key sequence which can be typed in order to invoke that
     command.

`C-h' (`get-help-window')
`?'
     Creates (or moves into) the window displaying `*Help*', and places
     a node containing a quick reference card into it.  This window
     displays the most concise information about GNU Info available.

`h' (`get-info-help-node')
     Tries hard to visit the node `(info)Help'.  The info file
     `info.texi' distributed with GNU Info contains this node.  Of
     course, the file must first be processed with `makeinfo', and then
     placed into the location of your info directory.

   Here are the commands for creating a numeric argument:

`C-u' (`universal-argument')
     Starts (or multiplies by 4) the current numeric argument.  `C-u' is
     a good way to give a small numeric argument to cursor movement or
     scrolling commands; `C-u C-v' scrolls the screen 4 lines, while
     `C-u C-u C-n' moves the cursor down 16 lines.

`M-1' (`add-digit-to-numeric-arg')
`M-2' ... `M-9'
     Adds the digit value of the invoking key to the current numeric
     argument.  Once Info is reading a numeric argument, you may just
     type the digits of the argument, without the Meta prefix.  For
     example, you might give `C-l' a numeric argument of 32 by typing:

          `C-u 3 2 C-l'
     or
          `M-3 2 C-l'

   `C-g' is used to abort the reading of a multi-character key
sequence, to cancel lengthy operations (such as multi-file searches) and
to cancel reading input in the echo area.

`C-g' (`abort-key')
     Cancels current operation.

   The `q' command of Info simply quits running Info.

`q' (`quit')
     Exits GNU Info.

   If the operating system tells GNU Info that the screen is 60 lines
tall, and it is actually only 40 lines tall, here is a way to tell Info
that the operating system is correct.

`M-x set-screen-height'
     Reads a height value in the echo area and sets the height of the
     displayed screen to that value.

   Finally, Info provides a convenient way to display footnotes which
might be associated with the current node that you are viewing:

`ESC C-f' (`show-footnotes')
     Shows the footnotes (if any) associated with the current node in
     another window.  You can have Info automatically display the
     footnotes associated with a node when the node is selected by
     setting the variable `automatic-footnotes'.  *Note
     `automatic-footnotes': Info Variables.


File: octave.info,  Node: Info Variables,  Prev: Other Info Commands,  Up: Help

Manipulating Variables
======================

   GNU Info contains several "variables" whose values are looked at by
various Info commands.  You can change the values of these variables,
and thus change the behaviour of Info to more closely match your
environment and info file reading manner.

`M-x set-variable'
     Reads the name of a variable, and the value for it, in the echo
     area and then sets the variable to that value.  Completion is
     available when reading the variable name; often, completion is
     available when reading the value to give to the variable, but that
     depends on the variable itself.  If a variable does *not* supply
     multiple choices to complete over, it expects a numeric value.

`M-x describe-variable'
     Reads the name of a variable in the echo area and then displays a
     brief description of what the variable affects.

   Here is a list of the variables that you can set in Info.

`automatic-footnotes'
     When set to `On', footnotes appear and disappear automatically.
     This variable is `On' by default.  When a node is selected, a
     window containing the footnotes which appear in that node is
     created, and the footnotes are displayed within the new window.
     The window that Info creates to contain the footnotes is called
     `*Footnotes*'.  If a node is selected which contains no footnotes,
     and a `*Footnotes*' window is on the screen, the `*Footnotes*'
     window is deleted.  Footnote windows created in this fashion are
     not automatically tiled so that they can use as little of the
     display as is possible.

`automatic-tiling'
     When set to `On', creating or deleting a window resizes other
     windows.  This variable is `Off' by default.  Normally, typing
     `C-x 2' divides the current window into two equal parts.  When
     `automatic-tiling' is set to `On', all of the windows are resized
     automatically, keeping an equal number of lines visible in each
     window.  There are exceptions to the automatic tiling;
     specifically, the windows `*Completions*' and `*Footnotes*' are
     *not* resized through automatic tiling; they remain their original
     size.

`visible-bell'
     When set to `On', GNU Info attempts to flash the screen instead of
     ringing the bell.  This variable is `Off' by default.  Of course,
     Info can only flash the screen if the terminal allows it; in the
     case that the terminal does not allow it, the setting of this
     variable has no effect.  However, you can make Info perform
     quietly by setting the `errors-ring-bell' variable to `Off'.

`errors-ring-bell'
     When set to `On', errors cause the bell to ring.  The default
     setting of this variable is `On'.

`gc-compressed-files'
     When set to `On', Info garbage collects files which had to be
     uncompressed.  The default value of this variable is `Off'.
     Whenever a node is visited in Info, the info file containing that
     node is read into core, and Info reads information about the tags
     and nodes contained in that file.  Once the tags information is
     read by Info, it is never forgotten.  However, the actual text of
     the nodes does not need to remain in core unless a particular info
     window needs it.  For non-compressed files, the text of the nodes
     does not remain in core when it is no longer in use.  But
     de-compressing a file can be a time consuming operation, and so
     Info tries hard not to do it twice.  `gc-compressed-files' tells
     Info it is okay to garbage collect the text of the nodes of a file
     which was compressed on disk.

`show-index-match'
     When set to `On', the portion of the matched search string is
     highlighted in the message which explains where the matched search
     string was found.  The default value of this variable is `On'.
     When Info displays the location where an index match was found,
     (*note `next-index-match': Searching Commands.), the portion of the
     string that you had typed is highlighted by displaying it in the
     inverse case from its surrounding characters.

`scroll-behaviour'
     Controls what happens when forward scrolling is requested at the
     end of a node, or when backward scrolling is requested at the
     beginning of a node.  The default value for this variable is
     `Continuous'.  There are three possible values for this variable:

    `Continuous'
          Tries to get the first item in this node's menu, or failing
          that, the `Next' node, or failing that, the `Next' of the
          `Up'.  This behaviour is identical to using the `]'
          (`global-next-node') and `[' (`global-prev-node') commands.

    `Next Only'
          Only tries to get the `Next' node.

    `Page Only'
          Simply gives up, changing nothing.  If `scroll-behaviour' is
          `Page Only', no scrolling command can change the node that is
          being viewed.

`scroll-step'
     The number of lines to scroll when the cursor moves out of the
     window.  Scrolling happens automatically if the cursor has moved
     out of the visible portion of the node text when it is time to
     display.  Usually the scrolling is done so as to put the cursor on
     the center line of the current window.  However, if the variable
     `scroll-step' has a nonzero value, Info attempts to scroll the
     node text by that many lines; if that is enough to bring the
     cursor back into the window, that is what is done.  The default
     value of this variable is 0, thus placing the cursor (and the text
     it is attached to) in the center of the window.  Setting this
     variable to 1 causes a kind of "smooth scrolling" which some
     people prefer.

`ISO-Latin'
     When set to `On', Info accepts and displays ISO Latin characters.
     By default, Info assumes an ASCII character set.  `ISO-Latin' tells
     Info that it is running in an environment where the European
     standard character set is in use, and allows you to input such
     characters to Info, as well as display them.


File: octave.info,  Node: Programming Utilities,  Next: Amusements,  Prev: Help,  Up: Top

Programming Utilities
*********************

* Menu:

* Evaluating Strings as Commands::
* Miscellaneous Utilities::


File: octave.info,  Node: Evaluating Strings as Commands,  Next: Miscellaneous Utilities,  Prev: Programming Utilities,  Up: Programming Utilities

Evaluating Strings as Commands
==============================

   It is often useful to evaluate a string as if it were an Octave
program, or use a string as the name of a function to call.  These
functions are necessary in order to evaluate commands that are not
known until run time, or to write functions that will need to call
user-supplied functions.

   The function `eval (COMMAND)' parses COMMAND and evaluates it as if
it were an Octave program, returning the last value computed.  The
COMMAND is evaluated in the current context, so any results remain
available after `eval' returns.  For example,

     octave:13> a
     error: `a' undefined
     octave:14> eval ("a = 13")
     a = 13
     ans = 13
     octave:15> a
     a = 13

   In this case, two values are printed:  one for the expression that
was evaluated, and one for the value returned from `eval'.  Just as
with any other expression, you can turn printing off by ending the
expression in a semicolon.  For example,

     octave:13> a
     error: `a' undefined
     octave:14> eval ("a = 13;")
     ans = 13
     octave:15> a
     a = 13

   The function `feval (NAME, ...)' can be used to evaluate the
function named NAME.  Any arguments after the first are passed on to
the named function.  For example,

     octave:12> feval ("acos", -1)
     ans = 3.1416

calls the function `acos' with the argument `-1'.

   The function `feval' is necessary in order to be able to write
functions that call user-supplied functions.  For example, here is a
simple-minded function for finding the root of a function of one
variable:

     function result = newtroot (f, x)
     
       delta = tol = sqrt (eps);
       maxit = 200;
       fx = feval (f, x);
       for i = 1:maxit
         if (abs (fx) < tol)
           result = x;
           return;
         else
           fx_new = feval (f, x + delta);
           deriv = (fx_new - fx) / delta;
           x = x - fx / deriv;
           fx = fx_new;
         endif
       endfor
     
       result = x;
     
     endfunction

   Note that this is only meant to be an example of calling
user-supplied functions and should not be taken too seriously.  In
addition to using a more robust algorithm, any serious code would check
the number and type of all the arguments, ensure that the supplied
function really was a function, etc.

