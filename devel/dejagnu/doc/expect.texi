@node Expect
@appendix Expect: Programmed Dialogue

@cindex Expect reference
This appendix presents the same information available in the Expect
Version 5 reference-manual entry (``man page''); we include it in the
DejaGnu manual for convenient reference.  The author of Expect, and of
this reference, is Don Libes, of the National Institute of Standards and
Technology (@sc{nist}).

@menu
* Introduction::
* Invoking Expect::
* Commands::
* Pretty-Printing::
* Examples::
* Caveats::
* Bugs::
* Expect Hints::
* Expect Bibliography::
* Acknowledgements::
@end menu

@node Introduction
@section Introduction

Expect is a program that ``talks'' to other interactive
programs according to a script.  Following the script, Expect
knows what can be expected from a program and what the correct
response should be.  An interpreted language provides branching and
high-level control structures to direct the dialogue.  In addition,
the user can take control and interact directly when desired,
afterward returning control to the script.

@code{expectk} is a mixture of Expect and @code{Tk}.  It behaves just
like Expect and @code{Tk}'s @code{wish}.  You can also use Expect
directly in C or C++ programs (that is, without Tcl). See libexpect(3).

The name ``Expect'' comes from the idea of ``send/expect'' sequences
popularized by @code{uucp}, @code{kermit}, and other modem control
programs.  However, unlike @code{uucp}, Expect is generalized so
that it can be run as a user-level command with any program and task in
mind.  Expect can actually talk to several programs at the same
time.

For example, here are some things Expect can do:

@itemize @bullet
@item
Cause your computer to dial you back, so that you can login without
paying for the call.

@item
Start a game (e.g., rogue) and if the optimal configuration doesn't appear,
restart it (again and again) until it does,
then hand over control to you.

@item
Run @code{fsck}, and in response to its questions, answer ``yes'' or
``no'', or give control back to you, based on predetermined criteria.

@item
Connect to another network or BBS (e.g., MCI Mail, CompuServe) and
automatically retrieve your mail so that it appears as if
it was originally sent to your local system.

@item
Carry environment variables, current directory, or any kind of
information across @code{rlogin}, @code{telnet}, @code{tip}, @code{su},
@code{chgrp}, and so on.
@end itemize

There are a variety of reasons why the shell cannot perform these tasks.
(Try, you'll see.)  All are possible with Expect.

In general, Expect is useful for running any program which
requires interaction between the program and the user.  All that is
necessary is that the interaction can be characterized programmatically.
Expect can also give the user back control (without halting the
program being controlled) if desired.  Similarly, the user can return
control to the script at any time.

@node Invoking Expect
@section Usage

@cindex executable Expect scripts
Expect reads a file for a list of commands to execute.  You can also
arrange to call Expect implicitly on systems which support the @samp{#!}
notation by marking the script executable, and making the first line in
your script:

@example
#!/usr/local/bin/expect -f
@end example

Of course, the path must accurately describe where Expect lives.
@file{/usr/local/bin} is just an example.

Here is a summary of the command line options you can use with Expect:

@smallexample
expect  @r{[} -dDinN @r{]}  @r{[} -c @var{cmds} @r{]}  @r{[[}  -f @r{]} @var{cmdfile} @r{]}  @r{[} @var{args} @r{]}
@end smallexample

@cindex end of Expect options
@cindex @samp{--} (Expect option)
@samp{--} may be used to delimit the end of the options.  This is useful
if you want to pass an option-like argument to your script without it
being interpreted by Expect.  This can usefully be placed in the
@samp{#!} line to prevent any option-like interpretation by Expect.  For
example, the following will leave the original arguments (including the
script name) in the variable @var{argv}.

@example
#!/usr/local/bin/expect --
@end example

Note that the usual @code{getopt} and @code{execve} conventions must be
observed when adding arguments to the @samp{#!} line.

@cindex command line options, Expect
@cindex options, Expect
Expect understands these command line options:

@table @code
@item -c @var{cmds}
@cindex @samp{-c} (Expect option)
@cindex command on invocation, Expect
@cindex Expect command on invocation
Execute the command @var{cmds} before any in the script.  The command
should be quoted to prevent being broken up by the shell.  This option
may be used multiple times.  You can execute multiple commands with a
single @samp{-c} by separating the commands with semicolons.  Commands
are executed in the order they appear.  (If you use Expectk, specify
this option as @samp{-command}.)

@item -d
@cindex @samp{-d} (Expect option)
@cindex debugging output, Expect
@cindex Expect debugging output
Enables some debugging output, which primarily reports internal activity
of commands such as @code{expect} and @code{interact}.  This option has
the same effect as @samp{exp_internal 1} at the beginning of an Expect
script, plus the version of Expect is printed.  (The @code{strace}
command is useful for tracing statements, and the @code{trace} command
is useful for tracing variable assignments.)  (When using Expectk,
specify this option as @samp{-diag}.)

@item -D @var{lev}
@cindex Expect interactive debugger
@cindex @samp{-D} (Expect option)
@cindex debugging Expect, option
Enables an interactive debugger.  The option argument @var{lev} is an
integer value.  The debugger takes control before the next Tcl procedure
if @var{lev} is non-zero or if a @key{C-c} is pressed (or a breakpoint
is hit, or other appropriate debugger command appears in the script).
@xref{Expect Bibliography,, Expect Bibliography}, for more information on
the debugger.  (When using Expectk, specify this option as
@samp{-Debug}.)

@item -f @var{cmdfile}
@cindex @samp{-f} (Expect option)
@cindex command file, Expect
@cindex Expect command line
Read commands from @var{cmdfile}.  The option itself is optional as it
is only useful with using the @samp{#!} notation in a script(see above),
so that other arguments may be supplied on the command line.  (When
using Expectk, specify this option as @samp{-file}.)

@item -b
@cindex @samp{-b} (Expect option)
@cindex reading Expect command files
By default, Expect reads the command file into memory in its entirety before
executing it.  It is occasionally desirable to read files one line at a
time.  For example, stdin is read this way.  In order to force Expect to
handle arbitrary files this way, use the @samp{-b} option.  (When using
Expectk, specify this option as @samp{-buffer}.)

If you supply the string @samp{-} as a filename, Expect reads standard input
instead.  (Use @samp{./-} to read from a file actually named @samp{-}.)

@item -i
@cindex @samp{-i} (Expect option)
@cindex interactive Expect
@cindex Expect, running interactively
Causes Expect to interactively prompt for commands instead of reading
them from a file.  Prompting is terminated via the @code{exit} command
or upon EOF.  See @code{interpreter} (below) for more information.
Expect assumes @samp{-i} if you use neither a command file nor
@samp{-c}.  (When using Expectk, specify this option as
@samp{-interactive}.)

@item -N
@cindex @samp{-N} (Expect option)
@itemx -n
@cindex @samp{-n} (Expect option)
@cindex initialization files, Expect
@cindex Expect initialization files
The file @file{$exp_library/expect.rc} is sourced automatically if
present, unless you use the @samp{-N} option.  (When using Expectk,
specify this option as @samp{-NORC}.)  Immediately after this, the file
@file{~/.expect.rc} is sourced automatically, unless you use the
@samp{-n} option.  (When using Expectk, specify this option as
@samp{-norc}.)  Both of these are sourced after executing any @samp{-c}
options.

@item @var{args}
@cindex arguments, Expect scripts
@cindex Expect script arguments
@cindex @code{argv}, Expect argument list
Optional @var{args} are constructed into a list and stored in the
variable named @code{argv}.  @code{argc} is initialized to the length of
@code{argv}.

@cindex name, Expect script
@cindex Expect script name
@cindex script name, Expect
@code{argv0} is defined to be the name of the script (or binary, if no
script is used).  For example, the following prints out the name of the
script and the first three arguments:

@example
send_user "$argv0 [lrange $argv 0 2]\n"
@end example
@end table

@node Commands
@section Commands

Expect uses @emph{Tcl} (Tool Command Language).  Tcl provides
control flow (e.g., if, for, break), expression evaluation and several
other features such as recursion, procedure definition, etc.  Commands
used here but not defined (e.g., @code{set}, @code{if}, @code{exec}) are
Tcl commands (@pxref{Tcl}).  Expect supports additional commands,
described below.  Unless otherwise specified, commands return the empty
string.

Commands are listed alphabetically so that they can be quickly located.
However, new users may find it easier to start by reading the
descriptions of @code{spawn}, @code{send}, @code{expect}, and
@code{interact}, in that order.  Then read the examples at the rear of
this man page.  (In the text of this man page, Expect with an
uppercase "E" refers to the Expect program while @code{expect}
with a lower-case "e" refers to the @code{expect} command within the
Expect program.)

@table @code
@item close @r{[} -slave @r{]} @r{[} -onexec @var{sw} @r{]} @r{[} -i @var{spawn_id} @r{]}
@cindex @code{close} (Expect command)
@cindex closing current process connection
Closes the connection to the current process.  Most interactive programs
detect EOF on their standard input, and exit; thus @code{close} usually
suffices to kill the process as well.  The @samp{-i} option declares the
process to close corresponding to the named @var{spawn_id}.

Both @code{expect} and @code{interact} will detect when the current
process exits and implicitly do a @code{close}.  But if you kill the
process by, say, @samp{exec kill $pid}, you will need to explicitly call
@code{close}.

The @samp{-onexec} option determines whether the spawn id will be closed
(when @var{sw} is nonzero) in any new spawned processes, or if you use
@code{overlay} to replace the current process.  To leave a spawn id
open, use the value @code{0} for @var{sw}.  The default is to force the
spawn id closed in any new processes.

@cindex slave, closing (Expect)
The @samp{-slave} option closes the slave associated with the spawn id.
(See @samp{open -pty}.)  If you leave the slave open, Expect closes it
automatically when the connection is closed.

No matter whether the connection is closed implicitly or explicitly, you
should call @code{wait} to clear up the corresponding kernel process
slot.  @code{close} does not call @code{wait} since there is no
guarantee that closing a process connection will cause it to exit.  See
@code{wait} below for more information.

@item debug @r{[[} -now @r{]} @var{sw} @r{]}
@cindex debugging Expect, command
@cindex @code{debug} (Expect command)
Controls a Tcl debugger that allows you to step through statements, set
breakpoints, and so on.

When you run @code{debug} with no arguments, it returns @code{1} if the
debugger is not running, or @code{0} otherwise.

To start the debugger, specify a value of @code{1} for the @var{sw}
argument.  To stop the debugger, specify a value of @code{0} for
@var{sw}.  Use the option @samp{-now} with a @var{sw} value of @code{1}
to start the debugger immediately (i.e., in the middle of the
@code{debug} command itself).  Otherwise, the debugger starts with the
next Tcl statement.

The @code{debug} command does not change any traps.  Compare this to
starting Expect with the @samp{-D} option (@pxref{Invoking Expect,,
Usage}).

@xref{Expect Bibliography,, Expect Bibliography}, for more information on
the debugger.

@item exp_internal @r{[} -f @var{file} @r{]} @var{value}
@cindex @code{exp_internal} (Expect command)
@cindex Expect exp_internal command
Causes further commands to send debugging information internal to
Expect to stderr if @var{value} is non-zero.  This output is
disabled if @var{value} is 0.  The debugging information includes every
character received, and every attempt made to match the current output
against the patterns.

@cindex Expect debug log
@cindex log, Expect debugging
If the optional @var{file} is supplied, all normal and debugging output
is written to that file (regardless of the value of @var{value}).  Any
previous debugging output file is closed.

@item disconnect
@cindex @code{disconnect} (Expect command)
@cindex disconnecting forked process
@cindex forked process, disconnecting
Disconnects a forked process from the terminal.  It continues running in
the background.  The process is given its own process group (if
possible).  Standard I/O is redirected to /dev/null.

The following fragment uses @code{disconnect} to continue running the
script in the background.

@example
if [fork]!=0 exit
disconnect
@dots{}
@end example

The following script reads a password, and then runs a program every
hour that demands a password each time it is run.  The script supplies
the password so that you only have to type it once.  (See the
description for the @code{stty} command, which demonstrates how to turn
off password echoing.)

@cartouche
@smallexample
send_user "password?\ "
expect_user -re "(.*)\n"
for @{@} 1 @{@} @{
      if [fork]!=0 @{exec sleep 3600;continue@}
      disconnect
      spawn priv_prog
      expect Password:
      send "$expect_out(1,string)\r"
      @dots{}
      exit
@}
@end smallexample
@end cartouche

An advantage to using @code{disconnect} over the shell asynchronous
process feature (@code{&}) is that Expect can save the terminal
parameters prior to disconnection, and then later apply them to new
ptys.  With @code{&}, Expect does not have a chance to read the
terminal's parameters since the terminal is already disconnected by the
time Expect receives control.

@item exit @r{[} -onexit @r{[} @var{eh} @r{]]} @r{[} -noexit @r{]} @r{[} @var{status} @r{]}
@cindex @code{exit} (Expect command)
@cindex killing Expect

Exit Expect, or prepare to do so.

Use the @samp{-onexit @var{eh}} option to set up a procedure named
@var{eh} as an exit handler.  Use @samp{exit -onexit} (without an
@var{eh} argument) to return the name of the current exit handler.

Use the @samp{-noexit} option to prepare Expect to exit, but stop short
of actually returning control to the operating system.  The user-defined
exit handler runs, as well as Expect's own internal handlers.  Do not
execute any further Expect commands.  This is useful if you are running
Expect with other Tcl extensions.  The current interpreter (and main
window if in the Tk environment) remain, so that other Tcl extensions
can clean up.  If the Expect @code{exit} is called again (however this
might occur), the handlers do not re-run.

Upon exiting, all connections to spawned processes are closed.  Closure
will be detected as an EOF by spawned processes.  @code{exit} takes no
other actions beyond what the normal system subroutine @code{_exit}
does.

Thus, spawned processes that do not check for EOF may continue to run.
(A variety of conditions are important to determining, for example, what
signals a spawned process will be sent, but these are system-dependent.)
Spawned processes that continue to run will be inherited by @code{init}.

@var{status} (or 0 if not specified) is returned as the exit status of
Expect.  @code{exit} is implicitly executed if the end of the
script is reached.

@item exp_pid @r{[} -i @var{spawn_id} @r{]}
@cindex @code{exp_pid} (Expect command)
@cindex process id (Expect)
Returns the process id corresponding to the currently spawned process.
If you use the @samp{-i} option, the result is the process id for the
@var{spawn_id} you specify.

@item expect @r{[[} -@var{opts} @r{]} @var{pat1} @var{body1} @r{]} @dots{} @r{[} -@var{opts} @r{]} @var{patn} @r{[} @var{bodyn} @r{]}
@cindex @code{expect} (Expect command)
@cindex waiting for output
@cindex output, expecting
waits until one of the patterns matches the output of a spawned process,
a specified time period has passed, or an end-of-file is seen.  If the
final @var{bodyn} is empty, it may be omitted.

Patterns from the most recent @code{expect_before} command are
implicitly used before any other patterns.  Patterns from the most
recent @code{expect_after} command are implicitly used after any other
patterns.

If the arguments to the entire @code{expect} statement require more than
one line, all the arguments may be ``braced'' into one so as to avoid
terminating each line with a backslash.  In this one case, the usual Tcl
substitutions will occur despite the braces.

If a pattern is the keyword @code{eof}, the corresponding body is
executed upon end-of-file.  If a pattern is the keyword @code{timeout},
the corresponding body is executed upon timeout.  The default timeout
period is 10 seconds but may be set, for example to 30, by the command
@samp{set timeout 30}.  An infinite timeout may be designated by the
value @code{-1}.  If a pattern is the keyword @code{default}, the
corresponding body is executed upon either timeout or end-of-file.

If a pattern matches, then the corresponding body is executed.
@code{expect} returns the result of the body (or the empty string if no
pattern matched).  In the event that multiple patterns match, the one
appearing first is used to select a body.

Each time new output arrives, it is compared to each pattern in the order
they are listed.  Thus, you may test for absence of a match by making
the last pattern something guaranteed to appear, such as a prompt.
In situations where there is no prompt, you must use
@code{timeout} (just like you would if you were interacting manually).

Patterns are specified in two ways.  By default, patterns are specified
as with Tcl's @code{string match} command.  (Such patterns are also
similar to C-shell filename expansion, usually referred to as ``glob''
patterns).

Use the @samp{-gl} option to distinguish patterns that might otherwise
match @code{expect} options.  You should protect any pattern beginning
with a @samp{-} by prefacing it with @samp{-gl}, since all strings
starting with @samp{-} are reserved for future options.

For example, the following fragment looks for a successful login.  (Note
that @code{abort} is presumed to be a procedure defined elsewhere in the
script.)

@cartouche
@smallexample
expect @{
  connected            break
  busy                 @{
                         print busy\n
                         continue
                       @}
  failed               abort
  "invalid password"   abort
  timeout              abort
@}
@end smallexample
@end cartouche

Quotes are necessary on the fourth pattern since it contains a space,
which would otherwise separate the pattern from the action.  Patterns
with the same action (such as the 3rd and 4th) require listing the
actions again.  This can be avoid by using regexp-style patterns (see
below).  More information on forming glob-style patterns can be found in
the Tcl manual.

Alternatively, regexp-style patterns follow the syntax defined by Tcl's
@code{regexp} (short for ``regular expression'') command.  regexp
patterns are introduced with the option @samp{-re}.  The previous
example can be rewritten using a regexp as:

@cartouche
@smallexample
expect @{
  connected                     break
  busy                          @{
                                  print busy\n
                                  continue
                                @}
  -re "failed|invalid password" abort
  timeout                       abort
@}
@end smallexample
@end cartouche

Both types of patterns are ``unanchored''.  This means that patterns do
not have to match the entire string, but can begin and end the match
anywhere in the string (as long as everything else matches).  Use
@samp{^} to match the beginning of a string, and @samp{$} to match the
end.  Note that if you do not wait for the end of a string, your
responses can easily end up in the middle of the string as they are
echoed from the spawned process.  While still producing correct results,
the output can look unnatural.  Thus, use of @samp{$} is encouraged if
you can exactly describe the characters at the end of a string.

The @samp{-nocase} option causes uppercase characters of the output to
compare as if they were lowercase characters.  The pattern is not
affected.

While reading output, more than 2000 bytes can force earlier bytes to be
``forgotten''.  This may be changed with the function @code{match_max}.
(Note that excessively large values can slow down the pattern matcher.)
If @var{patlist} is @code{full_buffer}, the corresponding body is
executed if @var{match_max} bytes have been received and no other
patterns have matched.


If @var{patlist} is the keyword @code{null}, and nulls are allowed (via
the @code{remove_nulls} command), the corresponding body is executed if
a single @sc{ascii} 0 is matched.  It is not possible to match 0 bytes
via glob or regexp patterns.

Upon matching a pattern (or @code{eof} or @code{full_buffer}), any
matching and previously unmatched output is saved in the array element
@w{@samp{expect_out(buffer)}}.  Up to 9 regexp substring matches are saved
in the array elements @w{@samp{expect_out(1,string)}} through
@w{@samp{expect_out(9,string)}}.

If you use the option @samp{-indices} before a pattern, @code{expect}
saves the starting and ending indices of the matched strings.  For each
substring, @w{@samp{expect_out(@var{x},start)}} holds the starting index;
the ending index is stored in @w{@samp{expect_out(@var{x},end)}}.  These
indices are in a form suitable for @code{lrange}; @var{x} corresponds to
the substring position in the pattern.  0 refers to the entire pattern
itself.

For example, if a process has produced output of @samp{abcdefgh\n}, the
result of:

@example
expect  "cd"
@end example

@noindent
is as if the following statements had executed:

@example
set expect_out(0,string) cd
set expect_out(buffer) abcd
@end example

@noindent
and @samp{efgh\n} is left in the output buffer.
For the output @samp{abbbcabkkkka\n}, the result of:

@example
expect -indices -re "b(b*).*(k+)"
@end example

@noindent
is as if the following statements had executed:

@example
set expect_out(0,start) 1
set expect_out(0,end) 10
set expect_out(0,string) bbbcabkkkk
set expect_out(1,start) 2
set expect_out(1,end) 3
set expect_out(1,string) bb
set expect_out(2,start) 10
set expect_out(2,end) 10
set expect_out(2,string) k
set expect_out(buffer) abbbcabkkkk
@end example

@noindent
and @samp{a\n} is left in the output buffer.  The pattern @samp{*} (or
@samp{-re ".*"} flushes the output buffer without reading any more
output from the process.

Normally, the matched output is discarded from Expect's internal
buffers.  You can prevent this by prefixing a pattern with the
@samp{-notransfer} option.  This option is especially useful in
experimenting (and, for convenience in that context, you can abbreviate
it to @samp{-n}).

By default, patterns are matched against output from the current
process; however, the @samp{-i} option declares the output from the
named @var{spawn_id} list be matched against any following patterns (up
to the next @samp{-i}).  The @var{spawn_id} list should either be a
shitespace-separated list of spawn ids, or a variable containing such a
list.

For example, the following @code{expect} command waits for
@samp{connected} from the current process, or @samp{busy}, @samp{failed}
or @samp{invalid password} from the @var{spawn_id} named by
@samp{$proc2}.

@cartouche
@smallexample
expect @{
  connected                     break
  -i $proc2 busy                @{
                                  print busy\n
                                  continue
                                @}
  -re "failed|invalid password" abort
  timeout                       abort
@}
@end smallexample
@end cartouche

@cindex @code{any_spawn_id} (Expect variable)
@cindex matching any spawn id
@cindex spawn id, matching any
The global variable @code{any_spawn_id} may be used to match patterns to
any spawn ids that are named with all other @samp{-i} options in t he
current @code{expect} command.  The spawn id from a @samp{-i} option with
no associated pattern (i.e., followed immediately by another @samp{-i})
is made available to any other patterns in the same @code{expect}
command associated with @code{any_spawn_id}.

@cindex indirect spawn ids (Expect)
@cindex I/O, changing source (Expect)
Preface a pattern with the option @samp{-iwrite} to set
@w{@code{expect_out(spawn_id)}} to the spawn id which matched the
pattern (or @code{eof}, or @code{full_buffer}).  Prefacing a pattern
with the option @samp{-iread} causes any spawn id lists containing
variables in any arguments of the current command to be reread when that
pattern is matched.  This provides a way of changing the I/O source
while the command is in execution.  Spawn ids provided this way are
called @dfn{indirect} spawn ids.

Prefacing a pattern with the option @samp{-timestamp} updates two
elements of @w{@code{expect_out}}:
@w{@code{expect_out(seconds)}} and @w{@code{expect_out(seconds_total)}}.  The
@code{seconds} element is the number of seconds that have elapsed
waiting for the current match.  The @code{seconds_total} element is the
number of seconds that have elapsed since the current @code{expect}
command began running.

Actions such as @code{break} and @code{continue} cause control
structures (i.e., @code{for}, @code{proc}) to behave in the usual way.
The command @samp{exp_continue} allows @code{expect} itself to continue
executing rather than returning as it normally would.

This is useful for avoiding explicit loops or repeated expect
statements.  The following example is part of a fragment to automate
@code{rlogin}.  The @code{continue} avoids having to write a second
@code{expect} statement (to look for the prompt again) if the
@code{rlogin} prompts for a password.

@cartouche
@smallexample
expect @{
  Password: @{
    stty -echo
    send_user "password (for $user) on $host: "
    expect_user -re "(.*)\n"
    send_user "\n"
    send "$expect_out(1,string)\r"
    stty echo
    exp_continue
  @} incorrect @{
    send_user "invalid password or account\n"
    exit
  @} timeout @{
    send_user "connection to $host timed out\n"
    exit
  @} eof @{
    send_user "connection to $host failed: \
$expect_out(buffer)"
    exit
  @} -re $prompt
@}
@end smallexample
@end cartouche

For example, the following fragment might help a user guide an
interaction that is already totally automated.  In this case, the
terminal is put into raw mode.  If the user presses @samp{+}, a variable
is incremented.  If @samp{p} is pressed, several returns are sent to the
process, perhaps to poke it in some way, and @samp{i} lets the user
interact with the process, effectively stealing away control from the
script.  In each case, the @samp{exp_continue} allows the current
@code{expect} to continue pattern matching after executing the current
action.

@cartouche
@smallexample
stty raw -echo
expect_after @{ -i $user_spawn_id
  "p" @{send "\r\r\r"; exp_continue@}
  "+" @{incr foo; exp_continue@}
  "i" @{interact; exp_continue@}
  "quit" exit
@}
@end smallexample
@end cartouche

@noindent
@samp{exp_continue} resets the timeout timer.

@item expect_after @r{[} @var{expect-args} @r{]}
@cindex @code{expect_after} (Expect command)
@cindex common patterns, matching last
@cindex matching common patterns last
Takes the same arguments as @code{expect}; however, it returns
immediately.  Pattern-action pairs from the most recent
@code{expect_after} are implicitly added to any following @code{expect}
commands.  If a pattern matches, it is treated as if it had been
specified in the @code{expect} command itself, and the associated body
is executed in the context of the @code{expect} command.  If patterns
from both @code{expect} and @code{expect_after} can match, the
@code{expect} pattern is used.

Unless overridden by a @samp{-i} option, @code{expect_after} patterns
match against the @code{spawn_id} defined at the time that the
@code{expect_after} command was executed (not when its pattern is
matched).

@item expect_background @r{[} @var{expect-args} @r{]}
@cindex @code{expect_background} (Expect command)
takes most of the same arguments as @code{expect}.  However, it returns
immediately.  Patterns are tested whenever new input arrives.
@emph{Note: this only works in the Tk environment.} The patterns
@code{timeout} and @code{default} are not meaningful to
@code{expect_background}.  @code{expect_background} accepts indirect
spawn id specifications; however, they cannot be updated.

The @code{expect_background} command uses @code{expect_before} and
@code{expect_after} patterns just like @code{expect} does.

When @code{expect_background} actions are being evaluated, background
processing for the same spawn id is blocked.  Background processing is
unblocked when the action completes.  While background processing is
blocked, it is possible to do a (foreground) @code{expect} on the same
spawn id.

It is not possible to execute an @code{expect} while an
@code{expect_background} is unblocked.  To cancel the effect of an
@code{expect_background} for a particular spawn id, declare another
@code{expect_background} with the same spawn id.  Declaring
@code{expect_background} with no pattern makes the corresponding spawn
id stop matching any patterns in the background.

@item expect_before @r{[} @var{expect-args} @r{]}
@cindex @code{expect_before} (Expect command)
@cindex common patterns, matching first
@cindex matching common patterns first
takes the same arguments as @code{expect}; however, it returns
immediately.  Pattern-action pairs from the most recent
@code{expect_before} are implicitly added to any following @code{expect}
commands.  If a pattern matches, it is treated as if it had been
specified in the @code{expect} command itself, and the associated body
is executed in the context of the @code{expect} command.  If patterns
from both @code{expect_before} and @code{expect} can match, the
@code{expect_before} pattern is used.

Unless overridden by a @samp{-i} option, @code{expect_before} patterns
match against the @code{spawn_id} defined at the time that the
@code{expect_before} command was executed (not when its pattern is
matched).

@item expect_user @r{[} @var{expect-args} @r{]}
@cindex @code{expect_user} (Expect command)
@cindex keystrokes, reading
@cindex reading keystrokes
Like @code{expect}, but reads characters from stdin (i.e.
keystrokes from the user).  By default, reading is performed in cooked
mode.  Thus, lines must end with a return in order for @code{expect} to
see them.  This may be changed via @code{stty} (see the @code{stty}
command below).

@item exp_version @r{[[} -exit @r{]} @var{version} @r{]}
@cindex @code{exp_version} (Expect command)
@cindex version of expect, checking
is useful for assuring that the script is compatible with the current
version of Expect.

With no arguments, the current version of Expect is returned.
This version may then be encoded in your script.  If you actually know
that you are not using features of recent versions, you can specify an
earlier version.

Versions consist of up to three numbers separated by dots.  First is the
major number.  Scripts written for versions of Expect with a
different major number will almost certainly not work.
@code{exp_version} returns an error if the major numbers do not
match.

Second is the minor number.  Scripts written for a version with a
greater minor number than the current version may depend upon some new
feature and might not run.  @code{exp_version} returns an error if
the major numbers match, but the script minor number is greater than
that of the running Expect.

Third is a number that plays no part in the version comparison.
However, it is incremented when the Expect software distribution
is changed in any way, such as by additional documentation or
optimization.  It is reset to 0 upon each new minor version.

With the @samp{-exit} option, Expect prints an error and exits if
the version is out of date.

@item fork
@cindex @code{fork} (Expect command)
@cindex creating new process
@cindex new process, creating
@cindex child process
Creates a new process.  The new process is an exact copy of the current
Expect process.  On success, @code{fork} returns 0 to the new (child)
process and returns the process ID of the child process to the parent
process.  On failure (invariably due to lack of resources, e.g., swap
space, memory), @code{fork} returns -1 to the parent process, and no
child process is created.

Forked processes exit via the @code{exit} command, just like the
original process.  Forked processes are allowed to write to the log
files.  If you do not disable debugging or logging in most of the
processes, the result can be confusing.

Some pty implementations may be confused by multiple readers and
writers, even momentarily.  Thus, it is safest to @code{fork} before
spawning processes.

@item interact @r{[} @var{string1} @var{body1} @r{]} @dots{} @r{[} @var{stringn} @r{[} @var{bodyn} @r{]]}
@cindex @code{interact} (Expect command)
@cindex Expect interaction, invoking from script
Gives control of the current process to the user, so that keystrokes are
sent to the current process, and the stdout and stderr of the current
process are returned.

String-body pairs may be specified as arguments, in which case the body
is executed when the corresponding string is entered.  (By default, the
string is not sent to the current process.)  The @code{interpreter}
command is assumed, if the final body is missing.

If the arguments to the entire @code{interact} statement require more
than one line, all the arguments may be ``braced'' into one so as to avoid
terminating each line with a backslash.  In this one case, the usual Tcl
substitutions will occur despite the braces.

For example, the following command runs interact with the following
string-body pairs defined: When @key{C-Z} is pressed, Expect is
suspended.  (The @code{-reset} option restores the terminal modes.)
When @key{C-A} is pressed, the user sees @samp{you typed a control-A}
and the process is sent a @samp{^A}.  When @kbd{$} is pressed, the user
sees the date.  When @key{C-C} is pressed, Expect exits.  If @kbd{foo}
is entered, the user sees @samp{bar}.  When @kbd{~~} is pressed, the
Expect interpreter runs interactively.

@cartouche
@smallexample
set CTRLZ \032
interact @{
  -reset $CTRLZ  @{exec kill -STOP 0@}
  \001    @{send_user "you typed a control-A\n";
            send "\001"
          @}
  $       @{send_user "The date is [exec date]."@}
  \003    exit
  foo     @{send_user "bar"@}
  ~~
@}
@end smallexample
@end cartouche

In string-body pairs, strings are matched in the order they are listed
as arguments.  Strings that partially match are not sent to the current
process in anticipation of the remainder coming.  If characters are then
entered such that there can no longer possibly be a match, only the part
of the string will be sent to the process that cannot possibly begin
another match.  Thus, strings that are substrings of partial matches can
match later, if the original string that was attempting to be match
ultimately fails.

By default, string matching is exact with no wild cards.  (In contrast,
the @code{expect} command uses glob-style patterns by default.)  Use the
@samp{-ex} option to distinguish patterns that might otherwise match
@code{interact} options.  Protect any pattern beginning with a @samp{-}
by prefacing it with @samp{-ex}.  (All strings starting with @samp{-}
are reserved for future options.)

The @samp{-re} option forces the string to be interpreted as a
regexp-style pattern.  In this case, matching substrings are stored in
the variable @w{@code{interact_out}} similarly to the way @code{expect}
stores its output in the variable @w{@code{expect_out}}.  The
@samp{-indices} option is similarly supported.

The pattern @code{eof} introduces an action that is executed upon
end-of-file.  A separate @code{eof} pattern may also follow the
@samp{-output} option, in which case it is matched if end of file is
detected while writing output.  The
default @code{eof} action is @code{return}, so that @code{interact}
simply returns upon any EOF.

The pattern @code{timeout} introduces a timeout (in seconds) and action
that is executed after no characters have been read for a given time.
The @code{timeout} pattern applies to the most recently specified
process.  There is no default timeout.  The special variable
@code{timeout} (used by the @code{expect} command) has no affect on this
timeout.

For example, the following statement could be used to autologout users
who have not typed anything for an hour but who still get frequent
system messages:

@smallexample
interact -input $user_spawn_id \
         timeout 3600 return  \
         -output $spawn_id
@end smallexample

If the pattern is the keyword @code{null}, and nulls are allowed (via
the @code{remove_nulls} command), the corresponding body is executed if
a single @sc{ascii} 0 is matched.  It is not possible to match 0 bytes
via glob or regexp patterns.

Preface a pattern with the option @samp{-iwrite}, to set
@w{@code{expect_out(spawn_id)}} to the spawn id which matches the
pattern (or eof).  Prefacing a pattern with the option @samp{-iread}
causes any spawn id lists containing variables in any arguments of the
current command to be re-read when that pattern is matched.  This
provides a way of changing the I/O source while the command is in
execution.

Actions such as @code{break} and @code{continue} cause control
structures (i.e., @code{for}, @code{proc}) to behave in the usual way.
However @code{return} causes interact to return to its caller, while
@code{inter_return} causes @code{interact} to cause a return in its
caller.  For example, if @samp{proc foo} called @code{interact} which
then executed the action @code{inter_return}, @samp{proc foo} would
return.  (This means that if @code{interact} calls @code{interpreter}
interactively typing @code{return} will cause the interact to continue,
while @code{inter_return} will cause the interact to return to its
caller.)

During @code{interact}, raw mode is used so that all characters may be
passed to the current process.  If the current process does not catch
job control signals, it will stop if sent a stop signal (by default
@key{C-Z}).  To restart it, send a continue signal (such as by
@samp{kill -CONT @var{pid}}).  If you really want to send a
@code{SIGSTOP} to such a process (by @key{C-Z}), consider spawning
@code{csh} first and then running your program.  On the other hand, if
you want to send a @code{SIGSTOP} to Expect itself, first press
@key{ESC} (the escape character), and then press @key{C-Z}.

String-body pairs can be used as a shorthand for avoiding having to
enter the interpreter and execute commands interactively.  The previous
terminal mode is used while the body of a string-body pair is being
executed.

For speed, actions execute in raw mode by default.  The @samp{-reset}
option resets the terminal to the mode it had before @code{interact} was
executed (invariably, cooked mode).  Note that characters entered when
the mode is being switched may be lost (an unfortunate feature of the
terminal driver on some systems).  The only reason to use @samp{-reset}
is if your action depends on running in cooked mode.

By default, actions that change the value of @code{spawn_id} will not
affect the behavior of interact even if input or output sources were
originally associated with @code{spawn_id}.

The @samp{-update} option forces @code{spawn_id} to be reexamined after
evaluation of an action.  This could be used, for example, so that
pressing a particular function key would switch to interacting with a
different process.  Place the @samp{-update} option before the pattern
of the action.

The @samp{-echo} option sends characters that match the following
pattern back to the process that generated them as each character is
read.  This may be useful when the user needs to see feedback from
partially typed patterns.

If a pattern is being echoed but eventually fails to match, the
characters are sent to the spawned process.  If the spawned process then
echoes them, the user will see the characters twice.  @samp{-echo} is
probably only appropriate in situations where the user is unlikely to
not complete the pattern.  For example, the following excerpt is from
@code{rftp}, the recursive-ftp script, where the user is prompted to
enter @kbd{~g}, @kbd{~p}, or @kbd{~l}, to get, put, or list the current
directory recursively.  These are so far away from the normal ftp
commands, that the user is unlikely to type @kbd{~} followed by anything
else, except mistakenly, in which case, they'll probably just ignore the
result anyway.

@example
interact @{
  -echo ~g @{getcurdirectory 1@}
  -echo ~l @{getcurdirectory 0@}
  -echo ~p @{putcurdirectory@}
@}
@end example

The @samp{-nobuffer} option sends characters that match the following
pattern on to the output process as characters are read.

This is useful when you wish to let a program echo back the pattern.
For example, the following might be used to monitor where a person is
dialing (a Hayes-style modem).  Each time @kbd{atd} is seen the script
logs the rest of the line.

@cartouche
@smallexample
proc lognumber @{@} @{
  interact -nobuffer -f -re "(.*)\r" return
  puts $log "[exec date]: dialed $interact_out(1,string)"
@}

interact -nobuffer -f "atd" lognumber
@end smallexample
@end cartouche

During @code{interact}, previous use of @code{log_user} is ignored.  In
particular, @code{interact} will force its output to be logged (sent to
the standard output) since it is presumed the user doesn't wish to
interact blindly.

The @samp{-o} option causes any following key-body pairs to be applied
to the output of the current process.  This can be useful, for example,
when dealing with hosts that send unwanted characters during a
@code{telnet} session.

By default, @code{interact} expects the user to be writing stdin and
reading stdout of the Expect process itself.  The @samp{-u} option (for
``user'') makes @code{interact} look for the user as the process named
by its argument (which must be a spawned id).

This allows two unrelated processes to be joined together without using
an explicit loop.  To aid in debugging, Expect diagnostics always go to
stderr (or stdout for certain logging and debugging information).  For
the same reason, the @code{interpreter} command will read interactively
from stdin.

For example, the following fragment creates a login process.  Then it
dials the user (not shown), and finally connects the two together.  Of
course, any process may be substituted for login.  A shell, for example,
would allow the user to work without supplying an account and password.

@cartouche
@smallexample
spawn login
set login $spawn_id
spawn tip modem
@dots{} ;# dial back out to user
@dots{} ;# connect user to login
interact -u $login
@end smallexample
@end cartouche

To send output to multiple processes, preface each spawn id list with a
@samp{-output} option.  Specify input for a group of output spawn ids by
prefacing a spawn id list with a @samp{-input} option.  (Both
@samp{-input} and @samp{-output} may take lists in the same form as the
@samp{-i} option in the @samp{expect} command.)  All following options and
strings (or patterns) apply to this input until another @samp{-input}
option appears.  If no @samp{-input} appears, @samp{-output} implies
@samp{-input $user_spawn_id -output}.  (Similarly, with patterns that do
not have @samp{-input}.)  If one @samp{-input} is specified, it
overrides @code{$user_spawn_id}.  If a second @samp{-input} is
specified, it overrides @code{$spawn_id}.  Additional @samp{-input}
options may be specified.

The two implied input processes default to having their outputs
specified as @code{$spawn_id} and @code{$user_spawn_id} (in reverse).
If a @samp{-input} option appears with no @samp{-output} option,
characters from that process are discarded.

The @samp{-i} option introduces a replacement for the current
@code{spawn_id} when no other @samp{-input} or @samp{-output} options
are used.

@item interpreter
@cindex @code{interpreter} (Expect command)
Causes the user to be interactively prompted for Expect and Tcl
commands.  The result of each command is printed.

Actions such as @code{break} and @code{continue} cause control
structures (i.e., @code{for}, @code{proc}) to behave in the usual way.
However @code{return} causes interpreter to return to its caller, while
@code{inter_return} causes @code{interpreter} to cause a return in its
caller.  For example, if @samp{proc foo} called @code{interpreter} which
then executed the action @code{inter_return}, @samp{proc foo} would
return.  Any other command causes @code{interpreter} to continue
prompting for new commands.

By default, the prompt contains two integers.  The first integer
describes the depth of the evaluation stack (i.e., how many times
@code{Tcl_Eval} has been called).  The second integer is the Tcl history
identifier.  The prompt can be set by defining a procedure called
@code{prompt1} whose return value becomes the next prompt.  If a
statement has open quotes, parens, braces, or brackets, a secondary
prompt (by default @samp{+> }) is issued upon newline.  The secondary
prompt may be set by defining a procedure called @code{prompt2}.

During @code{interpreter}, cooked mode is used, even if the its caller
was using raw mode.

@item log_file @r{[[-a]} @var{file} @r{]}
@cindex @code{log_file} (Expect command)
@cindex session transcript, Expect
@cindex Expect session transcript
If a filename is provided, @code{log_file} will record a transcript of
the session (beginning at that point) in the file.  @code{log_file} will
stop recording if no argument is given.  Any previous log file is
closed.

The @samp{-a} option forces output to be logged that was suppressed by
the @code{log_user} command.

The @code{log_file} command @emph{appends} to old files rather than
truncating them, for the convenience of being able to turn logging off
and on multiple times in one session.  A simple way to always start with
a fresh log file is to delete the log file before using the
@code{log_file} command for the first time in a script.  For example:

@example
exec rm transcript
log_file transcript
@end example

@item log_user @var{expression}
@cindex @code{log_user} (Expect command)
By default, the send/expect dialogue is logged to standard output (and a
logfile if open).  To disable logging to stdout, use the command
@samp{log_user 0}; re-enable it with @samp{log_user 1}.  Logging to a
logfile is unaffected by this command.

@item match_max @r{[}-d@r{]} @r{[}-i @var{spawn_id} @r{]} @r{[}@var{size}@r{]}
defines the size of the buffer (in bytes) used internally by
@code{expect}.  With no @var{size} argument, the current size is
returned.

With the @samp{-d} option, the default size is set.  (The initial
default is 2000.)  With the @samp{-i} option, the size is set for the
named spawn id, otherwise it is set for the current process.

@item overlay @r{[}-@var{n} @var{spawn_id}@r{@dots{}]} @var{program} @r{[}@var{args}@r{]}
@cindex @code{overlay} (Expect command)
Executes @samp{@var{program args}} in place of the current Expect program,
which terminates.  A bare hyphen argument forces a hyphen in front of
the command name as if it was a login shell.  All spawn ids are closed
except for those named as arguments.  These are mapped onto the named
file descriptors @var{n}.

Spawn ids are mapped to file descriptors for the new program to inherit.
For example, the following line runs @code{chess} and allows it to be
controlled by the current process---say, a chess master.

@c FIXME! There seems to be a lot of confusion in the original man page
@c (propagated here, alas) about when "spawn_id" is a metavariable, when
@c it is an Expect variable, and when it is just a name for a class of
@c things.  Try to fix this one day...!
@smallexample
overlay -0 $spawn_id -1 $spawn_id -2 $spawn_id chess
@end smallexample

This is more efficient than @samp{interact -u}.  However, it sacrifices
the ability to do programmed interaction since the Expect process is no
longer in control.

Note that no controlling terminal is provided.  Thus, if you disconnect
or remap standard input, programs that do job control (shells, login,
etc) will not function properly.

@item parity @r{[}-d@r{]} @r{[}-i @var{spawn_id}@r{]} @r{[}@var{value}@r{]}
@cindex @code{parity} (Expect command)
Defines whether parity should be retained or stripped from the output of
spawned processes.  If @var{value} is zero, parity is stripped,
otherwise it is not stripped.  With no @var{value} argument, the current
value is returned.

With the @samp{-d} option, the default parity value is set.  (The
initial default is 1, i.e., parity is not stripped.)  With the @samp{-i}
option, the parity value is set for the named spawn id, otherwise it is
set for the current process.

@item remove_nulls @r{[} -d @r{]}  @r{[} -i @var{spawn_id} @r{]} @r{[} @var{sw} @r{]}
@cindex @code{remove_nulls} (Expect command)
@cindex null characters, and Expect
Defines whether null characters are retained, or removed from the output
of spawned processes before pattern matching (and before storing in
either @w{@code{expect_out}} or @w{@code{interact_out}}).  If @var{sw} is zero,
nulls are removed; otherwise they are not removed.  With no @var{sw}
argument, the current setting is returned.

With the @samp{-d} option, the default value is set.  (The initial
default is @code{1}, i.e., nulls are removed.)  With the @samp{-i} option,
the value is set for the spawn id @var{spawn_id}; otherwise it is set
for the current process.

Whether or not nulls are removed, Expect records null bytes to the log
and to stdout.

@item send @r{[}-s@r{]} @r{[}-h@r{]} @r{[}-i @var{spawn_id}@r{]} @r{[}-raw@r{]} @r{[} -0 @r{[} @var{n} @r{]]} @r{[} -- @r{]} @var{string}
@cindex @code{send} (Expect command)
@cindex input to current process, sending
Sends @var{string} to the current process.  Strings are interpreted
following Tcl rules.  For example, the command

@example
send "hello world\r"
@end example

sends the characters @samp{h} @samp{e} @samp{l} @samp{l} @samp{o}
@w{@samp{ }} @samp{w} @samp{o} @samp{r} @samp{l} @samp{d}
@samp{@key{RET}} to the current process.  (Tcl includes a command
similar to @code{printf} (called @code{format}) which can build
arbitrarily complex strings.)

Characters are sent immediately although programs with line-buffered
input will not read the characters until a return character is sent.  A
return character is denoted @samp{\r}.

Use the @samp{--} option to force the next argument to be interpreted as
a string rather than an option.  Any string can be preceded by @samp{--}
whether or not it actually looks like an option.  This provides a reliable
mechanism to specify variable strings without being tripped up by those
that accidentally look like options.  (All strings starting with @samp{-}
are reserved for future options.)

The @samp{-i} option declares that the string be sent to the named spawn
id.  If the spawn id is @code{user_spawn_id}, and the terminal is in raw
mode, newlines in the string are translated to return-newline sequences
so that they appear as it the terminal was in cooked mode.  The
@samp{-raw} option disables this translation.

The @samp{-0} option sends @sc{ascii} NUL characters (zeros).  By default,
one NUL is sent.  Use an integer following the @samp{-0} to specify how
many NULs to send.

The @samp{-s} option forces output to be sent ``slowly'', thus avoid the
common situation where a computer outtypes an input buffer that was
designed for a human who would never outtype the same buffer.  This
output is controlled by the value of the variable @code{send_slow} which
takes a two element list.  The first element is an integer that
describes the number of bytes to send atomically.  The second element is
a real number that describes the number of seconds by which the atomic
sends must be separated.  For example, @samp{set send_slow 10 .001}
would force @samp{send -s} to send strings with 1 millisecond in between
each 10 characters sent.

@cindex @code{send_human} (Expect variable)
@cindex timing input
@cindex input delays
The @samp{-h} option forces output to be sent (somewhat) like a human
actually typing.  Human-like delays appear between the characters.  (The
algorithm is based upon a Weibull distribution, with modifications to
suit this particular application.)  This output is controlled by the
value of the variable @code{send_human} which takes a five element list.
The first two elements are average interarrival time of characters in
seconds.  The first is used by default.  The second is used at word
endings, to simulate the subtle pauses that occasionally occur at such
transitions.  The third parameter is a measure of variability, where .1
is quite variable, 1 is reasonably variable, and 10 is quite invariable.
The extremes are 0 to infinity.  The last two parameters are,
respectively, a minimum and maximum interarrival time.  The minimum and
maximum are used last, and ``clip'' the final time.  The effective
average can be quite different from the specified average if the minimum
and miximum clip enough values.

As an example, the following command emulates a fast and consistent
typist:

@example
set send_human @{.1 .3 1 .05 2@}
send -h "I'm hungry.  Let's do lunch."
@end example

@noindent
while the following might be more suitable after a hangover:

@example
set send_human @{.4 .4 .2 .5 100@}
send -h "Goodd party lash night!"
@end example

Note that errors are not simulated, although you can set up error
correction situations yourself by embedding mistakes and corrections
in a send argument.

It is a good idea to precede the first @code{send} to a process by an
@code{expect}.  @code{expect} will wait for the process to start, while
@code{send} cannot.  In particular, if the first @code{send} completes
before the process starts running, you run the risk of having your data
ignored.  In situations where interactive programs offer no initial
prompt, you can precede @code{send} by a delay as in:

@cartouche
@smallexample
# To avoid hints on how to break in,
# there is no prompt for an external password.
# Wait for 5 seconds for exec to complete
spawn telnet very.secure.gov
exec sleep 5
send password\r
@end smallexample
@end cartouche

@cindex @code{exp_send} (Expect command)
@code{exp_send} is an alias for @code{send}.  If you are using Expectk
or some other variant of Expect in the Tk environment, @code{send} is
defined by Tk for an entirely different purpose.  @code{exp_send} is
provided for compatibility between environments.  Similar aliases are
provided for other Expect's other send commands.

@item send_error @var{string}
@cindex @code{send_error} (Expect command)
@cindex standard error, writing on
Like @code{send}, except that the string is sent to standard
error rather than the current process.

@item send_log @var{string}
@cindex @code{send_log} (Expect command)
@cindex Expect log file, writing on
@cindex writing on Expect log file
Like @code{send}, except that @var{string} is only sent to the log
file (see @code{log_file}).  @var{string} is ignored if no log file is
open.

@item send_spawn @var{args}
@cindex @code{send_spawn} (Expect command)
An alias for @code{send}.  If you are use @code{expectk} or some other
variant of Expect in the Tk environment, @code{send} is defined by Tk
for an entirely different purpose.  @code{send_spawn} is provided for
compatibility between environments.

@item send_user @var{args}
@cindex @code{send_user} (Expect command)
@cindex writing on standard output
@cindex standard output, writing
is like @code{send}, except that the arguments are sent to stdout rather
than the current process.

@item spawn @r{[}@var{opts}@r{]} program @r{[}@var{args}@r{]}
@cindex @code{spawn} (Expect command)
@cindex new process, starting
@cindex program, starting
@cindex starting new process
Creates a new process running @samp{@var{program args}}.  Its
@code{stdin}, @code{stdout}, and @code{stderr} are connected to Expect,
so that they may be read and written by other Expect commands.  The
connection is broken by @code{close} or if the process itself closes any
of the file descriptors.

When a process is started by @code{spawn}, the variable @code{spawn_id}
is set to a descriptor referring to that process.  The process described
by @code{spawn_id} is considered the @dfn{current process}.
@code{spawn_id} may be read or written, in effect providing job control.

@code{user_spawn_id} is a global variable containing a descriptor
which refers to the user.  For example, when @code{spawn_id} is set to
this value, @code{expect} behaves like @code{expect_user}.

@code{tty_spawn_id} is a global variable containing a descriptor for
@file{/dev/tty}.  If @file{/dev/tty} does not exist (such as in a
@code{cron}, @code{at}, or @code{batch} script), then
@code{tty_spawn_id} is not defined.  This may be tested as:

@example
if [info vars tty_spawn_id] @{
  # /dev/tty exists
  @dots{}
@} else @{
  # /dev/tty doesn't exist
  # probably in cron, batch, or at script
  @dots{}
@}
@end example

@code{spawn} returns the UNIX process id.  If no process is spawned, the
result is @code{0}.  The variable element @code{spawn_out(slave,name)}
is set to the name of the pty slave device.

By default, @code{spawn} echoes the command name and arguments.  The
@samp{-noecho} option stops @code{spawn} from doing this.

The @samp{-console} option causes console output to be redirected to the
spawned process.  This is not supported on all systems.

Internally, @code{spawn} uses a pty, initialized the same way as the
user's tty.  This is further initialized so that all settings are
@code{sane} (according to @cite{stty(1)}).  If the variable
@code{stty_init} is defined, it is interpreted in the style of
@code{stty} arguments as further configuration.  For example, @samp{set
stty_init raw} will cause further spawned processes's terminals to start
in raw mode.  @samp{-nottycopy} skips the initialization based on the
user's tty.  @samp{-nottyinit} skips the @code{sane} initialization.

Normally, @code{spawn} takes little time to execute.  If you notice
spawn taking a significant amount of time, it is probably encountering
ptys that are wedged.  A number of tests are run on ptys to avoid
entanglements with errant processes.  (These take 10 seconds per wedged
pty.)  Running Expect with the @samp{-d} option will show if Expect is
encountering many ptys in odd states.  If you cannot kill the processes
to which these ptys are attached, your only recourse may be to reboot.

If @var{program} cannot be spawned successfully because @code{exec}
fails (e.g. when @var{program} does not exist), an error message will be
returned by the next @code{interact} or @code{expect} command as if
@var{program} had run and produced the error message as output.  This
behavior is a natural consequence of the implementation of @code{spawn}.
Internally, spawn forks, after which the spawned process has no way to
communicate with the original Expect process except by communication via
the spawn id.

The @samp{-open} option causes the next argument to be interpreted as a
Tcl file descriptor (i.e., a result of @code{open}.)  You can then use
the spawn id as if it were a spawned process.  (The file descriptor
should no longer be used.)  This lets you treat raw devices, files, and
pipelines as spawned processes without using a pty.  @code{0} is
returned to indicate there is no associated process.

The @samp{-pty} option causes a pty to be opened but no process spawned.
@code{0} is returned to indicate there is no associated process.
@code{spawn_id} is set as usual.

The variable element @code{spawn_out(slave,fd)} is set to a file
descriptor corresponding to the pty slave.  You can close it using
@samp{close -slave}.

@item strace @var{level}
@cindex @code{strace} (Expect command)
@cindex tracing Tcl from Expect
Causes following statements to be printed before being executed.  (The
Tcl @code{trace} command traces variables.)  @var{level} indicates how
far down in the call stack to trace.  For example, the following command
runs Expect while tracing the first 4 levels of calls, but none below
that.

@example
expect -c "strace 4" script.exp
@end example

@item stty @var{args}
Changes terminal modes similarly to the external @code{stty} command.

By default, the controlling terminal is accessed.  Other terminals can
be accessed by appending @w{@samp{"< /dev/tty@dots{}"}} to the command.
(Note that the arguments should not be grouped into a single argument.)

Requests for status return it as the result of the command.  If no status
is requested and the controlling terminal is accessed, the previous
status of the raw and echo attributes are returned in a form which can
later be used by the command.

For example, the arguments @samp{-raw} or @samp{cooked} put the terminal
into cooked mode.  The arguments @samp{echo} and @samp{-echo} put the
terminal into echo and noecho mode respectively.

The following example illustrates how to use @code{stty} to
temporarily disable echoing.  This could be used in otherwise-automatic
scripts to avoid embedding passwords in them.  (For more discussion of
this, @pxref{Expect Hints,, Expect Hints}.)

@cartouche
@smallexample
stty -echo
send_user "Password: "
expect_user -re "(.*)\n"
set password $expect_out(1,string)
stty echo
@end smallexample
@end cartouche

@item system @var{args}
@cindex @code{system} (Expect command)
@cindex shell commands
Gives @var{args} to @code{sh} as input, just if it had been typed as a
command from a terminal.  Expect waits until the shell terminates.  The
return status from @code{sh} is handled the same way that @code{exec}
handles its return status.

In contrast to @code{exec} which redirects stdin and stdout to the
script, @code{system} performs no redirection (other than that indicated
by the string itself).  Thus, it is possible to use programs which must
talk directly to @file{/dev/tty}.  For the same reason, the results of
@code{system} are not recorded in the log.

@item timestamp @r{[} -format @var{string} @r{]}  @r{[} -seconds @var{n} @r{]}
@cindex @code{timestamp} (Expect command)
Returns a timestamp.
With no arguments, the result is the number of seconds since the epoch.

The @samp{-format} option introduces a string which specifies a format
for the result according to the @sc{posix} rules for the @code{strftime}
C subroutine.  In the format string, you can specify these substitutions:

@table @code
@item %a
abbreviated weekday name (e.g., @samp{Sat})

@item %A
full weekday name

@item %b
abbreviated month name

@item %B
full month name

@item %c
date-time, as in: @samp{Wed Oct  6 11:45:56 1993}

@item %d
day of the month (1--31)

@item %H
hour (0--23)

@item %I
hour (1--12)

@item %j
day (1--366)

@item %m
month (1--12)

@item %M
minute (0--59)

@item %p
@samp{am} or @samp{pm}

@item %S
second (0--61)

@item %U
week (0--50, Sunday is first day of week)

@item %w
day (0--6)

@item %W
week (0--50, Monday is first day of week)

@item %x
date, as in: @samp{Wed Oct  6 1993}

@item %X
time, as in: @samp{23:59:59}

@item %y
year of century (0--99)

@item %Y
year, as in: @samp{1993}

@item %%
a percent sign
@end table

Other @samp{%} specifications are undefined.  Other characters are
copied as specified.  The final string returned must not be more than
200 characters.  Only the C locale is supported.

The @samp{-seconds} option introduces a number of seconds since the
epoch, as the time to format.  Otherwise, the current time is used.

@item trap @r{[[}@var{command}@r{]} @var{signals}@r{]}
@cindex @code{trap} (Expect command)
@cindex signal handling
Causes the given @var{command} to be executed upon future receipt of any
of the given signals.  The command executes with global scope.  If
@var{command} is absent, the signal action is returned.  If
@var{command} is the string @code{SIG_IGN}, the signals are ignored.  If
@var{command} is the string @code{SIG_DFL}, the signal handlers are
reset to the system default.  @var{signals} is either a single signal or
a list of signals.  Signals may be specified numerically or symbolically
as per @cite{signal(3)}.  The @samp{SIG} prefix may be omitted.
@code{ONEXIT} (signal 0) is raised upon exit from Expect.

For example, @samp{trap @{send_user "Ouch!"@} SIGINT} prints
@samp{Ouch!} each time the user presses @key{C-c}.

With no arguments (or with the option @samp{-number}), @code{trap}
returns the signal number of the trap command currently executing.

The @samp{-code} option uses the return code of the command in place of
whatever Tcl was about to return when the command originally started
running.

The @samp{-interp} option causes the command to be evaluated using the
interpreter active at the time the command started running rather than
when the trap was declared.

The @samp{-name} option causes the @code{trap} command to return the
signal name of the trap command currently being executed.

The @samp{-max} option causes the @code{trap} command to return the
largest signal number that can be set.

By default, @code{SIGINT} (which can usually be generated by pressing
@key{C-c}) and @code{SIGTERM} cause Expect to exit.  This is due to the
following trap, created by default when Expect starts:

@example
trap exit @{SIGINT SIGTERM@}
@end example

If you use the @samp{-D} option to start the debugger, the @code{SIGINT}
handler is redefined to start the interactive debugger, with the
following trap:

@example
trap @{exp_debug 1@} SIGINT
@end example

You can set the environment variable @code{EXPECT_DEBUG_INIT} to change
the debugger trap to another @code{trap} command.

You can, of course, override both of these just by adding trap commands
to your script.  In particular, if you have your own @w{@samp{trap exit
SIGINT}}, this overrides the debugger trap.  This is useful if you want
to prevent users from getting to the debugger at all.

If you want to define your own trap on @code{SIGINT} but still trap to the
debugger when it is running, use:

@example
if ![exp_debug] @{trap mystuff SIGINT@}
@end example

Alternatively, you can trap to the debugger using some other signal.

@code{trap} will not let you override the action for @code{SIGALRM} as
this is used internally to Expect.  The @code{disconnect} command sets
@code{SIGALRM} to @code{SIG_IGN} (ignore).  You can reenable this as
long as you disable it during subsequent spawn commands.

See @cite{signal(3)} for more information.

@item wait @r{[}-i @var{spawn_id}@r{]}
@cindex @code{wait} (Expect command)
@cindex delay
Delays until a spawned process (or the current process, if none is
named) terminates.

@code{wait} returns a list of four integers.  The first integer is the process id
of the process that was waited upon.  The second integer is the
corresponding spawn id.  The third integer is @code{-1} if an operating
system error occurred, @code{0} otherwise.  When the third integer is
@code{0}, the fourth integer is the status returned by the spawned
process.  When the third integer is @code{-1}, the fourth integer is the
value of @code{errno} set by the operating system.  The global variable
@code{errorCode} is also set.

The @samp{-i} option declares the process to wait corresponding to the
named spawn id (@emph{not} the process id).  You can wait for a signal
in any process by using the value stored in the global variable
@code{any_spawn_id}.
@end table

@node Pretty-Printing
@section Pretty-Printing

A @code{vgrind} definition is available for pretty-printing Expect
scripts.  Assuming the @code{vgrind} definition supplied with the Expect
distribution is correctly installed, you can use it as:

@example
vgrind -lexpect file
@end example

@node Examples
@section Examples

It may not be apparent how to put everything together that is described
here.  I encourage you to read and try out the examples in the
@file{example} directory of the Expect distribution.  Some of them are
real programs.  Others are simply illustrative of certain techniques,
and of course, a couple are just quick hacks.  The @file{INSTALL} file
has a quick overview of these programs.

The examples in the Expect papers (@pxref{Expect Bibliography}) are also
useful.  While some papers use syntax corresponding to earlier versions
of Expect, the accompanying rationales are stil valid, and go into a lot
more detail than this document.

@node Caveats
@section Caveats

@cindex @code{exp_@var{cmd}}
@cindex prefixed Expect commands
@cindex Expect commands, prefixed
Extensions may collide with Expect command names.  For example, Tk
defines @code{send} for an entirely different purpose.  For this reason,
most of the Expect commands are also available as @samp{exp_@var{cmd}}.
Commands and variables beginning with @samp{exp}, @samp{inter},
@samp{spawn}, and @samp{timeout} do not have aliases.  Use the prefixed
command names for compatibility between environments.

Expect takes a rather liberal view of scoping.  In particular, variables
read by commands specific to the Expect program will be sought first
from the local scope, and if not found, in the global scope.  For
example, this obviates the need to place @samp{global timeout} in every
procedure you write that uses @code{expect}.  On the other hand,
variables written are always in the local scope (unless a @code{global}
command has been issued).  The most common problem this causes is when
@code{spawn} is executed in a procedure.  Outside the procedure,
@code{spawn_id} no longer exists, so the spawned process is no longer
accessible simply because of scoping.  Add a @w{@samp{global spawn_id}}
to such a procedure.

If you cannot enable the multispawning capability (i.e., your system
supports neither @code{select} (BSD), @code{poll} (SVr@code{>}2), nor
something equivalent), Expect will only be able to control a single
process at a time.  In this case, do not attempt to set @code{spawn_id},
nor should you execute processes via @code{exec} while a spawned process
is running.  Furthermore, you will not be able to @code{expect} from
multiple processes (including the user as one) at the same time.

Terminal parameters can have a big effect on scripts.  For example, if a
script is written to look for echoing, it will misbehave if echoing is
turned off.  For this reason, Expect forces @samp{sane} terminal
parameters by default.  Unfortunately, this can make things unpleasant
for other programs.  As an example, the Emacs shell wants to change the
``usual'' mappings: newlines get mapped to newlines instead of
carriage-return newlines, and echoing is disabled.  This allows one to
use emacs to edit the input line.  Unfortunately, Expect cannot possibly
guess this.

You can request that Expect not override its default setting of terminal
parameters, but you must then be very careful when writing scripts for
such environments.  In the case of Emacs, avoid depending upon things
like echoing and end-of-line mappings.

The commands that accepted arguments braced into a single list (the
@code{expect} variants and @code{interact}) use a heuristic to decide if
the list is actually one argument or many.  The heuristic can fail only
in the case when the list actually does represent a single argument
which has multiple embedded @samp{\n} characters with non-whitespace
characters between them.  This seems sufficiently improbable; however,
the argument @samp{-brace} can be used to force a single argument to be
handled as a single argument.  This could conceivably be used with
machine-generated Expect code.

@node Bugs
@section Bugs
It was really tempting to name the program @code{sex} (for either
``Smart EXec'' or ``Send-EXpect''), but good sense (or perhaps just
Puritanism) prevailed.

On some systems, when a shell is spawned, it complains about not being
able to access the tty but runs anyway.  This means your system has a
mechanism for gaining the controlling tty that Expect doesn't know
about.  Please find out what it is, and send this information back to
me.

Ultrix 4.1 (at least the latest versions around here) considers timeouts
of above 1000000 to be equivalent to 0.

Telnet (verified only under SunOS 4.1.2) hangs if @code{TERM} is not
set.  This is a problem under @code{cron} and @code{at}, which do not
define @code{TERM}.  Thus, you must set it explicitly---to what type is
usually irrelevant.  It just has to be set to something!  The following
probably suffices for most cases.

@example
set env(TERM) vt100
@end example

Some implementations of ptys are designed so that the kernel throws away
any unread output after 10 to 15 seconds (actual number is
implementation-dependent) after the process has closed the file
descriptor.  Thus, Expect programs such as

@example
spawn date
exec sleep 20
expect
@end example

@noindent
will fail.  To avoid this, invoke non-interactive programs with
@code{exec} rather than @code{spawn}.  While such situations are
conceivable, in practice I have never encountered a situation in which
the final output of a truly interactive program would be lost due to
this behavior.

On the other hand, Cray UNICOS ptys throw away any unread output
immediately after the process has closed the file descriptor.  I have
reported this to Cray and they are working on a fix.

Sometimes a delay is required between a prompt and a response, such as
when a tty interface is changing UART settings or matching baud rates by
looking for start/stop bits.  Usually, all this requires is to sleep for
a second or two.  A more robust technique is to retry until the hardware
is ready to receive input.  The following example uses both strategies:

@cartouche
@smallexample
send "speed 9600\r";
exec sleep 1
expect @{
  timeout @{send "\r"; exp_continue@}
  $prompt
@}
@end smallexample
@end cartouche

@node Expect Hints
@section Expect Hints

There are a couple of things about Expect that may be non-intuitive.
This section attempts to address some of these things with a couple of
suggestions.

A common expect problem is how to recognize shell prompts.  Since these
are customized differently by differently people and different shells,
portably automating rlogin can be difficult without knowing the prompt.
A reasonable convention is to have users store a regular expression
describing their prompt (in particular, the end of it) in the
environment variable @code{EXPECT_PROMPT}.  Code like the following can be
used.  If @code{EXPECT_PROMPT} does not exist, this code still has a good
chance of functioning correctly.

@cartouche
@smallexample
set prompt "(%|#|\\$) $"          ;# default prompt
if [info exists env(EXPECT_PROMPT)] @{
  set prompt $env(EXPECT_PROMPT)
@}

expect -re $prompt
@end smallexample
@end cartouche

I encourage you to write @code{expect} patterns that include the end of
whatever you expect to see.  This avoids the possibility of answering a
question before seeing the entire thing.  In addition, while you may
well be able to answer questions before seeing them entirely, if you
answer early, your answer may appear echoed back in the middle of the
question.  In other words, the resulting dialogue will be correct but
look scrambled.

Most prompts include a space character at the end.  For example, the
prompt from ftp is @samp{f}, @samp{t}, @samp{p}, @samp{>} and @w{@samp{
}}.  To match this prompt, you must account for each of these
characters.  It is a common mistake not to include the blank.  Put the
blank in explicitly.

If you use a pattern of the form @samp{@var{X}*}, the @samp{*} will
match all the output received from the end of @var{X} to the last thing
received.  This sounds intuitive but can be somewhat confusing because
the phrase ``last thing received'' can vary depending upon the speed of
the computer and the processing of I/O both by the kernel and the device
driver.

In particular, humans tend to see program output arriving in huge chunks
(atomically) when in reality most programs produce output one line at a
time.  Assuming this is the case, the @samp{*} in the pattern of the
previous paragraph may only match the end of the current line, even
though there seems to be more, because at the time of the match that was
all the output that had been received.

@code{expect} has no way of knowing that further output is coming unless
your pattern specifically accounts for it.

Even depending on line-oriented buffering is unwise.  Not only do
programs rarely make promises about the type of buffering they do, but
system indigestion can break output lines up so that lines break at
seemingly random places.  Thus, if you can express the last few
characters of a prompt when writing patterns, it is wise to do so.

If you are waiting for a pattern in the last output of a program and the
program emits something else instead, you will not be able to detect
that with the @code{timeout} keyword.  The reason is that @code{expect}
will not time out---instead it will get an @code{eof} indication.  Use
that instead.  Even better, use both.  That way if that line is ever
moved around, you will not have to edit the line itself.

Newlines are usually converted to carriage return, linefeed sequences
when output by the terminal driver.  Thus, if you want a pattern that
explicitly matches the two lines, from, say, @samp{printf("foo\nbar")},
you should use the pattern @samp{foo\r\nbar}.

A similar translation occurs when reading from the user, via
@code{expect_user}.  In this case, when you press return, it will be
translated to a newline.  If Expect then passes that to a program which
sets its terminal to raw mode (like @code{telnet}), there is going to be
a problem, as the program expects a true return.  (Some programs are
actually forgiving in that they will automatically translate newlines to
returns, but most do not.)  Unfortunately, there is no way to find out
that a program put its terminal into raw mode.

Rather than manually replacing newlines with returns, the solution is to
use the command @samp{stty raw}, which will stop the translation.
Note, however, that this means that you will no longer get the cooked
line-editing features.

@code{interact} implicitly sets your terminal to raw mode so this
problem will not arise then.

It is often useful to store passwords (or other private information) in
Expect scripts.  This is not recommended since anything that is stored
on a computer is susceptible to being accessed by anyone.  Thus,
interactively prompting for passwords from a script is a smarter idea
than embedding them literally.  Nonetheless, sometimes such embedding is
the only possibility.

Unfortunately, the UNIX file system has no direct way of creating
scripts which are executable but unreadable.  Systems which support
@code{setgid} shell scripts may indirectly simulate this as follows:

Create the Expect script (that contains the secret data) as usual.  Make
its permissions be 750 (@samp{-rwxr-x---}) and owned by a trusted group,
i.e., a group which is allowed to read it.  If necessary, create a new
group for this purpose.  Next, create a @code{/bin/sh} script with
permissions 2751 (@samp{-rwxr-s--x}) owned by the same group as before.

The result is a script which may be executed (and read) by anyone.  When
invoked, it runs the Expect script.

@node Expect Bibliography
@section Expect Bibliography

@xref{Tcl}, for discussion of the Tcl language that underlies Expect.

See @cite{libexpect(3)}, for discussion of a library of C functions
implementing @code{expect} functionality.

A number of papers provide further reading:

@table @cite
@item expect: Curing Those Uncontrollable Fits of Interactivity
Don Libes, Proceedings of the Summer 1990 USENIX Conference,
Anaheim, California, June 11-15, 1990.

@item Using @code{expect} to Automate System Administration Tasks
Don Libes, Proceedings of the 1990 USENIX Large Installation Systems
Administration Conference, Colorado Springs, Colorado, October 17-19,
1990.

@item Tcl: An Embeddable Command Language
John Ousterhout, Proceedings of the Winter 1990 USENIX Conference,
Washington, D.C., January 22-26, 1990.

@item expect: Scripts for Controlling Interactive Programs
Don Libes, @cite{Computing Systems}, Vol. 4, No. 2, University of California
Press Journals, November 1991.

@item Regression Testing and Conformance Testing Interactive Programs
Don Libes, Proceedings of the Summer 1992 USENIX Conference, pp. 135-144,
San Antonio, TX, June 12-15, 1992.

@item Kibitz---Connecting Multiple Interactive Programs Together
Don Libes, @cite{Software---Practice & Experience}, John Wiley & Sons,
West Sussex, England, Vol. 23, No. 5, May, 1993.

@item A Debugger for Tcl Applications
Don Libes, @cite{Proceedings of the 1993 Tcl/Tk Workshop}, Berkeley, CA,
June 10--11, 1993.
@end table

@node Acknowledgements
@section Acknowledgements

Don Libes, of the National Institute of Standards and Technology (@sc{nist}),
implemented Expect.

Thanks to John Ousterhout for Tcl, and Scott Paisley for inspiration.
Thanks to Rob Savoye for Expect's autoconfiguration code.

The @file{HISTORY} file documents much of the evolution of Expect.  It
makes interesting reading and might give you further insight to this
software.  Thanks to the people mentioned in it who sent me bug fixes and
gave other assistance.

Design and implementation of Expect was paid for by the U.S. government
and is therefore in the public domain.  However, the author and
@sc{nist} would like credit if this program and documentation or
portions of them are used.
