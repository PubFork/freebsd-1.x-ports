This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Outline Format,  Next: Outline Motion,  Up: Outline Mode

Format of Outlines
------------------

   Outline mode assumes that the lines in the buffer are of two types:
"heading lines" and "body lines".  A heading line represents a topic in
the outline.  Heading lines start with one or more stars; the number of
stars determines the depth of the heading in the outline structure.
Thus, a heading line with one star is a major topic; all the heading
lines with two stars between it and the next one-star heading are its
subtopics; and so on.  Any line that is not a heading line is a body
line.  Body lines belong with the preceding heading line.  Here is an
example:

     * Food
     
     This is the body,
     which says something about the topic of food.
     
     ** Delicious Food
     
     This is the body of the second-level header.
     
     ** Distasteful Food
     
     This could have
     a body too, with
     several lines.
     
     *** Dormitory Food
     
     * Shelter
     
     A second first-level topic with its header line.

   A heading line together with all following body lines is called
collectively an "entry".  A heading line together with all following
deeper heading lines and their body lines is called a "subtree".

   You can customize the criterion for distinguishing heading lines by
setting the variable `outline-regexp'.  Any line whose beginning has a
match for this regexp is considered a heading line.  Matches that start
within a line (not at the beginning) do not count.  The length of the
matching text determines the level of the heading; longer matches make
a more deeply nested level.  Thus, for example, if a text formatter has
commands `@chapter', `@section' and `@subsection' to divide the
document into chapters and sections, you could make those lines count
as heading lines by setting `outline-regexp' to
`"@chap\\|@\\(sub\\)*section"'.  Note the trick: the two words
`chapter' and `section' are equally long, but by defining the regexp to
match only `chap' we ensure that the length of the text matched on a
chapter heading is shorter, so that Outline mode will know that
sections are contained in chapters.  This works as long as no other
command starts with `@chap'.

   Outline mode makes a line invisible by changing the newline before it
into an ASCII control-M (code 015).  Most editing commands that work on
lines treat an invisible line as part of the previous line because,
strictly speaking, it *is* part of that line, since there is no longer a
newline in between.  When you save the file in Outline mode, control-M
characters are saved as newlines, so the invisible lines become ordinary
lines in the file.  But saving does not change the visibility status of
a line inside Emacs.


File: emacs,  Node: Outline Motion,  Next: Outline Visibility,  Prev: Outline Format,  Up: Outline Mode

Outline Motion Commands
-----------------------

   There are some special motion commands in Outline mode that move
backward and forward to heading lines.

`C-c C-n'
     Move point to the next visible heading line
     (`outline-next-visible-heading').

`C-c C-p'
     Move point to the previous visible heading line
     (`outline-previous-visible-heading').

`C-c C-f'
     Move point to the next visible heading line at the same level as
     the one point is on (`outline-forward-same-level').

`C-c C-b'
     Move point to the previous visible heading line at the same level
     (`outline-backward-same-level').

`C-c C-u'
     Move point up to a lower-level (more inclusive) visible heading
     line (`outline-up-heading').

   `C-c C-n' (`next-visible-heading') moves down to the next heading
line.  `C-c C-p' (`previous-visible-heading') moves similarly backward.
Both accept numeric arguments as repeat counts.  The names emphasize
that invisible headings are skipped, but this is not really a special
feature.  All editing commands that look for lines ignore the invisible
lines automatically.

   More powerful motion commands understand the level structure of
headings.  `C-c C-f' (`outline-forward-same-level') and `C-c C-b'
(`outline-backward-same-level') move from one heading line to another
visible heading at the same depth in the outline.  `C-c C-u'
(`outline-up-heading') moves backward to another heading that is less
deeply nested.


File: emacs,  Node: Outline Visibility,  Prev: Outline Motion,  Up: Outline Mode

Outline Visibility Commands
---------------------------

   The other special commands of outline mode are used to make lines
visible or invisible.  Their names all start with `hide' or `show'.
Most of them fall into pairs of opposites.  They are not undoable;
instead, you can undo right past them.  Making lines visible or
invisible is simply not recorded by the undo mechanism.

`M-x hide-body'
     Make all body lines in the buffer invisible.

`M-x show-all'
     Make all lines in the buffer visible.

`C-c C-h'
     Make everything under this heading invisible, not including this
     heading itself
     (`hide-subtree').

`C-c C-s'
     Make everything under this heading visible, including body,
     subheadings, and their bodies (`show-subtree').

`M-x hide-leaves'
     Make the body of this heading line, and of all its subheadings,
     invisible.

`M-x show-branches'
     Make all subheadings of this heading line, at all levels, visible.

`C-c C-i'
     Make immediate subheadings (one level down) of this heading line
     visible (`show-children').

`M-x hide-entry'
     Make this heading line's body invisible.

`M-x show-entry'
     Make this heading line's body visible.

   Two commands that are exact opposites are `M-x hide-entry' and `M-x
show-entry'.  They are used with point on a heading line, and apply
only to the body lines of that heading.  The subtopics and their bodies
are not affected.

   Two more powerful opposites are `C-c C-h' (`hide-subtree') and `C-c
C-s' (`show-subtree').  Both expect to be used when point is on a
heading line, and both apply to all the lines of that heading's
"subtree": its body, all its subheadings, both direct and indirect, and
all of their bodies.  In other words, the subtree contains everything
following this heading line, up to and not including the next heading of
the same or higher rank.

   Intermediate between a visible subtree and an invisible one is having
all the subheadings visible but none of the body.  There are two
commands for doing this, depending on whether you want to hide the
bodies or make the subheadings visible.  They are `M-x hide-leaves' and
`M-x show-branches'.

   A little weaker than `show-branches' is `C-c C-i' (`show-children').
It makes just the direct subheadings visible--those one level down.
Deeper subheadings remain invisible, if they were invisible.

   Two commands have a blanket effect on the whole file.  `M-x
hide-body' makes all body lines invisible, so that you see just the
outline structure.  `M-x show-all' makes all lines visible.  These
commands can be thought of as a pair of opposites even though `M-x
show-all' applies to more than just body lines.

   You can turn off the use of ellipses at the ends of visible lines by
setting `selective-display-ellipses' to `nil'.  Then there is no
visible indication of the presence of invisible lines.


File: emacs,  Node: TeX Mode,  Next: Nroff Mode,  Prev: Outline Mode,  Up: Text

TeX Mode
========

   TeX is a powerful text formatter written by Donald Knuth; it is also
free, like GNU Emacs.  LaTeX is a simplified input format for TeX,
implemented by TeX macros; it comes with TeX.  SliTeX is a special form
of LaTeX.

   Emacs has a special TeX mode for editing TeX input files.  It
provides facilities for checking the balance of delimiters and for
invoking TeX on all or part of the file.

   TeX mode has three variants, Plain TeX mode, LaTeX mode, and SliTeX
mode (these three distinct major modes differ only slightly).  They are
designed for editing the three different formats.  The command `M-x
tex-mode' looks at the contents of the buffer to determine whether the
contents appear to be either LaTeX input or SliTeX input; it then
selects the appropriate mode.  If it can't tell which is right (e.g.,
the buffer is empty), the variable `tex-default-mode' controls which
mode is used.

   When `M-x tex-mode' does not guess right, you can use the commands
`M-x plain-tex-mode', `M-x latex-mode', and `M-x slitex-mode' to select
explicitly the particular variants of TeX mode.

* Menu:

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.
* Getting: TeX Distrib.   Getting the latest Unix TeX distribution.


File: emacs,  Node: TeX Editing,  Next: LaTeX Editing,  Up: TeX Mode

TeX Editing Commands
--------------------

   Here are the special commands provided in TeX mode for editing the
text of the file.

`"'
     Insert, according to context, either ```' or `"' or `'''
     (`tex-insert-quote').

`LFD'
     Insert a paragraph break (two newlines) and check the previous
     paragraph for unbalanced braces or dollar signs
     (`tex-terminate-paragraph').

`M-x validate-tex-region'
     Check each paragraph in the region for unbalanced braces or dollar
     signs.

`C-c {'
     Insert `{}' and position point between them (`tex-insert-braces').

`C-c }'
     Move forward past the next unmatched close brace (`up-list').

   In TeX, the character `"' is not normally used; we use ```' to start
a quotation and `''' to end one.  To make editing easier under this
formatting convention, TeX mode overrides the normal meaning of the key
`"' with a command that inserts a pair of single-quotes or backquotes
(`tex-insert-quote').  To be precise, this command inserts ```' after
whitespace or an open brace, `"' after a backslash, and `''' after any
other character.

   If you need the character `"' itself in unusual contexts, use `C-q'
to insert it.  Also, `"' with a numeric argument always inserts that
number of `"' characters.

   In TeX mode, `$' has a special syntax code which attempts to
understand the way TeX math mode delimiters match.  When you insert a
`$' that is meant to exit math mode, the position of the matching `$'
that entered math mode is displayed for a second.  This is the same
feature that displays the open brace that matches a close brace that is
inserted.  However, there is no way to tell whether a `$' enters math
mode or leaves it; so when you insert a `$' that enters math mode, the
previous `$' position is shown as if it were a match, even though they
are actually unrelated.

   TeX uses braces as delimiters that must match.  Some users prefer to
keep braces balanced at all times, rather than inserting them singly.
Use `C-c {' (`tex-insert-braces') to insert a pair of braces.  It
leaves point between the two braces so you can insert the text that
belongs inside.  Afterward, use the command `C-c }' (`up-list') to move
forward past the close brace.

   There are two commands for checking the matching of braces.  LFD
(`tex-terminate-paragraph') checks the paragraph before point, and
inserts two newlines to start a new paragraph.  It prints a message in
the echo area if any mismatch is found.  `M-x validate-tex-region'
checks a region, paragraph by paragraph.  When it finds a paragraph that
contains a mismatch, it displays point at the beginning of the paragraph
for a few seconds and pushes a mark at that spot.  Scanning continues
until the whole buffer has been checked or until you type another key.
The positions of the last several paragraphs with mismatches can be
found in the mark ring (*note Mark Ring::.).

   Note that Emacs commands count square brackets and parentheses in
TeX mode, not just braces.  This is not strictly correct for the
purpose of checking TeX syntax.  However, parentheses and square
brackets are likely to be used in text as matching delimiters and it is
useful for the various motion commands and automatic match display to
work with them.


File: emacs,  Node: LaTeX Editing,  Next: TeX Print,  Prev: TeX Editing,  Up: TeX Mode

LaTeX Editing Commands
----------------------

   LaTeX mode provides a few extra features not applicable to plain TeX.

`C-c C-o'
     Insert `\begin' and `\end' for LaTeX block and position point on a
     line between them. (`tex-latex-block').

`C-c C-e'
     Close the last unended block for LaTeX (`tex-close-latex-block').

   In LaTeX input, `\begin' and `\end' commands are used to group
blocks of text.  To insert a `\begin' and a matching `\end' (on a new
line following the `\begin'), use `C-c C-o' (`tex-latex-block').  A
blank line is inserted between the two, and point is left there.

   Emacs knows all of the standard LaTeX block names and will
permissively complete a partially entered block name (*note
Completion::.).  You can add your own list of block names to those
known by Emacs with the variable `latex-block-names'.  For example, to
add `theorem', `corollary', and `proof', include the line

     (setq latex-block-names '("theorem" "corollary" "proof"))

to your `.emacs' file.

   In LaTeX input, `\begin' and `\end' commands must balance.  You can
use `C-c C-e' (`tex-close-latex-block') to insert automatically a
matching `\end' to match the last unmatched `\begin'.  The `\end' will
be indented to match the corresponding `\begin'.  The `\end' will be
followed by a newline if point is at the beginning of a line.


File: emacs,  Node: TeX Print,  Next: TeX Distrib,  Prev: LaTeX Editing,  Up: TeX Mode

TeX Printing Commands
---------------------

   You can invoke TeX as an inferior of Emacs on either the entire
contents of the buffer or just a region at a time.  Running TeX in this
way on just one chapter is a good way to see what your changes look
like without taking the time to format the entire file.

`C-c C-r'
     Invoke TeX on the current region, together with the buffer's header
     (`tex-region').

`C-c C-b'
     Invoke TeX on the entire current buffer (`tex-buffer').

`C-c TAB'
     Invoke BibTeX on the current file (`tex-bibtex-file').

`C-c C-f'
     Invoke TeX on the current file (`tex-file').

`C-c C-l'
     Recenter the window showing output from the inferior TeX so that
     the last line can be seen (`tex-recenter-output-buffer').

`C-c C-k'
     Kill the TeX subprocess (`tex-kill-job').

`C-c C-p'
     Print the output from the last `C-c C-r', `C-c C-b', or `C-c C-f'
     command (`tex-print').

`C-c C-v'
     Preview the output from the last `C-c C-r', `C-c C-b', or `C-c
     C-f' command (`tex-view').

`C-c C-q'
     Show the printer queue (`tex-show-print-queue').

   You can pass the current buffer through an inferior TeX by means of
`C-c C-b' (`tex-buffer').  The formatted output appears in a temporary;
to print it, type `C-c C-p' (`tex-print').  Afterward use `C-c C-q'
(`tex-show-print-queue') to view the progress of your output towards
being printed. If your terminal has the ability to display TeX output
files, you can preview the output on the terminal with `C-c C-v'
(`tex-view').

   You can specify the directory to use for running TeX by setting the
variable `tex-directory'.  `"."' is the default value.  If your
environment variable `TEXINPUTS' contains relative directory names, or
if your files contains `\input' commands with relative file names, then
`tex-directory' *must* be `"."' or you will get the wrong results.
Otherwise, it is safe to specify some other directory, such as `/tmp'.

   If you want to specify which shell commands are used in the inferior
TeX, you can do so by setting the values of the variables
`tex-run-command', `latex-run-command', `slitex-run-command',
`tex-dvi-print-command', `tex-dvi-view-command', and
`tex-show-queue-command'.  You *must* set the value of
`tex-dvi-view-command' for your particular terminal; this variable has
no default value.  The other variables have default values that may (or
may not) be appropriate for your system.

   Normally, the file name given to these commands comes at the end of
the command string; for example, `latex FILENAME'.  In some cases,
however, the file name needs to be embedded in the command; an example
is when you need to provide the file name as an argument to one command
whose output is piped to another.  You can specify where to put the
file name with `*' in the command string.  For example,

     (setq tex-dvi-print-command "dvips -f * | lpr")

   The terminal output from TeX, including any error messages, appears
in a buffer called `*tex-shell*'.  If TeX gets an error, you can switch
to this buffer and feed it input (this works as in Shell mode; *note
Interactive Shell::.).  Without switching to this buffer you can scroll
it so that its last line is visible by typing `C-c C-l'.

   Type `C-c C-k' (`tex-kill-job') to kill the TeX process if you see
that its output is no longer useful.  Using `C-c C-b' or `C-c C-r' also
kills any TeX process still running.

   You can also pass an arbitrary region through an inferior TeX by
typing `C-c C-r' (`tex-region').  This is tricky, however, because most
files of TeX input contain commands at the beginning to set parameters
and define macros, without which no later part of the file will format
correctly.  To solve this problem, `C-c C-r' allows you to designate a
part of the file as containing essential commands; it is included before
the specified region as part of the input to TeX.  The designated part
of the file is called the "header".

   To indicate the bounds of the header in Plain TeX mode, you insert
two special strings in the file.  Insert `%**start of header' before the
header, and `%**end of header' after it.  Each string must appear
entirely on one line, but there may be other text on the line before or
after.  The lines containing the two strings are included in the header.
If `%**start of header' does not appear within the first 100 lines of
the buffer, `C-c C-r' assumes that there is no header.

   In LaTeX mode, the header begins with `\documentstyle' and ends with
`\begin{document}'.  These are commands that LaTeX requires you to use
in any case, so nothing special needs to be done to identify the header.

   The commands (`tex-buffer') and (`tex-region') do all of their work
in a temporary directory, and do not have available any of the auxiliary
files needed by TeX for cross-references; these commands are generally
not suitable for running the final copy in which all of the
cross-references need to be correct.  When you want the auxiliary
files, use `C-c C-f' (`tex-file') which runs TeX on the current
buffer's file, in that file's directory.  Before TeX runs, you will be
asked about saving any modified buffers.  Generally, you need to use
(`tex-file') twice to get cross-references correct.

   For LaTeX files, you can use BibTeX to process the auxiliary file
for the current buffer's file.  BibTeX looks up bibliographic citations
in a data base and prepares the cited references for the bibliography
section.  The command `C-c TAB' (`tex-bibtex-file') runs the shell
command (`tex-bibtex-command') to produce a `.bbl' file for the current
buffer's file.  Generally, you need to do `C-c C-f' (`tex-file') once
to generate the `.aux' file, then do `C-c TAB' (`tex-bibtex-file'), and
then repeat `C-c C-f' (`tex-file') twice more to get the
cross-references correct.

   Entering any kind of TeX mode runs the hooks `text-mode-hook' and
`tex-mode-hook'.  Then it runs either `plain-tex-mode-hook' or
`latex-mode-hook', whichever is appropriate.  For SliTeX files, it
calls `slitex-mode-hook'.  Starting the TeX shell runs the hook
`tex-shell-hook'.  *Note Hooks::.


File: emacs,  Node: TeX Distrib,  Prev: TeX Print,  Up: TeX Mode

Unix TeX Distribution
---------------------

   TeX for Unix systems can be obtained from the University of
Washington for a distribution fee.

   To order a full distribution, send $200.00 for a 1/2-inch 9-track
1600 bpi (tar or cpio) tape reel, or $210.00 for a 1/4-inch 4-track
QIC-24 (tar or cpio) cartridge, payable to the University of Washington
to:

     Northwest Computing Support Center
     DR-10, Thomson Hall 35
     University of Washington
     Seattle, Washington 98195

Purchase orders are acceptable, but there is an extra charge of $10.00,
to pay for processing charges.

For overseas orders please add $20.00 to the base cost for shipment via
air parcel post, or $30.00 for shipment via courier.

   The normal distribution is a tar tape, blocked 20, 1600 bpi, on an
industry standard 2400 foot half-inch reel.  The physical format for
the 1/4 inch streamer cartridges uses QIC-11, 8000 bpi, 4-track
serpentine recording for the SUN.  Also, System V tapes can be written
in cpio format, blocked 5120 bytes, ASCII headers.


File: emacs,  Node: Nroff Mode,  Prev: TeX Mode,  Up: Text

Nroff Mode
==========

   Nroff mode is a mode like Text mode but modified to handle nroff
commands present in the text.  Invoke `M-x nroff-mode' to enter this
mode.  It differs from Text mode in only a few ways.  All nroff command
lines are considered paragraph separators, so that filling will never
garble the nroff commands.  Pages are separated by `.bp' commands.
Comments start with backslash-doublequote.  Also, three special
commands are provided that are not in Text mode:

`M-n'
     Move to the beginning of the next line that isn't an nroff command
     (`forward-text-line').  An argument is a repeat count.

`M-p'
     Like `M-n' but move up (`backward-text-line').

`M-?'
     Prints in the echo area the number of text lines (lines that are
     not nroff commands) in the region (`count-text-lines').

   The other feature of Nroff mode is that you can turn on Electric
Nroff mode.  This is a minor mode that you can turn on or off with `M-x
electric-nroff-mode' (*note Minor Modes::.).  When the mode is on, each
time you use RET to end a line that contains an nroff command that
opens a kind of grouping, the matching nroff command to close that
grouping is automatically inserted on the following line.  For example,
if you are at the beginning of a line and type `. ( b RET', this
inserts the matching command `.)b' on a new line following point.

   Entering Nroff mode runs the hook `text-mode-hook', followed by the
hook `nroff-mode-hook' (*note Hooks::.).


File: emacs,  Node: Programs,  Next: Building,  Prev: Text,  Up: Top

Editing Programs
****************

   Emacs has many commands designed to understand the syntax of
programming languages such as Lisp and C.  These commands can

   * Move over or kill balanced expressions or "sexps" (*note Lists::.).

   * Move over or mark top-level expressions--"defuns", in Lisp;
     functions, in C (*note Defuns::.).

   * Show how parentheses balance (*note Matching::.).

   * Insert, kill or align comments (*note Comments::.).

   * Follow the usual indentation conventions of the language (*note
     Program Indent::.).

   The commands for words, sentences and paragraphs are very useful in
editing code even though their canonical application is for editing
human language text.  Most symbols contain words (*note Words::.);
sentences can be found in strings and comments (*note Sentences::.).
Paragraphs per se don't exist in code, but the paragraph commands are
useful anyway, because programming language major modes define
paragraphs to begin and end at blank lines (*note Paragraphs::.).
Judicious use of blank lines to make the program clearer will also
provide interesting chunks of text for the paragraph commands to work
on.

   The selective display feature is useful for looking at the overall
structure of a function (*note Selective Display::.).  This feature
causes only the lines that are indented less than a specified amount to
appear on the screen.

* Menu:

* Program Modes::     Major modes for editing programs.
* Lists::             Expressions with balanced parentheses.
* List Commands::     The commands for working with list and sexps.
* Defuns::            Each program is made up of separate functions.
                        There are editing commands to operate on them.
* Program Indent::    Adjusting indentation to show the nesting.
* Matching::          Insertion of a close-delimiter flashes matching open.
* Comments::          Inserting, killing, and aligning comments.
* Balanced Editing::  Inserting two matching parentheses at once, etc.
* Symbol Completion:: Completion on symbol names of your program or language.
* Documentation::     Getting documentation of functions you plan to call.
* Change Log::        Maintaining a change history for your program.
* Tags::              Go direct to any function in your program in one
                        command.  Tags remembers which file it is in.
* Emerge::	      A convenient way of merging two versions of a program.
* C Mode::	      Special commands of C mode (and C++ mode).
* Fortran::	      Fortran mode and its special features.
* Asm Mode::	      Asm mode and its special features.


File: emacs,  Node: Program Modes,  Next: Lists,  Up: Programs

Major Modes for Programming Languages
=====================================

   Emacs also has major modes for the programming languages Lisp, Scheme
(a variant of Lisp), Awk, C, C++, Perl, Icon, Fortran and Muddle
(another variant of Lisp).  There is also a major mode for makefiles,
called Makefile mode.

   Ideally, a major mode should be implemented for each programming
language that you might want to edit with Emacs; but often the mode for
one language can serve for other syntactically similar languages.  The
language modes that exist are those that someone decided to take the
trouble to write.

   There are several forms of Lisp mode, which differ in the way they
interface to Lisp execution.  *Note Executing Lisp::.

   Each of the programming language modes defines the TAB key to run an
indentation function that knows the indentation conventions of that
language and updates the current line's indentation accordingly.  For
example, in C mode TAB is bound to `c-indent-line'.  LFD is normally
defined to do RET followed by TAB; thus, it too indents in a
mode-specific fashion.

   In most programming languages, indentation is likely to vary from
line to line.  So the major modes for those languages rebind DEL to
treat a tab as if it were the equivalent number of spaces (using the
command `backward-delete-char-untabify').  This makes it possible to
rub out indentation one column at a time without worrying whether it is
made up of spaces or tabs.  Use `C-b C-d' to delete a tab character
before point, in these modes.

   Programming language modes define paragraphs to be separated only by
blank lines, so that the paragraph commands remain useful.  Auto Fill
mode, if enabled in a programming language major mode, indents the new
lines which it creates.

   Turning on a major mode runs a normal hook called the "mode hook",
which is the value of a Lisp variable.  For example, turning on C mode
runs the hook `c-mode-hook'.  Mode hook variables for other programming
language modes include `lisp-mode-hook', `emacs-lisp-mode-hook',
`lisp-interaction-mode-hook', `scheme-mode-hook' and
`muddle-mode-hook'.  *Note Hooks::.


File: emacs,  Node: Lists,  Next: List Commands,  Prev: Program Modes,  Up: Programs

Lists and Sexps
===============

   By convention, Emacs keys for dealing with balanced expressions are
usually Control-Meta characters.  They tend to be analogous in function
to their Control and Meta equivalents.  These commands are usually
thought of as pertaining to expressions in programming languages, but
can be useful with any language in which some sort of parentheses exist
(including human languages).

   These commands fall into two classes.  Some deal only with "lists"
(parenthetical groupings).  They see nothing except parentheses,
brackets, braces (whichever ones must balance in the language you are
working with), and escape characters that might be used to quote those.

   The other commands deal with expressions or "sexps".  The word `sexp'
is derived from "s-expression", the ancient term for an expression in
Lisp.  But in Emacs, the notion of `sexp' is not limited to Lisp.  It
refers to an expression in whatever language your program is written in.
Each programming language has its own major mode, which customizes the
syntax tables so that expressions in that language count as sexps.

   Sexps typically include symbols, numbers, and string constants, as
well as anything contained in parentheses, brackets or braces.

   In languages that use prefix and infix operators, such as C, it is
not possible for all expressions to be sexps.  For example, C mode does
not recognize `foo + bar' as a sexp, even though it *is* a C expression;
it recognizes `foo' as one sexp and `bar' as another, with the `+' as
punctuation between them.  This is a fundamental ambiguity: both `foo +
bar' and `foo' are legitimate choices for the sexp to move over if
point is at the `f'.  Note that `(foo + bar)' is a single sexp in C
mode.

   Some languages have obscure forms of syntax for expressions that
nobody has bothered to make Emacs understand properly.


File: emacs,  Node: List Commands,  Next: Defuns,  Prev: Lists,  Up: Programs

List And Sexp Commands
======================

`C-M-f'
     Move forward over a sexp (`forward-sexp').

`C-M-b'
     Move backward over a sexp (`backward-sexp').

`C-M-k'
     Kill sexp forward (`kill-sexp').

`C-M-u'
     Move up and backward in list structure (`backward-up-list').

`C-M-d'
     Move down and forward in list structure (`down-list').

`C-M-n'
     Move forward over a list (`forward-list').

`C-M-p'
     Move backward over a list (`backward-list').

`C-M-t'
     Transpose expressions (`transpose-sexps').

`C-M-@'
     Put mark after following expression (`mark-sexp').

   To move forward over a sexp, use `C-M-f' (`forward-sexp').  If the
first significant character after point is an opening delimiter (`(' in
Lisp; `(', `[' or `{' in C), `C-M-f' moves past the matching closing
delimiter.  If the character begins a symbol, string, or number,
`C-M-f' moves over that.

   The command `C-M-b' (`backward-sexp') moves backward over a sexp.
The detailed rules are like those above for `C-M-f', but with
directions reversed.  If there are any prefix characters (single-quote,
backquote and comma, in Lisp) preceding the sexp, `C-M-b' moves back
over them as well.  The sexp commands move across comments as if they
were whitespace in most modes.

   `C-M-f' or `C-M-b' with an argument repeats that operation the
specified number of times; with a negative argument, it moves in the
opposite direction.

   Killing a sexp at a time can be done with `C-M-k' (`kill-sexp').
`C-M-k' kills the characters that `C-M-f' would move over.

   The "list commands" move over lists like the sexp commands but skip
blithely over any number of other kinds of sexps (symbols, strings,
etc).  They are `C-M-n' (`forward-list') and `C-M-p' (`backward-list').
The main reason they are useful is that they usually ignore comments
(since the comments usually do not contain any lists).

   `C-M-n' and `C-M-p' stay at the same level in parentheses, when
that's possible.  To move *up* one (or N) levels, use `C-M-u'
(`backward-up-list').  `C-M-u' moves backward up past one unmatched
opening delimiter.  A positive argument serves as a repeat count; a
negative argument reverses direction of motion and also requests
repetition, so it moves forward and up one or more levels.

   To move *down* in list structure, use `C-M-d' (`down-list').  In
Lisp mode, where `(' is the only opening delimiter, this is nearly the
same as searching for a `('.  An argument specifies the number of levels
of parentheses to go down.

   A somewhat random-sounding command which is nevertheless handy is
`C-M-t' (`transpose-sexps'), which drags the previous sexp across the
next one.  An argument serves as a repeat count, and a negative
argument drags backwards (thus canceling out the effect of `C-M-t' with
a positive argument).  An argument of zero, rather than doing nothing,
transposes the sexps ending after point and the mark.

   To make the region be the next sexp in the buffer, use `C-M-@'
(`mark-sexp') which sets mark at the same place that `C-M-f' would move
to.  `C-M-@' takes arguments like `C-M-f'.  In particular, a negative
argument is useful for putting the mark at the beginning of the
previous sexp.

   The list and sexp commands' understanding of syntax is completely
controlled by the syntax table.  Any character can, for example, be
declared to be an opening delimiter and act like an open parenthesis.
*Note Syntax::.


File: emacs,  Node: Defuns,  Next: Program Indent,  Prev: List Commands,  Up: Programs

Defuns
======

   In Emacs, a parenthetical grouping at the top level in the buffer is
called a "defun".  The name derives from the fact that most top-level
lists in a Lisp file are instances of the special form `defun', but any
top-level parenthetical grouping counts as a defun in Emacs parlance
regardless of what its contents are, and regardless of the programming
language in use.  For example, in C, the body of a function definition
is a defun.

`C-M-a'
     Move to beginning of current or preceding defun
     (`beginning-of-defun').

`C-M-e'
     Move to end of current or following defun (`end-of-defun').

`C-M-h'
     Put region around whole current or following defun (`mark-defun').

   The commands to move to the beginning and end of the current defun
are `C-M-a' (`beginning-of-defun') and `C-M-e' (`end-of-defun').

   If you wish to operate on the current defun, use `C-M-h'
(`mark-defun') which puts point at the beginning and mark at the end of
the current or next defun.  For example, this is the easiest way to get
ready to move the defun to a different place in the text.  In C mode,
`C-M-h' runs the function `mark-c-function', which is almost the same
as `mark-defun'; the difference is that it backs up over the argument
declarations, function name and returned data type so that the entire C
function is inside the region.  *Note Marking Objects::.

   Emacs assumes that any open-parenthesis found in the leftmost column
is the start of a defun.  Therefore, *never put an open-parenthesis at
the left margin in a Lisp file unless it is the start of a top level
list.  Never put an open-brace or other opening delimiter at the
beginning of a line of C code unless it starts the body of a function.*
The most likely problem case is when you want an opening delimiter at
the start of a line inside a string.  To avoid trouble, put an escape
character (`\', in C and Emacs Lisp, `/' in some other Lisp dialects)
before the opening delimiter.  It will not affect the contents of the
string.

   In the remotest past, the original Emacs found defuns by moving
upward a level of parentheses until there were no more levels to go up.
This always required scanning all the way back to the beginning of the
buffer, even for a small function.  To speed up the operation, Emacs
was changed to assume that any `(' (or other character assigned the
syntactic class of opening-delimiter) at the left margin is the start
of a defun.  This heuristic is nearly always right and avoids the
costly scan; however, it mandates the convention described above.


File: emacs,  Node: Program Indent,  Next: Matching,  Prev: Defuns,  Up: Programs

Indentation for Programs
========================

   The best way to keep a program properly indented is to use Emacs to
re-indent it as you change it.  Emacs has commands to indent properly
either a single line, a specified number of lines, or all of the lines
inside a single parenthetical grouping.

* Menu:

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Choosing an indentation style for C code.


File: emacs,  Node: Basic Indent,  Next: Multi-line Indent,  Up: Program Indent

Basic Program Indentation Commands
----------------------------------

`TAB'
     Adjust indentation of current line.

`LFD'
     Equivalent to RET followed by TAB (`newline-and-indent').

   The basic indentation command is TAB, which gives the current line
the correct indentation as determined from the previous lines.  The
function that TAB runs depends on the major mode; it is
`lisp-indent-line' in Lisp mode, `c-indent-line' in C mode, etc.  These
functions understand different syntaxes for different languages, but
they all do about the same thing.  TAB in any programming language
major mode inserts or deletes whitespace at the beginning of the
current line, independent of where point is in the line.  If point is
inside the whitespace at the beginning of the line, TAB leaves it at
the end of that whitespace; otherwise, TAB leaves point fixed with
respect to the characters around it.

   Use `C-q TAB' to insert a tab at point.

   When entering a large amount of new code, use LFD
(`newline-and-indent'), which is equivalent to a RET followed by a TAB.
LFD creates a blank line, and then gives it the appropriate
indentation.

   TAB indents the second and following lines of the body of a
parenthetical grouping each under the preceding one; therefore, if you
alter one line's indentation to be nonstandard, the lines below will
tend to follow it.  This is the right behavior in cases where the
standard result of TAB is unaesthetic.

   Remember that an open-parenthesis, open-brace or other opening
delimiter at the left margin is assumed by Emacs (including the
indentation routines) to be the start of a function.  Therefore, you
must never have an opening delimiter in column zero that is not the
beginning of a function, not even inside a string.  This restriction is
vital for making the indentation commands fast; you must simply accept
it.  *Note Defuns::, for more information on this.


File: emacs,  Node: Multi-line Indent,  Next: Lisp Indent,  Prev: Basic Indent,  Up: Program Indent

Indenting Several Lines
-----------------------

   When you wish to re-indent several lines of code which have been
altered or moved to a different level in the list structure, you have
several commands available.

`C-M-q'
     Re-indent all the lines within one list (`indent-sexp').

`C-u TAB'
     Shift an entire list rigidly sideways so that its first line is
     properly indented.

`C-M-\'
     Re-indent all lines in the region (`indent-region').

   You can re-indent the contents of a single list by positioning point
before the beginning of it and typing `C-M-q' (`indent-sexp' in Lisp
mode, `indent-c-exp' in C mode; also bound to other suitable commands
in other modes).  The indentation of the line the sexp starts on is not
changed; therefore, only the relative indentation within the list, and
not its position, is changed.  To correct the position as well, type a
TAB before the `C-M-q'.

   If the relative indentation within a list is correct but the
indentation of its beginning is not, go to the line the list begins on
and type `C-u TAB'.  When TAB is given a numeric argument, it moves all
the lines in the grouping starting on the current line sideways the
same amount that the current line moves.  It is clever, though, and
does not move lines that start inside strings, or C preprocessor lines
when in C mode.

   Another way to specify the range to be re-indented is with point and
mark.  The command `C-M-\' (`indent-region') applies TAB to every line
whose first character is between point and mark.


File: emacs,  Node: Lisp Indent,  Next: C Indent,  Prev: Multi-line Indent,  Up: Program Indent

Customizing Lisp Indentation
----------------------------

   The indentation pattern for a Lisp expression can depend on the
function called by the expression.  For each Lisp function, you can
choose among several predefined patterns of indentation, or define an
arbitrary one with a Lisp program.

   The standard pattern of indentation is as follows: the second line
of the expression is indented under the first argument, if that is on
the same line as the beginning of the expression; otherwise, the second
line is indented underneath the function name.  Each following line is
indented under the previous line whose nesting depth is the same.

   If the variable `lisp-indent-offset' is non-`nil', it overrides the
usual indentation pattern for the second line of an expression, so that
such lines are always indented `lisp-indent-offset' more columns than
the containing list.

   The standard pattern is overridden for certain functions.  Functions
whose names start with `def' always indent the second line by
`lisp-body-indent' extra columns beyond the open-parenthesis starting
the expression.

   The standard pattern can be overridden in various ways for individual
functions, according to the `lisp-indent-hook' property of the function
name.  There are four possibilities for this property:

`nil'
     This is the same as no property; the standard indentation pattern
     is used.

`defun'
     The pattern used for function names that start with `def' is used
     for this function also.

a number, NUMBER
     The first NUMBER arguments of the function are "distinguished"
     arguments; the rest are considered the "body" of the expression.
     A line in the expression is indented according to whether the
     first argument on it is distinguished or not.  If the argument is
     part of the body, the line is indented `lisp-body-indent' more
     columns than the open-parenthesis starting the containing
     expression.  If the argument is distinguished and is either the
     first or second argument, it is indented *twice* that many extra
     columns.  If the argument is distinguished and not the first or
     second argument, the standard pattern is followed for that line.

a symbol, SYMBOL
     SYMBOL should be a function name; that function is called to
     calculate the indentation of a line within this expression.  The
     function receives two arguments:
    STATE
          The value returned by `parse-partial-sexp' (a Lisp primitive
          for indentation and nesting computation) when it parses up to
          the beginning of this line.

    POS
          The position at which the line being indented begins.

     It should return either a number, which is the number of columns of
     indentation for that line, or a list whose car is such a number.
     The difference between returning a number and returning a list is
     that a number says that all following lines at the same nesting
     level should be indented just like this one; a list says that
     following lines might call for different indentations.  This makes
     a difference when the indentation is being computed by `C-M-q'; if
     the value is a number, `C-M-q' need not recalculate indentation
     for the following lines until the end of the list.


File: emacs,  Node: C Indent,  Prev: Lisp Indent,  Up: Program Indent

Customizing C Indentation
-------------------------

   Two variables control which commands perform C indentation and when.

   If `c-auto-newline' is non-`nil', newlines are inserted both before
and after braces that you insert, and after colons and semicolons.
Correct C indentation is done on all the lines that are made this way.

   If `c-tab-always-indent' is `nil', the TAB command in C mode does
indentation only if point is at the left margin or within the line's
indentation.  If there is non-whitespace to the left of point, then TAB
just inserts a tab character in the buffer.  Normally, this variable is
`t', and TAB always reindents the current line.  The default behavior
means that to insert a real tab character you must quote it by typing
`C-q' TAB.

   C does not have anything analogous to particular function names for
which special forms of indentation are desirable.  However, it has a
different need for customization facilities: many different styles of C
indentation are in common use.

   There are six variables you can set to control the style that Emacs C
mode uses.

`c-indent-level'
     Indentation of C statements within surrounding block.  The
     surrounding block's indentation is the indentation of the line on
     which the open-brace appears.

`c-continued-statement-offset'
     Extra indentation given to a substatement, such as the then-clause
     of an if or body of a while.

`c-brace-offset'
     Extra indentation for line if it starts with an open brace.

`c-brace-imaginary-offset'
     An open brace following other text is treated as if it were this
     far to the right of the start of its line.

`c-argdecl-indent'
     Indentation level of declarations of C function arguments.

`c-label-offset'
     Extra indentation for line that is a label, or case or default.

   The variable `c-indent-level' controls the indentation for C
statements with respect to the surrounding block.  In the example

         {
           foo ();

the difference in indentation between the lines is `c-indent-level'.
Its standard value is 2.

   If the open-brace beginning the compound statement is not at the
beginning of its line, the `c-indent-level' is added to the indentation
of the line, not the column of the open-brace.  For example,

     if (losing) {
       do_this ();

One popular indentation style is that which results from setting
`c-indent-level' to 8 and putting open-braces at the end of a line in
this way.  I prefer to put the open-brace on a separate line.

   In fact, the value of the variable `c-brace-imaginary-offset' is
also added to the indentation of such a statement.  Normally this
variable is zero.  Think of this variable as the imaginary position of
the open brace, relative to the first nonblank character on the line.
By setting this variable to 4 and `c-indent-level' to 0, you can get
this style:

     if (x == y) {
         do_it ();
         }

   When `c-indent-level' is zero, the statements inside most braces
will line up right under the open brace.  But there is an exception made
for braces in column zero, such as surrounding a function's body.  The
statements just inside it do not go at column zero.  Instead,
`c-brace-offset' and `c-continued-statement-offset' (see below) are
added to produce a typical offset between brace levels, and the
statements are indented that far.

   `c-continued-statement-offset' controls the extra indentation for a
line that starts within a statement (but not within parentheses or
brackets).  These lines are usually statements that are within other
statements, such as the then-clauses of `if' statements and the bodies
of `while' statements.  This parameter is the difference in indentation
between the two lines in

     if (x == y)
       do_it ();

Its standard value is 2.  Some popular indentation styles correspond to
a value of zero for `c-continued-statement-offset'.

   `c-brace-offset' is the extra indentation given to a line that
starts with an open-brace.  Its standard value is zero; compare

     if (x == y)
       {

with

     if (x == y)
       do_it ();

if `c-brace-offset' were set to 4, the first example would become

     if (x == y)
           {

   `c-argdecl-indent' controls the indentation of declarations of the
arguments of a C function.  It is absolute: argument declarations
receive exactly `c-argdecl-indent' spaces.  The standard value is 5,
resulting in code like this:

     char *
     index (string, c)
          char *string;
          int c;

   `c-label-offset' is the extra indentation given to a line that
contains a label, a case statement, or a `default:' statement.  Its
standard value is -2, resulting in code like this

     switch (c)
       {
       case 'x':

If `c-label-offset' were zero, the same code would be indented as

     switch (c)
       {
         case 'x':

This example assumes that the other variables above also have their
standard values.

   I strongly recommend that you try out the indentation style produced
by the standard settings of these variables, together with putting open
braces on separate lines.  You can see how it looks in all the C source
files of GNU Emacs.

