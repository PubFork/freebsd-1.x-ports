This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Matching,  Next: Comments,  Prev: Program Indent,  Up: Programs

Automatic Display Of Matching Parentheses
=========================================

   The Emacs parenthesis-matching feature is designed to show
automatically how parentheses match in the text.  Whenever you type a
self-inserting character that is a closing delimiter, the cursor moves
momentarily to the location of the matching opening delimiter, provided
that is on the screen.  If it is not on the screen, some text near it is
displayed in the echo area.  Either way, you can tell what grouping is
being closed off.

   In Lisp, automatic matching applies only to parentheses.  In C, it
applies to braces and brackets too.  Emacs knows which characters to
regard as matching delimiters based on the syntax table, which is set
by the major mode.  *Note Syntax::.

   If the opening delimiter and closing delimiter are mismatched--such
as in `[x)'--a warning message is displayed in the echo area.  The
correct matches are specified in the syntax table.

   Two variables control parenthesis match display.
`blink-matching-paren' turns the feature on or off; `nil' turns it off,
but the default is `t' to turn match display on.
`blink-matching-paren-distance' specifies how many characters back to
search to find the matching opening delimiter.  If the match is not
found in that far, scanning stops, and nothing is displayed.  This is
to prevent scanning for the matching delimiter from wasting lots of
time when there is no match.  The default is 12,000.

   When using X Windows, you can request a more powerful kind of
automatic parenthesis matching by loading the `paren' library.  To load
it, type `M-x load-library RET paren RET'.  This library turns off the
usual kind of matching parenthesis display and substitutes another:
whenever point is after a close parenthesis, the close parenthesis and
its matching open parenthesis are both highlighted; otherwise, if point
is before an open parenthesis, the matching close parenthesis is
highlighted.  (There is no need to highlight the open parenthesis after
point because the cursor appears on top of that character.)


File: emacs,  Node: Comments,  Next: Balanced Editing,  Prev: Matching,  Up: Programs

Manipulating Comments
=====================

   The comment commands insert, kill and align comments.

`M-;'
     Insert or align comment (`indent-for-comment').

`C-x ;'
     Set comment column (`set-comment-column').

`C-u - C-x ;'
     Kill comment on current line (`kill-comment').

`M-LFD'
     Like RET followed by inserting and aligning a comment
     (`indent-new-comment-line').

`M-x comment-region'
     Add or remove comment delimiters on all the lines in the region.

   The command that creates a comment is `M-;' (`indent-for-comment').
If there is no comment already on the line, a new comment is created,
aligned at a specific column called the "comment column".  The comment
is created by inserting the string Emacs thinks comments should start
with (the value of `comment-start'; see below).  Point is left after
that string.  If the text of the line extends past the comment column,
then the indentation is done to a suitable boundary (usually, at least
one space is inserted).  If the major mode has specified a string to
terminate comments, that is inserted after point, to keep the syntax
valid.

   `M-;' can also be used to align an existing comment.  If a line
already contains the string that starts comments, then `M-;' just moves
point after it and re-indents it to the conventional place.  Exception:
comments starting in column 0 are not moved.

   Some major modes have special rules for indenting certain kinds of
comments in certain contexts.  For example, in Lisp code, comments which
start with two semicolons are indented as if they were lines of code,
instead of at the comment column.  Comments which start with three
semicolons are supposed to start at the left margin.  Emacs understands
these conventions by indenting a double-semicolon comment using TAB,
and by not changing the indentation of a triple-semicolon comment at
all.

     ;; This function is just an example
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;; And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

   In C code, a comment preceded on its line by nothing but whitespace
is indented like a line of code.

   Even when an existing comment is properly aligned, `M-;' is still
useful for moving directly to the start of the comment.

   `C-u - C-x ;' (`kill-comment') kills the comment on the current line,
if there is one.  The indentation before the start of the comment is
killed as well.  If there does not appear to be a comment in the line,
nothing is done.  To reinsert the comment on another line, move to the
end of that line, do `C-y', and then do `M-;' to realign it.  Note that
`C-u - C-x ;' is not a distinct key; it is `C-x ;'
(`set-comment-column') with a negative argument.  That command is
programmed so that when it receives a negative argument it calls
`kill-comment'.  However, `kill-comment' is a valid command which you
could bind directly to a key if you wanted to.

   The `M-x comment-region' command adds comment delimiters to the
lines that start in the region, thus commenting them out.  With a
negative argument, it does the opposite--it deletes comment delimiters
from the lines in the region.

   With a positive argument, `comment-region' adds comment delimiters
and duplicates the last character of the comment start sequence as many
times as the argument specifies.  Thus, in Lisp mode, `C-u 2 M-x
comment-region' adds `;;' to each line.

   Duplicating the comment delimiter is a way of calling attention to
the comment.  It can also affect how the comment is indented.  In Lisp,
for proper indentation, you should use an argument of two, if between
defuns, and three, if within a defun.

Multiple Lines of Comments
--------------------------

   If you are typing a comment and find that you wish to continue it on
another line, you can use the command `M-LFD'
(`indent-new-comment-line'), which terminates the comment you are
typing, creates a new blank line afterward, and begins a new comment
indented under the old one.  When Auto Fill mode is on, going past the
fill column while typing a comment causes the comment to be continued in
just this fashion.  If point is not at the end of the line when `M-LFD'
is typed, the text on the rest of the line becomes part of the new
comment line.

Options Controlling Comments
----------------------------

   The comment column is stored in the variable `comment-column'.  You
can set it to a number explicitly.  Alternatively, the command `C-x ;'
(`set-comment-column') sets the comment column to the column point is
at.  `C-u C-x ;' sets the comment column to match the last comment
before point in the buffer, and then does a `M-;' to align the current
line's comment under the previous one.  Note that `C-u - C-x ;' runs
the function `kill-comment' as described above.

   The variable `comment-column' is per-buffer: setting the variable in
the normal fashion affects only the current buffer, but there is a
default value which you can change with `setq-default'.  *Note
Locals::.  Many major modes initialize this variable for the current
buffer.

   The comment commands recognize comments based on the regular
expression that is the value of the variable `comment-start-skip'.
This regexp should not match the null string.  It may match more than
the comment starting delimiter in the strictest sense of the word; for
example, in C mode the value of the variable is `"/\\*+ *"', which
matches extra stars and spaces after the `/*' itself.  (Note that `\\'
is needed in Lisp syntax to include a `\' in the string, which is needed
to deny the first star its special meaning in regexp syntax.  *Note
Regexps::.)

   When a comment command makes a new comment, it inserts the value of
`comment-start' to begin it.  The value of `comment-end' is inserted
after point, so that it will follow the text that you will insert into
the comment.  In C mode, `comment-start' has the value `"/* "' and
`comment-end' has the value `" */"'.

   The variable `comment-multi-line' controls how `M-LFD'
(`indent-new-comment-line') behaves when used inside a comment.  If
`comment-multi-line' is `nil', as it normally is, then the comment on
the starting line is terminated and a new comment is started on the new
following line.  If `comment-multi-line' is not `nil', then the new
following line is set up as part of the same comment that was found on
the starting line.  This is done by not inserting a terminator on the
old line, and not inserting a starter on the new line.  In languages
where multi-line comments work, the choice of value for this variable
is a matter of taste.

   The variable `comment-indent-function' should contain a function
that will be called to compute the indentation for a newly inserted
comment or for aligning an existing comment.  It is set differently by
various major modes.  The function is called with no arguments, but with
point at the beginning of the comment, or at the end of a line if a new
comment is to be inserted.  It should return the column in which the
comment ought to start.  For example, in Lisp mode, the indent hook
function bases its decision on how many semicolons begin an existing
comment, and on the code in the preceding lines.


File: emacs,  Node: Balanced Editing,  Next: Symbol Completion,  Prev: Comments,  Up: Programs

Editing Without Unbalanced Parentheses
======================================

`M-('
     Put parentheses around next sexp(s) (`insert-parentheses').

`M-)'
     Move past next close parenthesis and re-indent
     (`move-over-close-and-reindent').

   The commands `M-(' (`insert-parentheses') and `M-)'
(`move-over-close-and-reindent') are designed to facilitate a style of
editing which keeps parentheses balanced at all times.  `M-(' inserts a
pair of parentheses, either together as in `()', or, if given an
argument, around the next several sexps, and leaves point after the open
parenthesis.  Instead of typing `( F O O )', you can type `M-( F O O',
which has the same effect except for leaving the cursor before the
close parenthesis.  Then you can type `M-)', which moves past the close
parenthesis, deleting any indentation preceding it (in this example
there is none), and indenting with LFD after it.

   `M-(' may insert a space before the open parenthesis, depending on
the syntax class or the preceding character.  Set
`parens-dont-require-spaces' to a non-`nil' value if you wish to
inhibit this.


File: emacs,  Node: Symbol Completion,  Next: Documentation,  Prev: Balanced Editing,  Up: Programs

Completion for Symbol Names
===========================

   Usually completion happens in the minibuffer.  But one kind of
completion is available in all buffers: completion for symbol names.

   The character `M-TAB' runs a command to complete the partial symbol
before point against the set of meaningful symbol names.  Any
additional characters determined by the partial name are inserted at
point.

   If the partial name in the buffer has more than one possible
completion and they have no additional characters in common, a list of
all possible completions is displayed in another window.

   There are two ways of determining the set of legitimate symbol names
to complete against.  In most major modes, this uses a tag table (*note
Tags::.); the legitimate symbol names are the tag names listed in the
tag table file.  The command which implements this is `complete-tag'.

   In Emacs-Lisp mode, the name space for completion normally consists
of nontrivial symbols present in Emacs--those that have function
definitions, values or properties.  However, if there is an
open-parenthesis immediately before the beginning of the partial symbol,
only symbols with function definitions are considered as completions.
The command which implements this is `lisp-complete-symbol'.


File: emacs,  Node: Documentation,  Next: Change Log,  Prev: Symbol Completion,  Up: Programs

Documentation Commands
======================

   As you edit Lisp code to be run in Emacs, the commands `C-h f'
(`describe-function') and `C-h v' (`describe-variable') can be used to
print documentation of functions and variables that you want to call.
These commands use the minibuffer to read the name of a function or
variable to document, and display the documentation in a window.

   For extra convenience, these commands provide default arguments
based on the code in the neighborhood of point.  `C-h f' sets the
default to the function called in the innermost list containing point.
`C-h v' uses the symbol name around or adjacent to point as its default.

   Documentation on Unix commands, system calls and libraries can be
obtained with the `M-x manual-entry' command.  This reads a topic as an
argument, and displays the text on that topic from the Unix manual.
`manual-entry' starts a background process that formats the manual
page, by running the `man' program.  The result goes in a buffer named
`*man TOPIC*'.  These buffers have a special major mode that
facilitates scrolling and examining other manual pages.

   Eventually the GNU project hopes to replace most man pages with
better-organized manuals that you can browse with Info.  *Note Misc
Help::.  Since this process is only partially completed, it is still
useful to read manual pages.


File: emacs,  Node: Change Log,  Next: Tags,  Prev: Documentation,  Up: Programs

Change Logs
===========

   The Emacs command `C-x 4 a' adds a new entry to the change log file
for the file you are editing (`add-change-log-entry-other-window').

   A change log file contains a chronological record of when and why you
have changed a program, consisting of a sequence of entries describing
individual changes.  Normally it is kept in a file called `ChangeLog'
in the same directory as the file you are editing, or one of its parent
directories.  A single `ChangeLog' file can record changes for all the
files in its directory and all its subdirectories.

   A change log entry starts with a header line that contains your name
and the current date.  Aside from these header lines, every line in the
change log starts with a space or a tab.  The bulk of the entry consists
of "items", each of which starts with a line starting with whitespace
and a star.  Here are two entries, each with two items:

     Wed May  5 14:11:45 1993  Richard Stallman  (rms@mole.gnu.ai.mit.edu)
     
     	* man.el: Rename functions and variables `man-*' to `Man-*'.
     	(manual-entry): Make prompt string clearer.
     
     	* simple.el (blink-matching-paren-distance): Change default to 12,000.
     
     Tue May  4 12:42:19 1993  Richard Stallman  (rms@mole.gnu.ai.mit.edu)
     
     	* vc.el (minor-mode-map-alist): Don't use it if it's void.
     	(vc-cancel-version): Doc fix.

   One entry can describe several changes; each change should have its
own item.  Normally there should be a blank line between items.  When
items are related (parts of the same change, in different places), group
them by leaving no blank line between them.  The second entry above
contains two items grouped in this way.

   `C-x 4 a' visits the change log file and creates a new entry unless
the most recent entry is for today's date and your name.  It also
creates a new item for the current file.  For many languages, it can
even guess the name of the function or other object that was changed.

   The change log file is visited in Change Log mode.  Each bunch of
grouped item counts as one paragraph, and each entry is considered a
page.  This facilitates editing the entries.  LFD and auto-fill indent
each new line like the previous line; this is convenient for entering
the contents of an entry.


File: emacs,  Node: Tags,  Next: Emerge,  Prev: Change Log,  Up: Programs

Tag Tables
==========

   A "tag table" is a description of how a multi-file program is broken
up into files.  It lists the names of the component files and the names
and positions of the functions (or other named subunits) in each file.
Grouping the related files makes it possible to search or replace
through all the files with one command.  Recording the function names
and positions makes possible the `M-.'  command which you can use to
find the definition of a function without having to know which of the
files it is in.

   Tag tables are stored in files called "tag table files".  The
conventional name for a tag table file is `TAGS'.

   Each entry in the tag table records the name of one tag, the name of
the file that the tag is defined in (implicitly), and the position in
that file of the tag's definition.

   Just what names from the described files are recorded in the tag
table depends on the programming language of the described file.  They
normally include all functions and subroutines, and may also include
global variables, data types, and anything else convenient.  Each name
recorded is called a "tag".

* Menu:

* Tag Syntax::          Tag syntax for various types of code and text
                          files.
* Create Tag Table::    Creating a tag table with `etags'.
* Select Tag Table::    How to visit a tag table.
* Find Tag::            Commands to find the definition of a specific
                          tag.
* Tags Search::         Using a tag table for searching and replacing.
* Tags Stepping::       Visiting files in a tag table, one by one.
* List Tags::           Listing and finding tags defined in a file.


File: emacs,  Node: Tag Syntax,  Next: Create Tag Table,  Up: Tags

Source File Tag Syntax
----------------------

   In Lisp code, any function defined with `defun', any variable
defined with `defvar' or `defconst', and in general the first argument
of any expression that starts with `(def' in column zero, is a tag.

   In Scheme code, tags include anything defined with `def' or with a
construct whose name starts with `def'.  They also include variables
set with `set!' at top level in the file.

   In C code, any C function is a tag, and so is any typedef if `-t' is
specified when the tag table is constructed.

   In Yacc or Bison input files, each rule defines as a tag the
nonterminal it constructs.  The portions of the file that contain C code
are parsed as C code.

   In Fortran code, functions and subroutines are tags.

   In Prolog code, a tag name appears at the left margin.

   In assembler code, labels appearing at the beginning of a line,
followed by a colon, are tags.

   In LaTeX text, the argument of any of the commands `\chapter',
`\section', `\subsection', `\subsubsection', `\eqno', `\label', `\ref',
`\cite', `\bibitem' and `\typeout' is a tag.


File: emacs,  Node: Create Tag Table,  Next: Select Tag Table,  Prev: Tag Syntax,  Up: Tags

Creating Tag Tables
-------------------

   The `etags' program is used to create a tag table file.  It knows
the syntax of several languages, as described in *Note Tag Syntax::.
Here is how to run `etags':

     etags INPUTFILES...

The `etags' program reads the specified files, and writes a tag table
named `TAGS' in the current working directory.  `etags' recognizes the
language used in an input file based on its file name and contents;
there are no switches for specifying the language.  The `-t' switch
tells `etags' to record typedefs in C code as tags.

   If the tag table data become outdated due to changes in the files
described in the table, the way to update the tag table is the same way
it was made in the first place.  It is not necessary to do this often.

   If the tag table fails to record a tag, or records it for the wrong
file, then Emacs cannot possibly find its definition.  However, if the
position recorded in the tag table becomes a little bit wrong (due to
some editing in the file that the tag definition is in), the only
consequence is a slight delay in finding the tag.  Even if the stored
position is very wrong, Emacs will still find the tag, but it must
search the entire file for it.

   So you should update a tag table when you define new tags that you
want to have listed, or when you move tag definitions from one file to
another, or when changes become substantial.  Normally there is no need
to update the tag table after each edit, or even every day.


File: emacs,  Node: Select Tag Table,  Next: Find Tag,  Prev: Create Tag Table,  Up: Tags

Selecting a Tag Table
---------------------

   Emacs has at any time one "selected" tag table, and all the commands
for working with tag tables use the selected one.  To select a tag
table, type `M-x visit-tags-table', which reads the tag table file name
as an argument.  The name `TAGS' in the default directory is used as the
default file name.

   All this command does is store the file name in the variable
`tags-file-name'.  Emacs does not actually read in the tag table
contents until you try to use them.  Setting this variable yourself is
just as good as using `visit-tags-table'.  The variable's initial value
is `nil'; that value tells all the commands for working with tag tables
that they must ask for a tag table file name to use.

   Using `visit-tags-table' to load a new tag table does not discard
the other tables previously loaded.  The other tags commands use all
the tag tables that are loaded; the first one they use is the one that
mentions the current visited file.

   You can specify a precise list of tag tables by setting the variable
`tags-table-list' to a list of strings, like this:

     (setq tags-table-list
           '("~/emacs" "/usr/local/lib/emacs/src"))

This tells the tags commands to look at the `TAGS' files in your
`~/emacs' directory and in the `/usr/local/lib/emacs/src' directory.
The order depends on which file you are in and which tags table
mentions that file, as explained above.


File: emacs,  Node: Find Tag,  Next: Tags Search,  Prev: Select Tag Table,  Up: Tags

Finding a Tag
-------------

   The most important thing that a tag table enables you to do is to
find the definition of a specific tag.

`M-. TAG RET'
     Find first definition of TAG (`find-tag').

`C-u M-.'
     Find next alternate definition of last tag specified.

`C-u - M-.'
     Go back to previous tag found.

`M-x find-tag-regexp RET PATTERN RET'
     Find a tag whose name matches PATTERN.

`C-u M-x find-tag-regexp'
     Find the next tag whose name matches the last pattern used.

`C-x 4 . TAG RET'
     Find first definition of TAG, but display it in another window
     (`find-tag-other-window').

`C-x 5 . TAG RET'
     Find first definition of TAG, and create a new frame to select the
     buffer (`find-tag-other-frame').

   `M-.' (`find-tag') is the command to find the definition of a
specified tag.  It searches through the tag table for that tag, as a
string, and then uses the tag table info to determine the file that the
definition is in and the approximate character position in the file of
the definition.  Then `find-tag' visits that file, moves point to the
approximate character position, and searches ever-increasing distances
away to find the tag definition.

   If an empty argument is given (just type RET), the sexp in the
buffer before or around point is used as the TAG argument.  *Note
Lists::, for info on sexps.

   You don't need to give `M-.' the full name of the tag; a part will
do.  This is because `M-.' finds tags in the table which contain TAG as
a substring.  However, it prefers an exact match to a substring match.

   To find other tags that match the same substring, give `find-tag' a
numeric argument, as in `C-u M-.'; this does not read a tag name, but
continues searching the tag table's text for another tag containing the
same substring last used.  If you have a real META key, `M-0 M-.' is an
easier alternative to `C-u M-.'.

   Like most commands that can switch buffers, `find-tag' has a variant
that displays the new buffer in another window, and one that makes a
new frame for it.  The former is `C-x 4 .', which invokes the command
`find-tag-other-window'.  The latter is `C-x 5 .', which invokes
`find-tag-other-frame'.

   To move back to places you've found tags recently, use `C-u - M-.';
more generally, `M-.' with a negative numeric argument.  This command
can take you to another buffer.  `C-x 4 .' with a negative argument
finds the previous tag location in another window.

   The new command `M-x find-tag-regexp' visits the tags that match a
specified regular expression.  It is just like `M-.' except that it
does regexp matching instead of substring matching.

   Emacs comes with a tag table file `src/TAGS' that includes all the
Lisp libraries and all the C sources of Emacs.  By specifying this file
with `visit-tags-table' and then using `M-.' you can quickly find the
source for any Emacs function.


File: emacs,  Node: Tags Search,  Next: Tags Stepping,  Prev: Find Tag,  Up: Tags

Searching and Replacing with Tag Tables
---------------------------------------

   The commands in this section visit and search all the files listed
in the selected tag table, one by one.  For these commands, the tag
table serves only to specify a sequence of files to search.  A related
command is `M-x grep' (*note Compilation::.).

`M-x tags-search'
     Search for the specified regexp through the files in the selected
     tag table.

`M-x tags-query-replace'
     Perform a `query-replace' on each file in the selected tag table.

`M-,'
     Restart one of the commands above, from the current location of
     point (`tags-loop-continue').

   `M-x tags-search' reads a regexp using the minibuffer, then searches
for matches in all the files in the selected tag table, one file at a
time.  It displays the name of the file being searched so you can
follow its progress.  As soon as it finds an occurrence, `tags-search'
returns.

   Having found one match, you probably want to find all the rest.  To
find one more match, type `M-,' (`tags-loop-continue') to resume the
`tags-search'.  This searches the rest of the current buffer, followed
by the remaining files of the tag table.

   `M-x tags-query-replace' performs a single `query-replace' through
all the files in the tag table.  It reads a regexp to search for and a
string to replace with, just like ordinary `M-x query-replace-regexp'.
It searches much like `M-x tags-search' but repeatedly, processing
matches according to your input.  *Note Replace::, for more information
on query replace.

   It is possible to get through all the files in the tag table with a
single invocation of `M-x tags-query-replace'.  But since any
unrecognized character causes the command to exit, you may need to
continue where you left off.  `M-,' can be used for this.  It resumes
the last tags search or replace command that you did.

   The commands in this section carry out much broader searches than the
`find-tags' family.  The `find-tags' commands search only for
definitions of tags that match your substring or regexp.  The commands
`tags-search' and `tags-query-replace' find every occurrence of the
regexp, as ordinary search commands and replace commands do in the
current buffer.

   These commands create buffers only temporarily for the files that
they have to search (those which are not already visited in Emacs
buffers).  Buffers in which no match is found are quickly killed; the
others continue to exist.

   It may have struck you that `tags-search' is a lot like `grep'.  You
can also run `grep' itself as an inferior of Emacs and have Emacs show
you the matching lines one by one.  This works mostly the same as
running a compilation and having Emacs show you where the errors were.
*Note Compilation::.


File: emacs,  Node: Tags Stepping,  Next: List Tags,  Prev: Tags Search,  Up: Tags

Stepping Through a Tag Table
----------------------------

   If you wish to process all the files in the selected tag table, but
not in the specific ways that `M-x tags-search' and `M-x
tags-query-replace' do, you can use `M-x next-file' to visit the files
one by one.

`C-u M-x next-file'
     Visit the first file in the tag table, and prepare to advance
     sequentially by files.

`M-x next-file'
     Visit the next file in the selected tag table.


File: emacs,  Node: List Tags,  Prev: Tags Stepping,  Up: Tags

Tag Table Inquiries
-------------------

`M-x list-tags'
     Display a list of the tags defined in a specific program file.

`M-x tags-apropos'
     Display a list of all tags matching a specified regexp.

   `M-x list-tags' reads the name of one of the files described by the
selected tag table, and displays a list of all the tags defined in that
file.  The "file name" argument is really just a string to compare
against the names recorded in the tag table; it is read as a string
rather than as a file name.  Therefore, completion and defaulting are
not available, and you must enter the string the same way it appears in
the tag table.  Do not include a directory as part of the file name
unless the file name recorded in the tag table includes a directory.

   `M-x tags-apropos' is like `apropos' for tags.  It reads a regexp,
then finds all the tags in the selected tag table whose entries match
that regexp, and displays the tag names found.

   You can also perform completion in the buffer on the name space of
tag names in the current tag tables.  *Note Symbol Completion::.


File: emacs,  Node: Emerge,  Next: C Mode,  Prev: Tags,  Up: Programs

Merging Files with Emerge
=========================

   It's not unusual for programmers to get their signals crossed and
modify the same program in two different directions.  To recover from
this confusion, you need to merge the two versions.  Emerge makes this
easier.  See also *Note Comparing Files::.

* Menu:

* Overview of Emerge::	    How to start Emerge.  Basic concepts.
* Submodes of Emerge::      Fast mode vs. Edit mode.
			      Skip Prefers mode and Auto Advance mode.
* State of Difference::	    You do the merge by specifying state A or B
			      for each difference.
* Merge Commands::	    Commands for selecting a difference,
			      changing states of differences, etc.
* Exiting Emerge::	    What to do when you've finished the merge.
* Combining in Emerge::	    How to keep both alternatives for a difference.
* Fine Points of Emerge::   Misc.


File: emacs,  Node: Overview of Emerge,  Next: Submodes of Emerge,  Up: Emerge

Overview of Emerge
------------------

   To start Emerge, run one of these four commands:

`M-x emerge-files'
     Merge two specified files.

`M-x emerge-files-with-ancestor'
     Merge two specified files, with reference to a common ancestor.

`M-x emerge-buffers'
     Merge two buffers.

`M-x emerge-buffers-with-ancestor'
     Merge two buffers with reference to a common ancestor in a third
     buffer.

   The Emerge commands compare two files or buffers, and display the
comparison in three buffers: one for each input text (the "A buffer"
and the "B buffer"), and one (the "merge buffer") where merging takes
place.  The merge buffer shows the full merged text, not just the
differences.  Wherever the two input texts differ, you can choose which
one of them to include in the merge buffer.

   The Emerge commands that take input from existing buffers use only
the accessible portions of those buffers, if they are narrowed (*note
Narrowing::.).

   If a common ancestor version is available, from which the two texts
to be merged were both derived, Emerge can use it to guess which
alternative is right.  Wherever one current version agrees with the
ancestor, Emerge presumes that the other current version is a deliberate
change which should be kept in the merged version.  Use the
`with-ancestor' commands if you want to specify a common ancestor text.
These commands read three file or buffer names--variant A, variant B,
and the common ancestor.

   After the comparison is done and the buffers are prepared, the
interactive merging starts.  You control the merging by typing special
commands in the merge buffer.  The merge buffer shows you a full merged
text, not just differences.  For each run of differences between the
input texts, you can choose which one of them to keep, or edit them both
together.

   The merge buffer uses a special major mode, Emerge mode, with
commands for making these choices.  But you can also edit the buffer
with ordinary Emacs commands.

   At any given time, the attention of Emerge is focused on one
particular difference, called the "selected" difference.  This
difference is marked off in the three buffers like this:

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

Emerge numbers all the differences sequentially and the mode line
always shows the number of the selected difference.

   Normally, the merge buffer starts out with the A version of the text.
But when the A version of a part of the buffer agrees with the common
ancestor, then the B version is preferred for that part.

   Emerge leaves the merged text in the merge buffer when you exit.  At
that point, you can save it in a file with `C-x C-w'.  If you give a
prefix argument to `emerge-files' or `emerge-files-with-ancestor', it
reads the name of the output file using the minibuffer.  (This is the
last file name those commands read.) Then exiting from Emerge saves the
merged text in the output file.

   If you abort Emerge with `C-]', the output is not saved.


File: emacs,  Node: Submodes of Emerge,  Next: State of Difference,  Prev: Overview of Emerge,  Up: Emerge

Submodes of Emerge
------------------

   You can choose between two modes for giving merge commands: Fast mode
and Edit mode.  In Fast mode, basic Emerge commands are single
characters, but ordinary Emacs commands are disabled.  This is
convenient if you use only Emerge commands.

   In Edit mode, all Emerge commands start with the prefix key `C-c
C-c', and the normal Emacs commands are also available.  This allows
editing the merge buffer, but slows down Emerge operations.

   Use `e' to switch to Edit mode, and `C-c C-c f' to switch to Fast
mode.  The mode line indicates Edit and Fast modes with `E' and `F'.

   Emerge has two additional submodes that affect how particular merge
commands work: Auto Advance mode and Skip Prefers mode.

   If Auto Advance mode is in effect, the `a' and `b' commands advance
to the next difference.  This lets you go through the merge faster as
long as you simply choose one of the alternatives from the input.  The
mode line indicates Auto Advance mode with `A'.

   If Skip Prefers mode is in effect, the `n' and `p' commands skip
over differences in states prefer-A and prefer-B.  Thus you see only
differences for which neither version is presumed "correct".  The mode
line indicates Skip Prefers mode with `S'.

   Use the command `s a' (`emerge-auto-advance-mode') to set or clear
Auto Advance mode.  Use `s s' (`emerge-skip-prefers-mode') to set or
clear Skip Prefers mode.  These commands turn on the mode with a
positive argument, turns it off with a negative or zero argument, and
toggle the mode with no argument.


File: emacs,  Node: State of Difference,  Next: Merge Commands,  Prev: Submodes of Emerge,  Up: Emerge

State of a Difference
---------------------

   In the merge buffer, a difference is marked with lines of `v' and
`^' characters.  Each difference has one of these seven states:

A
     The difference is showing the A version.  The `a' command always
     produces this state; the mode line indicates it with `A'.

B
     The difference is showing the B version.  The `b' command always
     produces this state; the mode line indicates it with `B'.

default-A
default-B
     The difference is showing the A or the B state by default, because
     you haven't made a choice.  All differences start in the default-A
     state (and thus the merge buffer is a copy of the A buffer),
     except those for which one alternative is "preferred" (see below).

     When you select a difference, its state changes from default-A or
     default-B to plain A or B.  Thus, the selected difference never has
     state default-A or default-B, and these states are never displayed
     in the mode line.

     The command `d a' chooses default-A as the default state, and `d
     b' chooses default-B.  This chosen default applies to all
     differences which you haven't selected and for which no
     alternative is preferred.  If you are moving through the merge
     sequentially, the differences you haven't selected are those
     following the selected one.  Thus, while moving sequentially, you
     can effectively make the A version the default for some sections
     of the merge buffer and the B version the default for others by
     using `d a' and `d b' at the end of each section.

prefer-A
prefer-B
     The difference is showing the A or B state because it is
     "preferred".  This means that you haven't made an explicit choice,
     but one alternative seems likely to be right because the other
     alternative agrees with the common ancestor.  Thus, where the A
     buffer agrees with the common ancestor, the B version is
     preferred, because chances are it is the one that was actually
     changed.

     These two states are displayed in the mode line as `A*' and `B*'.

combined
     The difference is showing a combination of the A and B states, as a
     result of the `x c' or `x C' commands.

     Once a difference is in this state, the `a' and `b' commands don't
     do anything to it unless you give them a prefix argument.

     The mode line displays this state as `comb'.


File: emacs,  Node: Merge Commands,  Next: Exiting Emerge,  Prev: State of Difference,  Up: Emerge

Merge Commands
--------------

   Here are the Merge commands for Fast mode; in Edit mode, precede them
with `C-c C-c':

`p'
     Select the previous difference.

`n'
     Select the next difference.

`a'
     Choose the A version of this difference.

`b'
     Choose the B version of this difference.

`j'
     Select a particular difference; specify the sequence number of that
     difference as a prefix argument.

`.'
     Select the difference containing point.  You can use this command
     in the merge buffer or in the A or B buffer.

`q'
     Quit--finish the merge.

`C-]'
     Abort--exit merging and do not save the output.

`f'
     Go into Fast mode.  (In Edit mode, this is actually `C-c C-c f'.)

`e'
     Go into Edit mode.

`l'
     Recenter (like `C-l') all three windows.

`-'
     Specify part of a prefix numeric argument.

`DIGIT'
     Also specify part of a prefix numeric argument.

`d a'
     Choose the A version as the default from here down in the merge
     buffer.

`d b'
     Choose the B version as the default from here down in the merge
     buffer.

`c a'
     Copy the A version of this difference into the kill ring.

`c b'
     Copy the B version of this difference into the kill ring.

`i a'
     Insert the A version of this difference at the point.

`i b'
     Insert the B version of this difference at the point.

`m'
     Put the point and mark around the difference region.

`^'
     Scroll all three windows down (like `M-v').

`v'
     Scroll all three windows up (like `C-v').

`<'
     Scroll all three windows left (like `C-x <').

`>'
     Scroll all three windows right (like `C-x >').

`|'
     Reset horizontal scroll on all three windows.

`x 1'
     Shrink the merge window to one line.  (Use `C-u l' to restore it
     to full size.)

`x c'
     Combine the two versions of this difference.

`x f'
     Show the files/buffers Emerge is operating on in Help window.
     (Use `C-u l' to restore windows.)

`x j'
     Join this difference with the following one.  (`C-u x j' joins
     this difference with the previous one.)

`x s'
     Split this difference into two differences.  Before you use this
     command, position point in each of the three buffers to the place
     where you want to split the difference.

`x t'
     Trim identical lines off top and bottom of the difference.  Such
     lines occur when the A and B versions are identical but differ
     from the ancestor version.


File: emacs,  Node: Exiting Emerge,  Next: Combining in Emerge,  Prev: Merge Commands,  Up: Emerge

Exiting Emerge
--------------

   The `q' command (`emerge-quit') finishes the merge, storing the
results into the output file if you specified one.  It restores the A
and B buffers to their proper contents, or kills them if they were
created by Emerge and you haven't changed them.  It also disables the
Emerge commands in the merge buffer, since executing them later could
damage the contents of the various buffers.

   `C-]' aborts the merge.  This means exiting without writing the
output file.  If you didn't specify an output file, then there is no
real difference between aborting and finishing the merge.

   If Emerge was called from another Lisp program, then its return value
is `t' for successful completion, or `nil' if you abort.


File: emacs,  Node: Combining in Emerge,  Next: Fine Points of Emerge,  Prev: Exiting Emerge,  Up: Emerge

Combining the Two Versions
--------------------------

   Sometimes you want to keep *both* alternatives for a particular
locus.  To do this, use `x c', which edits the merge buffer like this:

     #ifdef NEW
     VERSION FROM A FILE
     #else /* NEW */
     VERSION FROM B FILE
     #endif /* NEW */

While this example shows C preprocessor conditionals delimiting the two
alternative versions, you can specify the strings you want by setting
the variable `emerge-combine-versions-template' to a string of your
choice.  In the string, `%a' says where to put version A, and `%b' says
where to put version B.  The default setting, which produces the
results shown above, looks like this:

     "#ifdef NEW\n%a#else /* NEW */\n%b#endif /* NEW */\n"


File: emacs,  Node: Fine Points of Emerge,  Prev: Combining in Emerge,  Up: Emerge

Fine Points of Emerge
---------------------

   During the merge, you mustn't try to edit the A and B buffers
yourself.  Emerge modifies them temporarily, but ultimately puts them
back the way they were.

   You can have any number of merges going at once--just don't use any
one buffer as input to more than one merge at once, since the temporary
changes made in these buffers would get in each other's way.

   Starting Emerge can take a long time because it needs to compare the
files fully.  Emacs can't do anything else until `diff' finishes.
Perhaps in the future someone will change Emerge to do the comparison in
the background when the input files are large--then you could keep on
doing other things with Emacs until Emerge gets ready to accept
commands.

   After setting up the merge, Emerge runs the hook
`emerge-startup-hook' (*note Hooks::.).


File: emacs,  Node: C Mode,  Next: Fortran,  Prev: Emerge,  Up: Programs

C Mode
======

   In addition to the facilities of typical programming language major
modes (*note Program Modes::.), C mode has various special facilities.

`M-a'
`M-e'
     In C mode, `M-a' and `M-e' now move by complete C statements
     (`c-beginning-of-statement' and `c-end-of-statement').  These
     commands do ordinary, textual sentence motion when in or next to a
     comment.

`M-q'
     `M-q' in C mode runs `c-fill-paragraph', which is designed for
     filling C comments.  (We assume you don't want to fill the actual
     C code in a C program.)

`C-c C-u'
     Move back to the containing preprocessor conditional, setting the
     mark at the starting point (`c-up-conditional').

     A prefix argument acts as a repeat count.  With a negative
     argument, this command moves forward to the end of the containing
     preprocessor conditional.  When going backwards, `#elif' acts like
     `#else' followed by `#if'.  When going forwards, `#elif' is
     ignored.

`C-c C-n'
     Move forward across the next preprocessor conditional, setting the
     mark at the starting point (`c-forward-conditional').

`C-c C-p'
     Move backward across the previous preprocessor conditional,
     setting the at the starting point (`c-backward-conditional').

`M-x c-macro-expand'
     When you are debugging C code that uses macros, sometimes it is
     hard to figure out precisely how the macros expand.  The command
     `M-x c-macro-expand' runs the C preprocessor and shows you what
     expansion results from the region.  The portion of the buffer
     before the region is also included in preprocessing, for the sake
     of macros defined there, but the output from this part isn't shown.

`M-x c-backslash-region'
     Insert or align `\' characters at the ends of the lines of the
     region, except for the last such line.  This is useful after
     writing or editing a C macro definition.

     If a line already ends in `\', this command adjusts the amount of
     whitespace before it.  Otherwise, it inserts a new `\'.

   C++ mode is like C mode, except that it understands C++ comment
syntax and certain other differences between C and C++.  It also has a
command `M-x fill-c++-comment', which fills a paragraph made of C++
comment lines.

   The command `comment-region' is useful in C++ mode for commenting
out several consecutive lines, or removing the commenting out of such
lines.  (You don't need this command with C comment syntax because you
don't need to put comment delimiters on each line.)  *Note Comments::.


File: emacs,  Node: Fortran,  Next: Asm Mode,  Prev: C Mode,  Up: Programs

Fortran Mode
============

   Fortran mode provides special motion commands for Fortran statements
and subprograms, and indentation commands that understand Fortran
conventions of nesting, line numbers and continuation statements.
Fortran mode has it's own Auto Fill mode that breaks long lines into
proper Fortran continuation lines.

   Special commands for comments are provided because Fortran comments
are unlike those of other languages.

   Built-in abbrevs optionally save typing when you insert Fortran
keywords.

   Use `M-x fortran-mode' to switch to this major mode.  This command
runs the hook `fortran-mode-hook' (*note Hooks::.).

* Menu:

* Motion: Fortran Motion.      Moving point by statements or subprograms.
* Indent: Fortran Indent.      Indentation commands for Fortran.
* Comments: Fortran Comments.  Inserting and aligning comments.
* Autofill: Fortran Autofill.  Auto fill minor mode for Fortran.
* Columns: Fortran Columns.    Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.      Built-in abbrevs for Fortran keywords.

   Fortran mode was contributed by Michael Prange.  It has been updated
by Stephen A. Wood who has collated the contributions and suggestions
of many users.


File: emacs,  Node: Fortran Motion,  Next: Fortran Indent,  Up: Fortran

Motion Commands
---------------

   Fortran mode provides special commands to move by subprograms
(functions and subroutines) and by statements.  There is also a command
to put the region around one subprogram, convenient for killing it or
moving it.

`C-M-a'
     Move to beginning of subprogram
     (`beginning-of-fortran-subprogram').

`C-M-e'
     Move to end of subprogram (`end-of-fortran-subprogram').

`C-M-h'
     Put point at beginning of subprogram and mark at end
     (`mark-fortran-subprogram').

`C-c C-n'
     Move to beginning of current or next statement
     (`fortran-next-statement').

`C-c C-p'
     Move to beginning of current or previous statement
     (`fortran-previous-statement').


File: emacs,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

Fortran Indentation
-------------------

   Special commands and features are needed for indenting Fortran code
in order to make sure various syntactic entities (line numbers, comment
line indicators and continuation line flags) appear in the columns that
are required for standard Fortran.

* Menu:

* Commands: ForIndent Commands.  Commands for indenting Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.


File: emacs,  Node: ForIndent Commands,  Next: ForIndent Cont,  Up: Fortran Indent

Fortran Indentation Commands
............................

`TAB'
     Indent the current line (`fortran-indent-line').

`LFD'
     Indent the current and start a new indented line
     (`fortran-indent-new-line').

`M-LFD'
     Break the current line and set up a continuation line.

`C-M-q'
     Indent all the lines of the subprogram point is in
     (`fortran-indent-subprogram').

   Fortran mode redefines TAB to reindent the current line for Fortran
(`fortran-indent-line').  This command indents Line numbers and
continuation markers to their required columns, and independently
indents the body of the statement based on its nesting in the program.

   The key `LFD' runs the command `fortran-indent-new-line', which
reindents the current line then makes and indents a new line.  This
command is useful to reindent the closing statement of `do' loops and
other blocks before starting a new line.

   The key `C-M-q' runs `fortran-indent-subprogram', a command to
reindent all the lines of the Fortran subprogram (function or
subroutine) containing point.

   The key `M-LFD' runs `fortran-split-line', which splits a line in
the appropriate fashion for Fortran.  In a non-comment line, the second
half becomes a continuation line and is indented accordingly.  In a
comment line, both halves become separate comment lines.

