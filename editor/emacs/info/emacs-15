This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Sorting,  Next: Shell,  Prev: GNUS,  Up: Top

Sorting Text
============

   Emacs provides several commands for sorting text in the buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
into the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numeric sorting, in
numeric order.  In alphabetic sorting, all upper case letters `A'
through `Z' come before lower case `a', in accord with the ASCII
character sequence.

   The various sort commands differ in how they divide the text into
sort records and in which part of each record is used as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines, and sort by comparing the entire
     text of a line.  A prefix argument means sort into descending
     order.

`M-x sort-paragraphs'
     Divide the region into paragraphs, and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort into descending order.

`M-x sort-pages'
     Divide the region into pages, and sort by comparing the entire
     text of a page (except for leading blank lines).  A prefix
     argument means sort into descending order.

`M-x sort-fields'
     Divide the region into lines, and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     Specify which field to sort by with a numeric argument: 1 to sort
     by field 1, etc.  A negative argument means sort into descending
     order.  Thus, minus 2 means sort by field 2 in
     reverse-alphabetical order.  If several lines have identical
     contents in the field being sorted, they keep same relative order
     that they had in the original buffer.

`M-x sort-numeric-fields'
     Like `M-x sort-fields' except the specified field is converted to
     a number for each line, and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields' except that the text within each line used
     for comparison comes from a fixed range of columns.  See below for
     an explanation.

   For example, if the buffer contains this:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then applying `M-x sort-lines' to the entire buffer produces this:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' sorts before all lower case letters.  If you
use `C-u 2 M-x sort-fields' instead, you get this:

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `Emacs', `If', `buffer', `systems' and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then run
`sort-columns'.  Equivalently, you could run it with the mark on column
15 in the first line and point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

   Many of the sort commands ignore case differences when comparing, if
`sort-fold-case' is non-`nil'.


File: emacs,  Node: Shell,  Next: Narrowing,  Prev: Sorting,  Up: Top

Running Shell Commands from Emacs
=================================

   Emacs has commands for passing single command lines to inferior shell
processes; it can also run a shell interactively with input and output
to an Emacs buffer `*shell*'.

`M-!'
     Run a specified shell command line and display the output
     (`shell-command').

`M-|'
     Run a specified shell command line with region contents as input;
     optionally replace the region with the output
     (`shell-command-on-region').

`M-x shell'
     Run a subshell with input and output through an Emacs buffer.  You
     can then give commands interactively.

* Menu:

* Single Shell::           How to run one shell command and return.
* Interactive Shell::      Permanent shell taking input via Emacs.
* Shell Mode::             Special Emacs commands used with permanent shell.
* History: Shell History.  Repeating previous commands in a shell buffer.


File: emacs,  Node: Single Shell,  Next: Interactive Shell,  Up: Shell

Single Shell Commands
---------------------

   `M-!' (`shell-command') reads a line of text using the minibuffer
executes it as a shell command in a subshell made just for this
command.  Standard input for the command comes from the null device.
If the shell command produces any output, the output goes into an Emacs
buffer named `*Shell Command Output*', which is displayed in another
window but not selected.  A numeric argument, as in `M-1 M-!', directs
this command to insert any output into the current buffer.  In that
case, point is left before the output and the mark is set after the
output.

   If the shell command line ends in `&', it runs asynchronously.

   `M-|' (`shell-command-on-region') is like `M-!' but passes the
contents of the region as input to the shell command, instead of no
input.  If a numeric argument is used, meaning insert output in the
current buffer, then the old region is deleted first and the output
replaces it as the contents of the region.

   Both `M-!' and `M-|' use `shell-file-name' to specify the shell to
use.  This variable is initialized based on your `SHELL' environment
variable when Emacs is started.  If the file name does not specify a
directory, the directories in the list `exec-path' are searched; this
list is initialized based on the environment variable `PATH' when Emacs
is started.  Your `.emacs' file can override either or both of these
default initializations.

   With `M-!' and `M-|', Emacs has to wait until the shell command
completes.  To stop waiting, type `C-g' to quit; that also kills the
shell command.


File: emacs,  Node: Interactive Shell,  Next: Shell Mode,  Prev: Single Shell,  Up: Shell

Interactive Inferior Shell
--------------------------

   To run a subshell interactively, putting its typescript in an Emacs
buffer, use `M-x shell'.  This creates (or reuses) a buffer named
`*shell*' and runs a subshell with input coming from and output going
to that buffer.  That is to say, any "terminal output" from the subshell
goes into the buffer, advancing point, and any "terminal input" for the
subshell comes from text in the buffer.  To give input to the subshell,
go to the end of the buffer and type the input, terminated by RET.

   Emacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while
it is running a command.  Output from the subshell waits until Emacs
has time to process it; this happens whenever Emacs is waiting for
keyboard input or for time to elapse.

   To make multiple subshells, rename the buffer `*shell*' to something
different using `M-x rename-uniquely'.  Then type `M-x shell' again to
create a new buffer `*shell*' with its own subshell.  If you rename
this buffer as well, you can create a third one, and so on.  All the
subshells run independently and in parallel.

   The file name used to load the subshell is the value of the variable
`explicit-shell-file-name', if that is non-`nil'.  Otherwise, the
environment variable `ESHELL' is used, or the environment variable
`SHELL' if there is no `ESHELL'.  If the file name specified is
relative, the directories in the list `exec-path' are searched (*note
Single Shell Commands: Single Shell.).

   As soon as the subshell is started, it is sent as input the contents
of the file `~/.emacs_SHELLNAME', if that file exists, where SHELLNAME
is the name of the file that the shell was loaded from.  For example,
if you use `bash', the file sent to it is `~/.emacs_bash'.

   `cd', `pushd' and `popd' commands given to the inferior shell are
watched by Emacs so it can keep the `*shell*' buffer's default
directory the same as the shell's working directory.  These commands
are recognized syntactically by examining lines of input that are sent.
If you use aliases for these commands, you can tell Emacs to recognize
them also.  For example, if the value of the variable
`shell-pushd-regexp' matches the beginning of a shell command line,
that line is regarded as a `pushd' command.  Change this variable when
you add aliases for `pushd'.  Likewise, `shell-popd-regexp' and
`shell-cd-regexp' are used to recognize commands with the meaning of
`popd' and `cd'.  These commands are recognized only at the beginning
of a shell command line.

   If Emacs gets an error while trying to handle what it believes is a
`cd', `pushd' or `popd' command, it runs the hook
`shell-set-directory-error-hook' (*note Hooks::.).

   If Emacs does not properly track changes in the current directory of
the subshell, use the command `M-x dirs' to ask the shell what its
current directory is.  This command works for shells that support the
most common command syntax; it may not work for unusual shells.


File: emacs,  Node: Shell Mode,  Next: Shell History,  Prev: Interactive Shell,  Up: Shell

Shell Mode
----------

   The shell buffer uses Shell mode, which defines several special keys
attached to the `C-c' prefix.  They are chosen to resemble the usual
editing and job control characters present in shells that are not under
Emacs, except that you must type `C-c' first.  Here is a complete list
of the special key bindings of Shell mode:

`RET'
     At end of buffer send line as input; otherwise, copy current line
     to end of buffer and send it (`comint-send-input').  When a line is
     copied, any text at the beginning of the line that matches the
     variable `shell-prompt-pattern' is left out; this variable's value
     should be a regexp string that matches the prompts that your shell
     uses.

`TAB'
     Complete the file name before point in the shell buffer
     (`comint-dynamic-complete').

`M-?'
     Display temporarily a list of the possible completions of the file
     name before point in the shell buffer
     (`comint-dynamic-list-completions').

`C-a'
     Move to the beginning of the line, but after the prompt if any
     (`comint-bol').

`C-d'
     Either delete a character or send EOF
     (`comint-delchar-or-maybe-eof').  Typed at the end of the shell
     buffer, `C-d' sends EOF to the subshell.  Typed at any other
     position in the buffer, `C-d' deletes a character as usual.

`C-c C-u'
     Kill all text pending at end of buffer to be sent as input
     (`comint-kill-input').

`C-c C-w'
     Kill a word before point (`backward-kill-word').

`C-c C-c'
     Interrupt the shell or its current subjob if any
     (`comint-interrupt-subjob').

`C-c C-z'
     Stop the shell or its current subjob if any (`comint-stop-subjob').

`C-c C-\'
     Send quit signal to the shell or its current subjob if any
     (`comint-quit-subjob').

`C-c C-o'
     Kill the last batch of output from a shell command
     (`comint-kill-output').  This is useful if a shell command spews
     out lots of output that just gets in the way.

`C-c C-r'
     Scroll to display the beginning of the last batch of output at the
     top of the window; also move the cursor there
     (`comint-show-output').

`M-x dirs'
     Ask the shell what its current directory is, so that Emacs can
     agree with the shell.

`M-x send-invisible RET TEXT RET'
     Send TEXT as input to the shell, after reading it without echoing.
     This is useful when a shell command runs a program that asks for
     a password.

`M-x comint-continue-subjob'
     Continue the shell process.  This is useful if you accidentally
     suspend the shell process.(1)

   ---------- Footnotes ----------

   (1)  You should not suspend the shell process.  Suspending a subjob
of the shell is a completely different matter-that is normal practice,
but you must use the shell to continue the subjob; this command won't
do it.


File: emacs,  Node: Shell History,  Prev: Shell Mode,  Up: Shell

Shell Command History
---------------------

   Shell buffers support history commands much like the minibuffer
history commands.

`M-p'
     Fetch the next earlier old shell command.

`M-n'
     Fetch the next later old shell command.

`M-r REGEXP RET'
`M-s REGEXP RET'
     Search backwards or forwards for old shell commands that match
     REGEXP.

   Shell buffers provide a history of previously entered shell
commands.  To reuse shell commands from the history, use the editing
commands `M-p', `M-n', `M-r' and `M-s'.  These work just like the
minibuffer history commands except that they operate on the text at the
end of the shell buffer, the text that typing RET will send to the
shell.

   `M-p' fetches an earlier shell command to the end of the shell
buffer.  Successive use of `M-p' fetches successively earlier shell
commands, each replacing any text that was already present as potential
shell input.  `M-n' does likewise except that it finds successively
more recent shell commands from the buffer.

   The history search commands `M-r' and `M-s' read a regular
expression and search through the history for a matching command.  Aside
from the choice of which command to fetch, they work just like `M-p'
and `M-r'.  If you enter an empty regexp, these commands reuse the same
regexp used last time.

   When you find the previous input you want, you can resubmit it by
typing RET, or you can edit it first and then resubmit it if you wish.

   These commands get the text of previous shell commands from a special
history list, not from the shell buffer itself.  Thus, editing the shell
buffer, or even killing large parts of it, does not affect the history
that these commands access.


File: emacs,  Node: Narrowing,  Next: Hardcopy,  Prev: Shell,  Up: Top

Narrowing
=========

   "Narrowing" means focusing in on some portion of the buffer, making
the rest temporarily inaccessible.  The portion which you can still get
to is called the "accessible portion".  Cancelling the narrowing, and
making the entire buffer once again accessible, is called "widening".
The amount of narrowing in effect in a buffer at any time is called the
buffer's "restriction".

`C-x n n'
     Narrow down to between point and mark (`narrow-to-region').

`C-x n w'
     Widen to make the entire buffer accessible again (`widen').

`C-x n p'
     Narrow down to the current page (`narrow-to-page').

   When you have narrowed down to a part of the buffer, that part
appears to be all there is.  You can't see the rest, you can't move
into it (motion commands won't go outside the accessible part), you
can't change it in any way.  However, it is not gone, and if you save
the file all the inaccessible text will be saved.  In addition to
sometimes making it easier to concentrate on a single subroutine or
paragraph by eliminating clutter, narrowing can be used to restrict the
range of operation of a replace command or repeating keyboard macro.
The word `Narrow' appears in the mode line whenever narrowing is in
effect.

   The primary narrowing command is `C-x n n' (`narrow-to-region').  It
sets the current buffer's restrictions so that the text in the current
region remains accessible but all text before the region or after the
region is invisible.  Point and mark do not change.

   Alternatively, use `C-x n p' (`narrow-to-page') to narrow down to
the current page.  *Note Pages::, for the definition of a page.

   The way to undo narrowing is to widen with `C-x n w' (`widen').
This makes all text in the buffer accessible again.

   You can get information on what part of the buffer you are narrowed
down to using the `C-x =' command.  *Note Position Info::.

   Because narrowing can easily confuse users who do not understand it,
`narrow-to-region' is normally a disabled command.  Attempting to use
this command asks for confirmation and gives you the option of enabling
it; once you enable the command, confirmation will no longer be
required for it.  *Note Disabling::.


File: emacs,  Node: Hardcopy,  Next: Two-Column,  Prev: Narrowing,  Up: Top

Hardcopy Output
===============

   The Emacs commands for making hardcopy let you print either an entire
buffer or just part of one, either with or without page headers.  See
also the hardcopy commands of Dired (*note Misc File Ops::.) and the
diary (*note Diary Commands::.).

`M-x print-buffer'
     Print hardcopy of current buffer using Unix command `print' (`lpr
     -p').  This makes page headings containing the file name and page
     number.

`M-x lpr-buffer'
     Print hardcopy of current buffer using Unix command `lpr'.  This
     makes no page headings.

`M-x print-region'
     Like `print-buffer' but prints only the current region.

`M-x lpr-region'
     Like `lpr-buffer' but prints only the current region.

   All the hardcopy commands pass extra switches to the `lpr' program
based on the value of the variable `lpr-switches'.  Its value should be
a list of strings, each string an option starting with `-'.  For
example, to use a printer named `nearme', set `lpr-switches' like this:

     (setq lpr-switches '("-Pnearme"))


File: emacs,  Node: Two-Column,  Next: Editing Binary Files,  Prev: Hardcopy,  Up: Top

Two-Column Editing
==================

   Two-column mode lets you conveniently edit two side-by-side columns
of text.  It uses two side-by-side windows, each showing its own buffer.

   There are three ways to enter two-column mode:

`C-x 6 2'
     Enter two-column mode with the current buffer on the left, and on
     the right, a buffer whose name is based on the current buffer's
     name (`tc-two-columns').  If the right-hand buffer doesn't already
     exist, it starts out empty; the current buffer's contents are not
     changed.

     This command is appropriate when the current buffer contains just
     one column and you want to add another column.

`C-x 6 s'
     Split the current buffer, which contains two-column text, into two
     buffers, and display them side by side (`tc-split').  The current
     buffer becomes the left-hand buffer, but the text in the right-hand
     column is moved into the right-hand buffer.  The current column
     specifies the split point.  Splitting starts with the current line
     and continues to the end of the buffer.

     This command is appropriate when you have a buffer that already
     contains two-column text, and you wish to separate the columns
     temporarily.

`C-x 6 b BUFFER RET'
     Enter two-column mode using the current buffer as the left-hand
     buffer, and using buffer BUFFER as the right-hand buffer
     (`tc-associate-buffer').

   `C-x 6 s' looks for a column separator which is a string that
appears on each line between the two columns.  You can specify the width
of the separator with a numeric argument to `C-x 6 s'; that many
characters, before point, constitute the separator string.  By default,
the width is 1, so the column separator is the character before point.

   When a line has the separator at the proper place, `C-x 6 s' puts
the text after the separator into the right-hand buffer, and deletes the
separator.  Lines that don't have the column separator at the proper
place remain unsplit; they stay in the left-hand buffer, and the
right-hand buffer gets an empty line to correspond.  (This is the way
to write a line which "spans both columns while in two-column mode:
write it in the left-hand buffer, and put an empty line in the
right-hand buffer.)

   It's not a good idea to use ordinary scrolling commands during
two-column editing, because that separates the two parts of each split
line.  Instead, use these special scroll commands:

`C-x 6 SPC'
     Scroll both buffers up, in lockstep (`tc-scroll-up').

`C-x 6 DEL'
     Scroll both buffers down, in lockstep (`tc-scroll-down').

`C-x 6 C-l'
     Recenter both buffers, in lockstep (`tc-recenter').

   When you have edited both buffers as you wish, merge them with `C-x
6 1' (`tc-merge').  This copies the text from the right-hand buffer as
a second column in the other buffer.  To go back to two-column editing,
use `C-x 6 s'.

   Use `C-x 6 d' to disassociate the two buffers, leaving each as it
stands (`tc-dissociate').  If the other buffer, the one not current
when you type `C-x 6 d', is empty, `C-x 6 d' kills it.


File: emacs,  Node: Editing Binary Files,  Next: Emacs Server,  Prev: Two-Column,  Up: Top

Editing Binary Files
====================

   There is a special major mode for editing binary files: Hexl mode.
To use it, use `M-x hexl-find-file' instead of `C-x C-f' to visit the
file.  This command converts the file's contents to hexadecimal and
lets you edit the translation.  When you save the file, it is converted
automatically back to binary.

   You can also use `M-x hexl-mode' to translate an existing buffer
into hex.  This is useful if you visit a file normally and then discover
it is a binary file.

   Ordinary text characters overwrite in Hexl mode.  This is to reduce
the risk of accidentally spoiling the alignment of data in the file.
There are special commands for insertion.  Here is a list of the
commands of Hexl mode:

`C-M-d'
     Insert a byte with a code typed in decimal.

`C-M-o'
     Insert a byte with a code typed in octal.

`C-M-x'
     Insert a byte with a code typed in hex.

`C-x ['
     Move to the beginning of a 1k-byte "page".

`C-x ]'
     Move to the end of a 1k-byte "page".

`M-g'
     Move to an address specified in hex.

`M-j'
     Move to an address specified in decimal.

`C-c C-c'
     Leave Hexl mode, going back to the major mode this buffer had
     before you invoked `hexl-mode'.


File: emacs,  Node: Emacs Server,  Next: Recursive Edit,  Prev: Editing Binary Files,  Up: Top

Using Emacs as a Server
=======================

   Various programs such as `mail' can invoke your choice of editor to
edit a particular piece of text, such as a message that you are
sending.  By convention, these programs use the environment variable
`EDITOR' to specify which editor to run.  If you set `EDITOR' to
`emacs', they invoke Emacs--but in an inconvenient fashion, by starting
a new, separate Emacs process.  This is inconvenient because it takes
time and because the new Emacs process doesn't share the buffers in the
existing Emacs process.

   You can arrange to use your existing Emacs process as the editor for
programs like `mail' by using the Emacs client and Emacs server
programs.  Here is how.

   First, the preparation.  Within Emacs, call the function
`server-start'.  (Your `.emacs' file can do this automatically if you
add the expression `(server-start)' to it.)  Then, outside Emacs, set
the `EDITOR' environment variable to `emacsclient'.

   Then, whenever any program invokes your specified `EDITOR' program,
the effect is to send a message to your principal Emacs telling it to
visit a file.  (That's what the program `emacsclient' does.) Emacs
obeys silently; it does not immediately switch to the new file's
buffer.  When you want to do that, type `C-x #' (`server-edit').

   When you've finished editing that buffer, type `C-x #' again.  This
saves the file and sends a message back to the `emacsclient' program
telling it to exit.  The programs that use `EDITOR' wait for the
"editor" (actually, `emacsclient') to exit.  `C-x #' also checks to see
if any other files are pending for you to edit, and selects the next
one.

   You can switch to a server buffer manually if you wish; you don't
have to arrive at it with `C-x #'.  But `C-x #' is the only way to say
that you are "finished" with one.

   If you set the variable `server-window' to a window or a frame, `C-x
#' displays the server buffer in that window or in that frame.

   While `mail' or another application is waiting for `emacsclient' to
finish, `emacsclient' does not read terminal input.  So the terminal
that `mail' was using is effectively blocked for the duration.  In
order to edit with your principal Emacs, you need to be able to use it
without using that terminal.  There are two ways to do this:

   * Using a window system, run `mail' and the principal Emacs in two
     separate windows.  While `mail' is waiting for `emacsclient', the
     window where it was running is blocked, but you can use Emacs by
     switching windows.

   * Use Shell mode in Emacs to run the other program such as `mail';
     then, `emacsclient' blocks only the subshell under Emacs; you can
     still use Emacs to edit the file.

   Some programs write temporary files for you to edit.  After you edit
the temporary file, the program reads it back and deletes it.  If the
Emacs server is later asked to edit the same file name, it should assume
this has nothing to do with the previous occasion for that file name.
The server accomplishes this by killing the temporary file's buffer when
you finish with the file.  Use the variable `server-temp-file-regexp'
to specify which files are temporary in this sense; its value should be
a regular expression that matches file names that are temporary.


File: emacs,  Node: Recursive Edit,  Next: Dissociated Press,  Prev: Emacs Server,  Up: Top

Recursive Editing Levels
========================

   A "recursive edit" is a situation in which you are using Emacs
commands to perform arbitrary editing while in the middle of another
Emacs command.  For example, when you type `C-r' inside of a
`query-replace', you enter a recursive edit in which you can change the
current buffer.  On exiting from the recursive edit, you go back to the
`query-replace'.

   "Exiting" the recursive edit means returning to the unfinished
command, which continues execution.  To exit, type `C-M-c'
(`exit-recursive-edit').

   You can also "abort" the recursive edit.  This is like exiting, but
also quits the unfinished command immediately.  Use the command `C-]'
(`abort-recursive-edit') for this.  *Note Quitting::.

   The mode line shows you when you are in a recursive edit by
displaying square brackets around the parentheses that always surround
the major and minor mode names.  Every window's mode line shows this,
in the same way, since being in a recursive edit is true of Emacs as a
whole rather than any particular window or buffer.

   It is possible to be in recursive edits within recursive edits.  For
example, after typing `C-r' in a `query-replace', you may type a
command that enters the debugger.  This begins a recursive editing level
for the debugger, within the recursive editing level for `C-r'.  Mode
lines display a pair of square brackets for each recursive editing
level currently in progress.

   Exiting the inner recursive edit (such as, with the debugger `c'
command) resumes the command running in the next level up.  When that
command finishes, you can then use `C-M-c' to exit another recursive
editing level, and so on.  Exiting applies to the innermost level only.
Aborting also gets out of only one level of recursive edit; it returns
immediately to the command level of the previous recursive edit.  If you
wish, you can then abort the next recursive editing level.

   Alternatively, the command `M-x top-level' aborts all levels of
recursive edits, returning immediately to the top level command reader.

   The text being edited inside the recursive edit need not be the same
text that you were editing at top level.  It depends on what the
recursive edit is for.  If the command that invokes the recursive edit
selects a different buffer first, that is the buffer you will edit
recursively.  In any case, you can switch buffers within the recursive
edit in the normal manner (as long as the buffer-switching keys have
not been rebound).  You could probably do all the rest of your editing
inside the recursive edit, visiting files and all.  But this could have
surprising effects (such as stack overflow) from time to time.  So
remember to exit or abort the recursive edit when you no longer need it.

   In general, we try to minimize the use of recursive editing levels in
GNU Emacs.  This is because they constrain you to "go back" in a
particular order-from the innermost level toward the top level.  When
possible, we present different activities in separate buffers.  Some
commands switch to a new major mode but provide a way to switch back.
These approaches give you more flexibility to go back to unfinished
tasks in the order you choose.


File: emacs,  Node: Dissociated Press,  Next: Amusements,  Prev: Recursive Edit,  Up: Top

Dissociated Press
=================

   `M-x dissociated-press' is a command for scrambling a file of text
either word by word or character by character.  Starting from a buffer
of straight English, it produces extremely amusing output.  The input
comes from the current Emacs buffer.  Dissociated Press writes its
output in a buffer named `*Dissociation*', and redisplays that buffer
after every couple of lines (approximately) to facilitate reading it.

   Dissociated Press asks every so often whether to continue operating.
Answer `n' to stop it.  You can also stop at any time by typing `C-g'.
The dissociation output remains in the `*Dissociation*' buffer for you
to copy elsewhere if you wish.

   Dissociated Press operates by jumping at random from one point in the
buffer to another.  In order to produce plausible output rather than
gibberish, it insists on a certain amount of overlap between the end of
one run of consecutive words or characters and the start of the next.
That is, if it has just printed out `president' and then decides to jump
to a different point in the file, it might spot the `ent' in `pentagon'
and continue from there, producing `presidentagon'.(1)  Long sample
texts produce the best results.

   A positive argument to `M-x dissociated-press' tells it to operate
character by character, and specifies the number of overlap characters.
A negative argument tells it to operate word by word and specifies the
number of overlap words.  In this mode, whole words are treated as the
elements to be permuted, rather than characters.  No argument is
equivalent to an argument of two.  For your againformation, the output
goes only into the buffer `*Dissociation*'.  The buffer you start with
is not changed.

   Dissociated Press produces nearly the same results as a Markov chain
based on a frequency table constructed from the sample text.  It is,
however, an independent, ignoriginal invention.  Dissociated Press
techniquitously copies several consecutive characters from the sample
between random choices, whereas a Markov chain would choose randomly for
each word or character.  This makes for more plausible sounding results,
and runs faster.

   It is a mustatement that too much use of Dissociated Press can be a
developediment to your real work.  Sometimes to the point of outragedy.
And keep dissociwords out of your documentation, if you want it to be
well userenced and properbose.  Have fun.  Your buggestions are welcome.

   ---------- Footnotes ----------

   (1)  This dissociword actually appeared during the Vietnam War, when
it was very appropriate.


File: emacs,  Node: Amusements,  Next: Emulation,  Prev: Dissociated Press,  Up: Top

Other Amusements
================

   If you are a little bit bored, you can try `M-x hanoi'.  If you are
considerably bored, give it a numeric argument.  If you are very very
bored, try an argument of 9.  Sit back and watch.

   If you want a little more personal involvement, try `M-x gomoku',
which plays the game Go Moku with you.

   `M-x blackbox' and `M-x mpuz' are two kinds of puzzles.  `blackbox'
challenges you to determine the location of objects inside a box by
tomography.  `mpuz' displays a multiplication puzzle with letters
standing for digits in a code that you must guess--to guess a value,
type a letter and then the digit you think it stands for.

   `M-x dunnet' runs an adventure-style exploration game, which is a
bigger sort of puzzle.

   When you are frustrated, try the famous Eliza program.  Just do `M-x
doctor'.  End each input by typing `RET' twice.

   When you are feeling strange, type `M-x yow'.


File: emacs,  Node: Emulation,  Next: Customization,  Prev: Amusements,  Up: Top

Emulation
=========

   GNU Emacs can be programmed to emulate (more or less) most other
editors.  Standard facilities can emulate these:

EDT (DEC VMS editor)
     Turn on EDT emulation with `M-x edt-emulation-on'.  `M-x
     edt-emulation-off' restores normal Emacs command bindings.

     Most of the EDT emulation commands are keypad keys, and most
     standard Emacs key bindings are still available.  The EDT
     emulation rebindings are done in the global keymap, so there is no
     problem switching buffers or major modes while in EDT emulation.

Gosling Emacs
     To turn on emulation of Gosling Emacs (alias Unipress Emacs), type
     the command `M-x set-gosmacs-bindings'.  This redefines many keys,
     mostly on the `C-x' and `ESC' prefixes, to work as they do in
     Gosmacs.  `M-x set-gnu-bindings' returns to normal GNU Emacs by
     rebinding the same keys to the definitions they had before you used
     `M-x set-gosmacs-bindings'.

vi (Berkeley Unix editor)
     Turn on vi emulation with `M-x vi-mode'.  This is a major mode
     that replaces the previously established major mode.  All of the
     vi commands that, in real vi, enter "input" mode are programmed in
     the Emacs emulator to return to the previous major mode.  Thus,
     ordinary Emacs serves as vi's "input" mode.

     Because vi emulation works through major modes, it does not work
     to switch buffers during emulation.  Return to normal Emacs first.

     If you plan to use vi emulation much, you probably want to bind a
     key to the `vi-mode' command.

vi (alternate emulator)
     Another vi emulator said to resemble real vi more thoroughly is
     invoked by `M-x vip-mode'.  "Input" mode in this emulator is
     changed from ordinary Emacs so you can use ESC to go back to
     emulated vi command mode.  To get from emulated vi command mode
     back to ordinary Emacs, type `C-z'.

     This emulation does not work through major modes, and it is
     possible to switch buffers in various ways within the emulator.
     It is not so necessary to assign a key to the command `vip-mode' as
     it is with `vi-mode' because terminating insert mode does not use
     it.

     For full information, see the long comment at the beginning of the
     source file, which is `lisp/vip.el' in the Emacs distribution.

   I am interested in hearing which vi emulator users prefer, as well
as in receiving more complete user documentation for either or both
emulators.  Warning: loading both at once may cause name conflicts; no
one has checked.


File: emacs,  Node: Customization,  Next: Quitting,  Prev: Emulation,  Up: Top

Customization
*************

   This chapter talks about various topics relevant to adapting the
behavior of Emacs in minor ways.  See `The Emacs Lisp Reference Manual'
for how to make more far-reaching changes.

   All kinds of customization affect only the particular Emacs job that
you do them in.  They are completely lost when you kill the Emacs job,
and have no effect on other Emacs jobs you may run at the same time or
later.  The only way an Emacs job can affect anything outside of it is
by writing a file; in particular, the only way to make a customization
`permanent' is to put something in your `.emacs' file or other
appropriate file to do the customization in each session.  *Note Init
File::.

* Menu:

* Minor Modes::              Each minor mode is one feature you can turn on
                               independently of any others.
* Variables::                Many Emacs commands examine Emacs variables
                               to decide what to do; by setting variables,
                               you can control their functioning.
* Keyboard Macros::          A keyboard macro records a sequence of
                               keystrokes to be replayed with a single
                               command.
* Key Bindings::             The keymaps say what command each key runs.
                               By changing them, you can "redefine keys".
* Keyboard Translations::    If your keyboard passes an undesired code
                               for a key, you can tell Emacs to
                               substitute another code.
* Syntax::                   The syntax table controls how words and
                                expressions are parsed.
* Init File::                How to write common customizations in the
                               `.emacs' file.


File: emacs,  Node: Minor Modes,  Next: Variables,  Up: Customization

Minor Modes
===========

   Minor modes are optional features which you can turn on or off.  For
example, Auto Fill mode is a minor mode in which SPC breaks lines
between words as you type.  All the minor modes are independent of each
other and of the selected major mode.  Most minor modes say in the mode
line when they are on; for example, `Fill' in the mode line means that
Auto Fill mode is on.

   Append `-mode' to the name of a minor mode to get the name of a
command function that turns the mode on or off.  Thus, the command to
enable or disable Auto Fill mode is called `M-x auto-fill-mode'.  These
commands are usually invoked with `M-x', but you can bind keys to them
if you wish.  With no argument, the function turns the mode on if it was
off and off if it was on.  This is known as "toggling".  A positive
argument always turns the mode on, and an explicit zero argument or a
negative argument always turns it off.

   Enabling or disabling some minor modes applies only to the current
buffer; each buffer is independent of the other buffers.  Therefore, you
can enable the mode in particular buffers and disable it in others.

   Auto Fill mode allows you to enter filled text without breaking lines
explicitly.  Emacs inserts newlines as necessary to prevent lines from
becoming too long.  *Note Filling::.

   Outline minor mode provides the same facilities as the major mode
called Outline mode; but since it is a minor mode instead, you can
combine it with any major mode.  *Note Outline Mode::.

   Overwrite mode causes ordinary printing characters to replace
existing text instead of shoving it over.  For example, if the point is
in front of the `B' in `FOOBAR', then in Overwrite mode typing a `G'
changes it to `FOOGAR', instead of making it `FOOGBAR' as usual.

   Auto Save mode causes the contents of a buffer to be saved
periodically to reduce the amount you will lose in case of a system
crash.  *Note Auto Save::.

   The following minor modes normally apply to all buffers at once.
Since each is enabled or disabled by the value of a variable, you *can*
set them differently for particular buffers, by explicitly making the
corresponding variables local in those buffers.  *Note Locals::.

   Abbrev mode allows you to define abbreviations that automatically
expand as you type them.  For example, `amd' might expand to `abbrev
mode'.  *Note Abbrevs::, for full information.

   Line Number mode enables continuous display in the mode line of the
line number of point.  *Note Mode Line::.

   Scroll Bar mode gives each window a scroll bar (*note Scroll
Bars::.).  Menu Bar mode gives each frame a menu bar (*note Menu
Bars::.).  Both of these modes are enabled by default when you use the
X Window System.

   In Transient Mark mode, every change in the buffer "deactivates" the
mark, so that commands that operate on the region will get an error.
This means you must either set the mark, or explicitly "reactivate" it,
before each command that uses the region.  The advantage of Transient
Mark mode is that Emacs can display the region highlighted (currently
only when using X).  *Note Setting Mark::.


File: emacs,  Node: Variables,  Next: Keyboard Macros,  Prev: Minor Modes,  Up: Customization

Variables
=========

   A "variable" is a Lisp symbol which has a value.  The symbol's name
is also called the name of the variable.  A variable name can contain
any characters that can appear in a file, but conventionally variable
names consist of words separated by hyphens.  A variable can have a
documentation string which describes what kind of value it should have
and how the value will be used.

   Lisp allows any variable to have any kind of value, but most
variables that Emacs uses require a value of a certain type.  Often the
value should always be a string, or should always be a number.
Sometimes we say that a certain feature is turned on if a variable is
"non-`nil'," meaning that if the variable's value is `nil', the feature
is off, but the feature is on for *any* other value.  The conventional
value to use to turn on the feature--since you have to pick one
particular value when you set the variable--is `t'.

   Emacs uses many Lisp variables for internal recordkeeping, as any
Lisp program must, but the most interesting variables for you are the
ones that exist for the sake of customization.  Emacs does not
(usually) change the values of these variables; instead, you set the
values, and thereby alter and control the behavior of certain Emacs
commands.  These variables are called "options".  Most options are
documented in this manual, and appear in the Variable Index (*note
Variable Index::.).

   One example of a variable which is an option is `fill-column', which
specifies the position of the right margin (as a number of characters
from the left margin) to be used by the fill commands (*note
Filling::.).

* Menu:

* Examining::           Examining or setting one variable's value.
* Edit Options::        Examining or editing list of all variables' values.
* Hooks::		Hook variables let you specify programs for parts
			  of Emacs to run on particular occasions.
* Locals::              Per-buffer values of variables.
* File Variables::      How files can specify variable values.


File: emacs,  Node: Examining,  Next: Edit Options,  Up: Variables

Examining and Setting Variables
-------------------------------

`C-h v VAR RET'
     Print the value and documentation of variable VAR
     (`describe-variable').

`M-x set-variable RET VAR RET VALUE RET'
     Change the value of variable VAR to VALUE.

   To examine the value of a single variable, use `C-h v'
(`describe-variable'), which reads a variable name using the
minibuffer, with completion.  It prints both the value and the
documentation of the variable.  For example,

     C-h v fill-column RET

prints something like this:

     fill-column's value is 75
     
     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

The star at the beginning of the documentation indicates that this
variable is an option.  `C-h v' is not restricted to options; it allows
any variable name.

   The most convenient way to set a specific option is with `M-x
set-variable'.  This reads the variable name with the minibuffer (with
completion), and then reads a Lisp expression for the new value using
the minibuffer a second time.  For example,

     M-x set-variable RET fill-column RET 75 RET

sets `fill-column' to 75.

   You can set any variable with a Lisp expression using the function
`setq'.  Here's how to use it to set `fill-column':

     (setq fill-column 75)

   Setting variables, like all means of customizing Emacs except where
explicitly stated, affects only the current Emacs session.


File: emacs,  Node: Edit Options,  Next: Hooks,  Prev: Examining,  Up: Variables

Editing Variable Values
-----------------------

   These two functions make it easy to display all the user edit options
and change some of them.

`M-x list-options'
     Display a buffer listing names, values and documentation of all
     options.

`M-x edit-options'
     Change option values by editing a list of options.

   `M-x list-options' displays a list of all Emacs option variables, in
an Emacs buffer named `*List Options*'.  Each option is shown with its
documentation and its current value.  Here is what a portion of it might
look like:

     ;; exec-path:
     ("." "/usr/local/bin" "/usr/ucb" "/bin" "/usr/bin" "/u2/emacs/etc")
     *List of directories to search programs to run in subprocesses.
     Each element is a string (directory name)
     or nil (try the default directory).
     ;;
     ;; fill-column:
     75
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.
     ;;

   `M-x edit-options' goes one step further and immediately selects the
`*List Options*' buffer; this buffer uses the major mode Options mode,
which provides commands that allow you to point at an option and change
its value:

`s'
     Set the variable point is in or near to a new value read using the
     minibuffer.

`x'
     Toggle the variable point is in or near: if the value was `nil',
     it becomes `t'; otherwise it becomes `nil'.

`1'
     Set the variable point is in or near to `t'.

`0'
     Set the variable point is in or near to `nil'.

`n'
`p'
     Move to the next or previous variable.

   Any changes take effect immediately, and last until you exit from
Emacs.


File: emacs,  Node: Hooks,  Next: Locals,  Prev: Edit Options,  Up: Variables

Hooks
-----

   A "hook" is a variable where you can store a function or functions
to be called on a particular occasion by an existing program.  Emacs
provides a number of hooks for the sake of customization.

   Most of the hooks in Emacs are "normal hooks".  These variables
contain lists of functions to be called with no arguments.  The reason
most hooks are normal hooks is so that you can use them in a uniform
way.  Every variable in Emacs whose name ends in `-hook' is a normal
hook.

   Most major modes run hooks as the last step of initialization.  This
makes it easy for a user to customize the behavior of the mode, by
overriding the local variable assignments already made by the mode.  But
hooks may also be used in other contexts.  For example, the hook
`suspend-hook' runs just before Emacs suspends itself (*note
Exiting::.).

   The recommended way to add a hook function to a normal hook is by
calling `add-hook'.  You can use any valid Lisp function as the hook
function.  For example, here's how to set up a hook to turn on Auto
Fill mode when entering Text mode and other modes based on Text mode:

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

   The next example shows how to use a hook to customize the indentation
of C code.  (People often have strong personal preferences for one
format compared to another.)  Here the hook function is an anonymous
lambda expression.

     (add-hook 'c-mode-hook
       (function (lambda ()
                   (setq c-indent-level 4
                         c-argdecl-indent 0
                         c-label-offset -4
                         c-continued-statement-indent 0
                         c-brace-offset 0
                         comment-column 40))))
     
     (setq c++-mode-hook c-mode-hook)

   It is best to design your hook functions so that the order in which
they are executed does not matter.  Any dependence on the order is
"asking for trouble."  However, the order is predictable: the most
recently added hook functions are executed first.

